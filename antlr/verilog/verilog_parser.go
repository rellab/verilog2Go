// Code generated from Verilog.g4 by ANTLR 4.7.2. DO NOT EDIT.

package parser // Verilog

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 182, 4037,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 4, 183,
	9, 183, 4, 184, 9, 184, 4, 185, 9, 185, 4, 186, 9, 186, 4, 187, 9, 187,
	4, 188, 9, 188, 4, 189, 9, 189, 4, 190, 9, 190, 4, 191, 9, 191, 4, 192,
	9, 192, 4, 193, 9, 193, 4, 194, 9, 194, 4, 195, 9, 195, 4, 196, 9, 196,
	4, 197, 9, 197, 4, 198, 9, 198, 4, 199, 9, 199, 4, 200, 9, 200, 4, 201,
	9, 201, 4, 202, 9, 202, 4, 203, 9, 203, 4, 204, 9, 204, 4, 205, 9, 205,
	4, 206, 9, 206, 4, 207, 9, 207, 4, 208, 9, 208, 4, 209, 9, 209, 4, 210,
	9, 210, 4, 211, 9, 211, 4, 212, 9, 212, 4, 213, 9, 213, 4, 214, 9, 214,
	4, 215, 9, 215, 4, 216, 9, 216, 4, 217, 9, 217, 4, 218, 9, 218, 4, 219,
	9, 219, 4, 220, 9, 220, 4, 221, 9, 221, 4, 222, 9, 222, 4, 223, 9, 223,
	4, 224, 9, 224, 4, 225, 9, 225, 4, 226, 9, 226, 4, 227, 9, 227, 4, 228,
	9, 228, 4, 229, 9, 229, 4, 230, 9, 230, 4, 231, 9, 231, 4, 232, 9, 232,
	4, 233, 9, 233, 4, 234, 9, 234, 4, 235, 9, 235, 4, 236, 9, 236, 4, 237,
	9, 237, 4, 238, 9, 238, 4, 239, 9, 239, 4, 240, 9, 240, 4, 241, 9, 241,
	4, 242, 9, 242, 4, 243, 9, 243, 4, 244, 9, 244, 4, 245, 9, 245, 4, 246,
	9, 246, 4, 247, 9, 247, 4, 248, 9, 248, 4, 249, 9, 249, 4, 250, 9, 250,
	4, 251, 9, 251, 4, 252, 9, 252, 4, 253, 9, 253, 4, 254, 9, 254, 4, 255,
	9, 255, 4, 256, 9, 256, 4, 257, 9, 257, 4, 258, 9, 258, 4, 259, 9, 259,
	4, 260, 9, 260, 4, 261, 9, 261, 4, 262, 9, 262, 4, 263, 9, 263, 4, 264,
	9, 264, 4, 265, 9, 265, 4, 266, 9, 266, 4, 267, 9, 267, 4, 268, 9, 268,
	4, 269, 9, 269, 4, 270, 9, 270, 4, 271, 9, 271, 4, 272, 9, 272, 4, 273,
	9, 273, 4, 274, 9, 274, 4, 275, 9, 275, 4, 276, 9, 276, 4, 277, 9, 277,
	4, 278, 9, 278, 4, 279, 9, 279, 4, 280, 9, 280, 4, 281, 9, 281, 4, 282,
	9, 282, 4, 283, 9, 283, 4, 284, 9, 284, 4, 285, 9, 285, 4, 286, 9, 286,
	4, 287, 9, 287, 4, 288, 9, 288, 4, 289, 9, 289, 4, 290, 9, 290, 4, 291,
	9, 291, 4, 292, 9, 292, 4, 293, 9, 293, 4, 294, 9, 294, 4, 295, 9, 295,
	4, 296, 9, 296, 4, 297, 9, 297, 4, 298, 9, 298, 4, 299, 9, 299, 4, 300,
	9, 300, 4, 301, 9, 301, 4, 302, 9, 302, 4, 303, 9, 303, 4, 304, 9, 304,
	4, 305, 9, 305, 4, 306, 9, 306, 4, 307, 9, 307, 4, 308, 9, 308, 4, 309,
	9, 309, 4, 310, 9, 310, 4, 311, 9, 311, 4, 312, 9, 312, 4, 313, 9, 313,
	3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 7, 2, 632, 10, 2, 12, 2, 14, 2, 635, 11,
	2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 643, 10, 3, 3, 3, 7, 3, 646,
	10, 3, 12, 3, 14, 3, 649, 11, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3,
	4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4, 668,
	10, 4, 3, 5, 3, 5, 3, 6, 3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 7, 7, 678, 10, 7,
	12, 7, 14, 7, 681, 11, 7, 3, 8, 3, 8, 7, 8, 685, 10, 8, 12, 8, 14, 8, 688,
	11, 8, 3, 9, 3, 9, 3, 9, 3, 9, 5, 9, 694, 10, 9, 3, 9, 3, 9, 3, 10, 3,
	10, 3, 10, 3, 10, 5, 10, 702, 10, 10, 3, 10, 3, 10, 5, 10, 706, 10, 10,
	3, 11, 5, 11, 709, 10, 11, 3, 11, 7, 11, 712, 10, 11, 12, 11, 14, 11, 715,
	11, 11, 3, 11, 7, 11, 718, 10, 11, 12, 11, 14, 11, 721, 11, 11, 3, 11,
	3, 11, 3, 12, 3, 12, 3, 13, 7, 13, 728, 10, 13, 12, 13, 14, 13, 731, 11,
	13, 3, 13, 3, 13, 3, 13, 5, 13, 736, 10, 13, 3, 13, 5, 13, 739, 10, 13,
	3, 13, 3, 13, 7, 13, 743, 10, 13, 12, 13, 14, 13, 746, 11, 13, 3, 13, 3,
	13, 3, 13, 7, 13, 751, 10, 13, 12, 13, 14, 13, 754, 11, 13, 3, 13, 3, 13,
	3, 13, 5, 13, 759, 10, 13, 3, 13, 5, 13, 762, 10, 13, 3, 13, 3, 13, 7,
	13, 766, 10, 13, 12, 13, 14, 13, 769, 11, 13, 3, 13, 3, 13, 5, 13, 773,
	10, 13, 3, 14, 3, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 7, 15, 782, 10,
	15, 12, 15, 14, 15, 785, 11, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 16, 3,
	16, 7, 16, 793, 10, 16, 12, 16, 14, 16, 796, 11, 16, 3, 16, 3, 16, 3, 17,
	3, 17, 3, 17, 3, 17, 7, 17, 804, 10, 17, 12, 17, 14, 17, 807, 11, 17, 3,
	17, 3, 17, 3, 17, 3, 17, 5, 17, 813, 10, 17, 3, 18, 5, 18, 816, 10, 18,
	3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 822, 10, 18, 3, 18, 3, 18, 5, 18, 826,
	10, 18, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 7, 19, 833, 10, 19, 12, 19,
	14, 19, 836, 11, 19, 3, 19, 3, 19, 5, 19, 840, 10, 19, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 853,
	10, 20, 3, 21, 7, 21, 856, 10, 21, 12, 21, 14, 21, 859, 11, 21, 3, 21,
	3, 21, 7, 21, 863, 10, 21, 12, 21, 14, 21, 866, 11, 21, 3, 21, 3, 21, 7,
	21, 870, 10, 21, 12, 21, 14, 21, 873, 11, 21, 3, 21, 5, 21, 876, 10, 21,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 7, 22, 883, 10, 22, 12, 22, 14, 22,
	886, 11, 22, 3, 22, 3, 22, 7, 22, 890, 10, 22, 12, 22, 14, 22, 893, 11,
	22, 3, 22, 3, 22, 7, 22, 897, 10, 22, 12, 22, 14, 22, 900, 11, 22, 3, 22,
	3, 22, 7, 22, 904, 10, 22, 12, 22, 14, 22, 907, 11, 22, 3, 22, 3, 22, 7,
	22, 911, 10, 22, 12, 22, 14, 22, 914, 11, 22, 3, 22, 5, 22, 917, 10, 22,
	3, 23, 7, 23, 920, 10, 23, 12, 23, 14, 23, 923, 11, 23, 3, 23, 3, 23, 7,
	23, 927, 10, 23, 12, 23, 14, 23, 930, 11, 23, 3, 23, 3, 23, 7, 23, 934,
	10, 23, 12, 23, 14, 23, 937, 11, 23, 3, 23, 3, 23, 7, 23, 941, 10, 23,
	12, 23, 14, 23, 944, 11, 23, 3, 23, 3, 23, 7, 23, 948, 10, 23, 12, 23,
	14, 23, 951, 11, 23, 3, 23, 3, 23, 7, 23, 955, 10, 23, 12, 23, 14, 23,
	958, 11, 23, 3, 23, 3, 23, 7, 23, 962, 10, 23, 12, 23, 14, 23, 965, 11,
	23, 3, 23, 5, 23, 968, 10, 23, 3, 24, 7, 24, 971, 10, 24, 12, 24, 14, 24,
	974, 11, 24, 3, 24, 3, 24, 7, 24, 978, 10, 24, 12, 24, 14, 24, 981, 11,
	24, 3, 24, 3, 24, 7, 24, 985, 10, 24, 12, 24, 14, 24, 988, 11, 24, 3, 24,
	3, 24, 7, 24, 992, 10, 24, 12, 24, 14, 24, 995, 11, 24, 3, 24, 3, 24, 7,
	24, 999, 10, 24, 12, 24, 14, 24, 1002, 11, 24, 3, 24, 3, 24, 7, 24, 1006,
	10, 24, 12, 24, 14, 24, 1009, 11, 24, 3, 24, 5, 24, 1012, 10, 24, 3, 25,
	3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 5, 25, 1024,
	10, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3, 27, 3, 27, 5, 27, 1032, 10, 27,
	3, 27, 5, 27, 1035, 10, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3,
	27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 5, 27, 1060, 10, 27, 3, 28, 3,
	28, 3, 28, 3, 29, 3, 29, 5, 29, 1067, 10, 29, 3, 29, 5, 29, 1070, 10, 29,
	3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 3, 29, 5, 29, 1085, 10, 29, 3, 30, 3, 30, 5, 30, 1089, 10, 30,
	3, 30, 3, 30, 3, 30, 3, 31, 3, 31, 5, 31, 1096, 10, 31, 3, 31, 5, 31, 1099,
	10, 31, 3, 31, 5, 31, 1102, 10, 31, 3, 31, 3, 31, 3, 32, 3, 32, 5, 32,
	1108, 10, 32, 3, 32, 5, 32, 1111, 10, 32, 3, 32, 5, 32, 1114, 10, 32, 3,
	32, 3, 32, 3, 33, 3, 33, 5, 33, 1120, 10, 33, 3, 33, 5, 33, 1123, 10, 33,
	3, 33, 5, 33, 1126, 10, 33, 3, 33, 3, 33, 3, 33, 5, 33, 1131, 10, 33, 3,
	33, 5, 33, 1134, 10, 33, 3, 33, 5, 33, 1137, 10, 33, 3, 33, 3, 33, 3, 33,
	3, 33, 5, 33, 1143, 10, 33, 3, 33, 5, 33, 1146, 10, 33, 3, 33, 3, 33, 3,
	33, 5, 33, 1151, 10, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 1158,
	10, 33, 3, 34, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 36,
	3, 36, 3, 36, 3, 36, 3, 37, 3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 3, 38, 3,
	38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 40, 3, 40, 5, 40, 1186, 10, 40, 3, 40,
	5, 40, 1189, 10, 40, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 5, 41, 1196, 10,
	41, 3, 41, 5, 41, 1199, 10, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41,
	1206, 10, 41, 3, 41, 5, 41, 1209, 10, 41, 3, 41, 5, 41, 1212, 10, 41, 3,
	41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 1219, 10, 41, 3, 41, 5, 41, 1222,
	10, 41, 3, 41, 5, 41, 1225, 10, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41,
	5, 41, 1232, 10, 41, 3, 41, 5, 41, 1235, 10, 41, 3, 41, 5, 41, 1238, 10,
	41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 1245, 10, 41, 3, 41, 5, 41,
	1248, 10, 41, 3, 41, 5, 41, 1251, 10, 41, 3, 41, 3, 41, 5, 41, 1255, 10,
	41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 1262, 10, 41, 3, 41, 5, 41,
	1265, 10, 41, 3, 41, 5, 41, 1268, 10, 41, 3, 41, 3, 41, 5, 41, 1272, 10,
	41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 1279, 10, 41, 3, 41, 5, 41,
	1282, 10, 41, 3, 41, 5, 41, 1285, 10, 41, 3, 41, 3, 41, 5, 41, 1289, 10,
	41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 1296, 10, 41, 3, 41, 5, 41,
	1299, 10, 41, 3, 41, 3, 41, 5, 41, 1303, 10, 41, 3, 41, 3, 41, 3, 41, 5,
	41, 1308, 10, 41, 3, 42, 3, 42, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 5, 44,
	1317, 10, 44, 3, 44, 3, 44, 3, 44, 7, 44, 1322, 10, 44, 12, 44, 14, 44,
	1325, 11, 44, 5, 44, 1327, 10, 44, 3, 45, 3, 45, 3, 45, 5, 45, 1332, 10,
	45, 3, 45, 3, 45, 3, 45, 7, 45, 1337, 10, 45, 12, 45, 14, 45, 1340, 11,
	45, 5, 45, 1342, 10, 45, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 1380, 10,
	46, 3, 47, 3, 47, 3, 48, 3, 48, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49,
	3, 49, 3, 49, 3, 49, 5, 49, 1395, 10, 49, 3, 50, 3, 50, 3, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 1406, 10, 50, 5, 50, 1408, 10, 50,
	3, 50, 3, 50, 5, 50, 1412, 10, 50, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3,
	51, 3, 51, 5, 51, 1421, 10, 51, 3, 51, 3, 51, 5, 51, 1425, 10, 51, 3, 52,
	3, 52, 3, 52, 3, 52, 5, 52, 1431, 10, 52, 3, 53, 3, 53, 3, 53, 7, 53, 1436,
	10, 53, 12, 53, 14, 53, 1439, 11, 53, 5, 53, 1441, 10, 53, 3, 53, 3, 53,
	3, 53, 3, 53, 7, 53, 1447, 10, 53, 12, 53, 14, 53, 1450, 11, 53, 5, 53,
	1452, 10, 53, 7, 53, 1454, 10, 53, 12, 53, 14, 53, 1457, 11, 53, 3, 54,
	3, 54, 3, 54, 7, 54, 1462, 10, 54, 12, 54, 14, 54, 1465, 11, 54, 5, 54,
	1467, 10, 54, 3, 54, 3, 54, 3, 54, 3, 54, 7, 54, 1473, 10, 54, 12, 54,
	14, 54, 1476, 11, 54, 5, 54, 1478, 10, 54, 7, 54, 1480, 10, 54, 12, 54,
	14, 54, 1483, 11, 54, 3, 55, 3, 55, 3, 55, 7, 55, 1488, 10, 55, 12, 55,
	14, 55, 1491, 11, 55, 3, 56, 3, 56, 3, 56, 7, 56, 1496, 10, 56, 12, 56,
	14, 56, 1499, 11, 56, 3, 57, 3, 57, 3, 57, 7, 57, 1504, 10, 57, 12, 57,
	14, 57, 1507, 11, 57, 3, 58, 3, 58, 3, 58, 7, 58, 1512, 10, 58, 12, 58,
	14, 58, 1515, 11, 58, 3, 59, 3, 59, 3, 59, 7, 59, 1520, 10, 59, 12, 59,
	14, 59, 1523, 11, 59, 3, 60, 3, 60, 3, 60, 7, 60, 1528, 10, 60, 12, 60,
	14, 60, 1531, 11, 60, 3, 61, 3, 61, 3, 61, 7, 61, 1536, 10, 61, 12, 61,
	14, 61, 1539, 11, 61, 3, 62, 3, 62, 3, 62, 5, 62, 1544, 10, 62, 3, 62,
	3, 62, 3, 62, 3, 62, 5, 62, 1550, 10, 62, 7, 62, 1552, 10, 62, 12, 62,
	14, 62, 1555, 11, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 64, 3, 64, 3, 64,
	3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 5, 65, 1570, 10, 65, 3, 66, 3,
	66, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 1578, 10, 66, 3, 66, 3, 66, 3, 66,
	3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 1592,
	10, 66, 3, 66, 3, 66, 3, 66, 5, 66, 1597, 10, 66, 3, 67, 3, 67, 3, 68,
	3, 68, 3, 69, 3, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 71, 3,
	71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 72, 3, 72, 5, 72, 1619, 10, 72, 3, 72,
	5, 72, 1622, 10, 72, 3, 72, 5, 72, 1625, 10, 72, 3, 72, 3, 72, 3, 72, 7,
	72, 1630, 10, 72, 12, 72, 14, 72, 1633, 11, 72, 3, 72, 5, 72, 1636, 10,
	72, 3, 72, 3, 72, 3, 72, 3, 72, 5, 72, 1642, 10, 72, 3, 72, 5, 72, 1645,
	10, 72, 3, 72, 5, 72, 1648, 10, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72,
	3, 72, 7, 72, 1656, 10, 72, 12, 72, 14, 72, 1659, 11, 72, 3, 72, 5, 72,
	1662, 10, 72, 3, 72, 3, 72, 5, 72, 1666, 10, 72, 3, 73, 3, 73, 3, 73, 3,
	73, 5, 73, 1672, 10, 73, 3, 74, 3, 74, 3, 74, 7, 74, 1677, 10, 74, 12,
	74, 14, 74, 1680, 11, 74, 3, 75, 7, 75, 1683, 10, 75, 12, 75, 14, 75, 1686,
	11, 75, 3, 75, 3, 75, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 1695, 10,
	76, 3, 77, 3, 77, 5, 77, 1699, 10, 77, 3, 77, 3, 77, 3, 77, 7, 77, 1704,
	10, 77, 12, 77, 14, 77, 1707, 11, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77,
	5, 77, 1714, 10, 77, 3, 77, 3, 77, 3, 77, 5, 77, 1719, 10, 77, 3, 77, 3,
	77, 3, 77, 7, 77, 1724, 10, 77, 12, 77, 14, 77, 1727, 11, 77, 3, 77, 3,
	77, 3, 77, 5, 77, 1732, 10, 77, 3, 78, 3, 78, 7, 78, 1736, 10, 78, 12,
	78, 14, 78, 1739, 11, 78, 3, 78, 3, 78, 3, 78, 5, 78, 1744, 10, 78, 3,
	79, 3, 79, 3, 79, 7, 79, 1749, 10, 79, 12, 79, 14, 79, 1752, 11, 79, 3,
	80, 7, 80, 1755, 10, 80, 12, 80, 14, 80, 1758, 11, 80, 3, 80, 3, 80, 3,
	81, 3, 81, 5, 81, 1764, 10, 81, 3, 81, 5, 81, 1767, 10, 81, 3, 81, 5, 81,
	1770, 10, 81, 3, 81, 5, 81, 1773, 10, 81, 3, 81, 3, 81, 5, 81, 1777, 10,
	81, 3, 81, 5, 81, 1780, 10, 81, 5, 81, 1782, 10, 81, 3, 82, 3, 82, 3, 82,
	3, 83, 3, 83, 3, 84, 7, 84, 1790, 10, 84, 12, 84, 14, 84, 1793, 11, 84,
	3, 84, 3, 84, 7, 84, 1797, 10, 84, 12, 84, 14, 84, 1800, 11, 84, 3, 84,
	3, 84, 7, 84, 1804, 10, 84, 12, 84, 14, 84, 1807, 11, 84, 3, 84, 3, 84,
	7, 84, 1811, 10, 84, 12, 84, 14, 84, 1814, 11, 84, 3, 84, 3, 84, 7, 84,
	1818, 10, 84, 12, 84, 14, 84, 1821, 11, 84, 3, 84, 3, 84, 7, 84, 1825,
	10, 84, 12, 84, 14, 84, 1828, 11, 84, 3, 84, 3, 84, 7, 84, 1832, 10, 84,
	12, 84, 14, 84, 1835, 11, 84, 3, 84, 3, 84, 7, 84, 1839, 10, 84, 12, 84,
	14, 84, 1842, 11, 84, 3, 84, 5, 84, 1845, 10, 84, 3, 85, 3, 85, 5, 85,
	1849, 10, 85, 3, 85, 5, 85, 1852, 10, 85, 3, 85, 3, 85, 3, 85, 3, 86, 3,
	86, 3, 86, 7, 86, 1860, 10, 86, 12, 86, 14, 86, 1863, 11, 86, 3, 87, 3,
	87, 3, 87, 3, 87, 7, 87, 1869, 10, 87, 12, 87, 14, 87, 1872, 11, 87, 5,
	87, 1874, 10, 87, 3, 88, 3, 88, 5, 88, 1878, 10, 88, 3, 88, 3, 88, 3, 88,
	7, 88, 1883, 10, 88, 12, 88, 14, 88, 1886, 11, 88, 3, 88, 3, 88, 3, 88,
	3, 88, 5, 88, 1892, 10, 88, 3, 88, 3, 88, 3, 88, 7, 88, 1897, 10, 88, 12,
	88, 14, 88, 1900, 11, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 7,
	88, 1908, 10, 88, 12, 88, 14, 88, 1911, 11, 88, 3, 88, 3, 88, 3, 88, 3,
	88, 5, 88, 1917, 10, 88, 3, 88, 3, 88, 3, 88, 7, 88, 1922, 10, 88, 12,
	88, 14, 88, 1925, 11, 88, 3, 88, 3, 88, 3, 88, 3, 88, 5, 88, 1931, 10,
	88, 3, 88, 3, 88, 3, 88, 7, 88, 1936, 10, 88, 12, 88, 14, 88, 1939, 11,
	88, 3, 88, 3, 88, 3, 88, 3, 88, 5, 88, 1945, 10, 88, 3, 88, 5, 88, 1948,
	10, 88, 3, 88, 3, 88, 3, 88, 7, 88, 1953, 10, 88, 12, 88, 14, 88, 1956,
	11, 88, 3, 88, 3, 88, 3, 88, 3, 88, 5, 88, 1962, 10, 88, 3, 88, 5, 88,
	1965, 10, 88, 3, 88, 3, 88, 3, 88, 7, 88, 1970, 10, 88, 12, 88, 14, 88,
	1973, 11, 88, 3, 88, 3, 88, 3, 88, 3, 88, 5, 88, 1979, 10, 88, 3, 88, 5,
	88, 1982, 10, 88, 3, 88, 3, 88, 3, 88, 7, 88, 1987, 10, 88, 12, 88, 14,
	88, 1990, 11, 88, 3, 88, 3, 88, 3, 88, 3, 88, 5, 88, 1996, 10, 88, 3, 88,
	3, 88, 3, 88, 7, 88, 2001, 10, 88, 12, 88, 14, 88, 2004, 11, 88, 3, 88,
	3, 88, 5, 88, 2008, 10, 88, 3, 89, 5, 89, 2011, 10, 89, 3, 89, 3, 89, 3,
	89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 90, 5, 90, 2024,
	10, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 91,
	5, 91, 2035, 10, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3,
	91, 3, 92, 5, 92, 2046, 10, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92,
	7, 92, 2054, 10, 92, 12, 92, 14, 92, 2057, 11, 92, 3, 92, 3, 92, 3, 93,
	5, 93, 2062, 10, 93, 3, 93, 3, 93, 3, 93, 3, 93, 7, 93, 2068, 10, 93, 12,
	93, 14, 93, 2071, 11, 93, 3, 93, 3, 93, 3, 93, 3, 93, 3, 94, 5, 94, 2078,
	10, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 3, 95, 5, 95, 2087, 10,
	95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 96, 5, 96,
	2098, 10, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 97, 3, 97, 5, 97, 2106, 10,
	97, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98,
	3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 5, 98, 2124, 10, 98, 3, 99, 3,
	99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99,
	3, 99, 3, 99, 3, 99, 3, 99, 5, 99, 2142, 10, 99, 3, 100, 3, 100, 3, 101,
	3, 101, 3, 102, 3, 102, 3, 103, 3, 103, 3, 104, 3, 104, 3, 105, 3, 105,
	3, 106, 3, 106, 3, 107, 3, 107, 3, 108, 3, 108, 3, 109, 3, 109, 3, 110,
	3, 110, 3, 111, 3, 111, 3, 112, 3, 112, 3, 113, 3, 113, 5, 113, 2172, 10,
	113, 3, 113, 3, 113, 3, 113, 7, 113, 2177, 10, 113, 12, 113, 14, 113, 2180,
	11, 113, 3, 113, 3, 113, 3, 114, 3, 114, 3, 114, 3, 114, 3, 114, 3, 115,
	3, 115, 3, 115, 7, 115, 2192, 10, 115, 12, 115, 14, 115, 2195, 11, 115,
	3, 115, 3, 115, 3, 115, 7, 115, 2200, 10, 115, 12, 115, 14, 115, 2203,
	11, 115, 5, 115, 2205, 10, 115, 3, 116, 3, 116, 3, 117, 3, 117, 3, 117,
	3, 117, 5, 117, 2213, 10, 117, 3, 117, 3, 117, 3, 118, 3, 118, 3, 118,
	3, 118, 3, 118, 3, 119, 3, 119, 5, 119, 2224, 10, 119, 3, 120, 3, 120,
	3, 120, 7, 120, 2229, 10, 120, 12, 120, 14, 120, 2232, 11, 120, 3, 120,
	3, 120, 3, 120, 7, 120, 2237, 10, 120, 12, 120, 14, 120, 2240, 11, 120,
	5, 120, 2242, 10, 120, 3, 121, 7, 121, 2245, 10, 121, 12, 121, 14, 121,
	2248, 11, 121, 3, 121, 5, 121, 2251, 10, 121, 3, 122, 7, 122, 2254, 10,
	122, 12, 122, 14, 122, 2257, 11, 122, 3, 122, 3, 122, 3, 122, 3, 122, 5,
	122, 2263, 10, 122, 3, 122, 3, 122, 3, 123, 3, 123, 7, 123, 2269, 10, 123,
	12, 123, 14, 123, 2272, 11, 123, 3, 123, 3, 123, 3, 124, 3, 124, 5, 124,
	2278, 10, 124, 3, 125, 3, 125, 3, 125, 3, 125, 3, 125, 5, 125, 2285, 10,
	125, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 5, 126, 2294,
	10, 126, 3, 127, 3, 127, 3, 127, 3, 127, 3, 127, 3, 127, 7, 127, 2302,
	10, 127, 12, 127, 14, 127, 2305, 11, 127, 3, 127, 3, 127, 3, 128, 3, 128,
	3, 128, 7, 128, 2312, 10, 128, 12, 128, 14, 128, 2315, 11, 128, 3, 128,
	3, 128, 3, 128, 3, 128, 3, 128, 5, 128, 2322, 10, 128, 3, 128, 5, 128,
	2325, 10, 128, 3, 129, 3, 129, 3, 129, 3, 129, 3, 129, 3, 129, 3, 129,
	3, 129, 3, 129, 3, 129, 3, 130, 3, 130, 3, 130, 3, 130, 3, 131, 3, 131,
	3, 131, 5, 131, 2344, 10, 131, 3, 131, 7, 131, 2347, 10, 131, 12, 131,
	14, 131, 2350, 11, 131, 3, 131, 3, 131, 3, 132, 3, 132, 5, 132, 2356, 10,
	132, 3, 132, 5, 132, 2359, 10, 132, 3, 132, 3, 132, 3, 132, 3, 133, 3,
	133, 3, 133, 7, 133, 2367, 10, 133, 12, 133, 14, 133, 2370, 11, 133, 3,
	134, 3, 134, 3, 134, 3, 134, 3, 135, 3, 135, 3, 135, 3, 136, 3, 136, 3,
	136, 3, 137, 3, 137, 3, 137, 5, 137, 2385, 10, 137, 3, 137, 3, 137, 3,
	138, 3, 138, 3, 138, 5, 138, 2392, 10, 138, 3, 138, 3, 138, 3, 139, 3,
	139, 3, 139, 3, 139, 3, 139, 3, 139, 3, 139, 3, 139, 3, 139, 3, 139, 3,
	139, 3, 139, 5, 139, 2408, 10, 139, 3, 140, 3, 140, 3, 140, 3, 140, 3,
	141, 3, 141, 7, 141, 2416, 10, 141, 12, 141, 14, 141, 2419, 11, 141, 3,
	141, 5, 141, 2422, 10, 141, 3, 142, 3, 142, 3, 142, 3, 142, 7, 142, 2428,
	10, 142, 12, 142, 14, 142, 2431, 11, 142, 5, 142, 2433, 10, 142, 3, 142,
	7, 142, 2436, 10, 142, 12, 142, 14, 142, 2439, 11, 142, 3, 142, 3, 142,
	3, 143, 3, 143, 3, 143, 3, 143, 3, 144, 3, 144, 3, 144, 3, 144, 7, 144,
	2451, 10, 144, 12, 144, 14, 144, 2454, 11, 144, 5, 144, 2456, 10, 144,
	3, 144, 7, 144, 2459, 10, 144, 12, 144, 14, 144, 2462, 11, 144, 3, 144,
	3, 144, 3, 145, 3, 145, 3, 145, 3, 145, 7, 145, 2470, 10, 145, 12, 145,
	14, 145, 2473, 11, 145, 5, 145, 2475, 10, 145, 3, 145, 7, 145, 2478, 10,
	145, 12, 145, 14, 145, 2481, 11, 145, 3, 145, 3, 145, 3, 146, 7, 146, 2486,
	10, 146, 12, 146, 14, 146, 2489, 11, 146, 3, 146, 3, 146, 3, 146, 3, 146,
	7, 146, 2495, 10, 146, 12, 146, 14, 146, 2498, 11, 146, 3, 146, 3, 146,
	7, 146, 2502, 10, 146, 12, 146, 14, 146, 2505, 11, 146, 3, 146, 3, 146,
	7, 146, 2509, 10, 146, 12, 146, 14, 146, 2512, 11, 146, 3, 146, 3, 146,
	7, 146, 2516, 10, 146, 12, 146, 14, 146, 2519, 11, 146, 3, 146, 3, 146,
	7, 146, 2523, 10, 146, 12, 146, 14, 146, 2526, 11, 146, 3, 146, 3, 146,
	7, 146, 2530, 10, 146, 12, 146, 14, 146, 2533, 11, 146, 3, 146, 3, 146,
	3, 146, 3, 146, 7, 146, 2539, 10, 146, 12, 146, 14, 146, 2542, 11, 146,
	3, 146, 3, 146, 7, 146, 2546, 10, 146, 12, 146, 14, 146, 2549, 11, 146,
	3, 146, 3, 146, 3, 146, 3, 146, 7, 146, 2555, 10, 146, 12, 146, 14, 146,
	2558, 11, 146, 3, 146, 3, 146, 7, 146, 2562, 10, 146, 12, 146, 14, 146,
	2565, 11, 146, 3, 146, 3, 146, 7, 146, 2569, 10, 146, 12, 146, 14, 146,
	2572, 11, 146, 3, 146, 3, 146, 7, 146, 2576, 10, 146, 12, 146, 14, 146,
	2579, 11, 146, 3, 146, 3, 146, 7, 146, 2583, 10, 146, 12, 146, 14, 146,
	2586, 11, 146, 3, 146, 5, 146, 2589, 10, 146, 3, 147, 3, 147, 7, 147, 2593,
	10, 147, 12, 147, 14, 147, 2596, 11, 147, 3, 147, 5, 147, 2599, 10, 147,
	3, 148, 7, 148, 2602, 10, 148, 12, 148, 14, 148, 2605, 11, 148, 3, 148,
	3, 148, 3, 148, 3, 148, 7, 148, 2611, 10, 148, 12, 148, 14, 148, 2614,
	11, 148, 3, 148, 3, 148, 7, 148, 2618, 10, 148, 12, 148, 14, 148, 2621,
	11, 148, 3, 148, 3, 148, 7, 148, 2625, 10, 148, 12, 148, 14, 148, 2628,
	11, 148, 3, 148, 3, 148, 7, 148, 2632, 10, 148, 12, 148, 14, 148, 2635,
	11, 148, 3, 148, 3, 148, 7, 148, 2639, 10, 148, 12, 148, 14, 148, 2642,
	11, 148, 3, 148, 3, 148, 7, 148, 2646, 10, 148, 12, 148, 14, 148, 2649,
	11, 148, 3, 148, 5, 148, 2652, 10, 148, 3, 149, 3, 149, 3, 149, 3, 149,
	3, 149, 3, 149, 3, 149, 3, 149, 5, 149, 2662, 10, 149, 3, 150, 3, 150,
	3, 150, 3, 150, 3, 150, 3, 150, 3, 150, 5, 150, 2671, 10, 150, 3, 151,
	3, 151, 3, 151, 3, 151, 3, 151, 3, 151, 3, 151, 3, 151, 5, 151, 2681, 10,
	151, 3, 152, 3, 152, 3, 152, 3, 152, 3, 152, 3, 152, 3, 152, 3, 152, 3,
	152, 3, 152, 3, 152, 3, 152, 3, 152, 5, 152, 2696, 10, 152, 3, 153, 3,
	153, 3, 153, 3, 153, 3, 154, 3, 154, 3, 154, 3, 154, 3, 154, 7, 154, 2707,
	10, 154, 12, 154, 14, 154, 2710, 11, 154, 3, 155, 3, 155, 3, 155, 3, 155,
	3, 155, 5, 155, 2717, 10, 155, 3, 156, 3, 156, 3, 156, 3, 157, 3, 157,
	3, 157, 3, 157, 3, 157, 3, 157, 3, 158, 3, 158, 3, 158, 3, 158, 3, 158,
	3, 158, 3, 158, 3, 158, 5, 158, 2736, 10, 158, 3, 158, 5, 158, 2739, 10,
	158, 3, 159, 3, 159, 3, 159, 3, 159, 3, 159, 3, 159, 3, 159, 3, 159, 3,
	159, 3, 159, 3, 159, 3, 159, 7, 159, 2753, 10, 159, 12, 159, 14, 159, 2756,
	11, 159, 3, 159, 3, 159, 3, 159, 5, 159, 2761, 10, 159, 3, 160, 3, 160,
	3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 5, 161,
	2773, 10, 161, 3, 161, 5, 161, 2776, 10, 161, 3, 162, 3, 162, 3, 162, 3,
	162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 7,
	162, 2790, 10, 162, 12, 162, 14, 162, 2793, 11, 162, 3, 162, 3, 162, 5,
	162, 2797, 10, 162, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163, 7,
	163, 2805, 10, 163, 12, 163, 14, 163, 2808, 11, 163, 3, 163, 3, 163, 3,
	163, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163, 7, 163, 2818, 10, 163, 12,
	163, 14, 163, 2821, 11, 163, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163, 3,
	163, 3, 163, 3, 163, 7, 163, 2831, 10, 163, 12, 163, 14, 163, 2834, 11,
	163, 3, 163, 3, 163, 5, 163, 2838, 10, 163, 3, 164, 3, 164, 3, 164, 7,
	164, 2843, 10, 164, 12, 164, 14, 164, 2846, 11, 164, 3, 164, 3, 164, 3,
	164, 3, 164, 3, 164, 5, 164, 2853, 10, 164, 3, 164, 5, 164, 2856, 10, 164,
	3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 7, 165, 2864, 10, 165,
	12, 165, 14, 165, 2867, 11, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165,
	3, 165, 3, 165, 3, 165, 7, 165, 2877, 10, 165, 12, 165, 14, 165, 2880,
	11, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165,
	7, 165, 2890, 10, 165, 12, 165, 14, 165, 2893, 11, 165, 3, 165, 3, 165,
	5, 165, 2897, 10, 165, 3, 166, 3, 166, 3, 166, 7, 166, 2902, 10, 166, 12,
	166, 14, 166, 2905, 11, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 5,
	166, 2912, 10, 166, 3, 166, 5, 166, 2915, 10, 166, 3, 167, 3, 167, 3, 167,
	3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167,
	3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167,
	3, 167, 3, 167, 3, 167, 5, 167, 2941, 10, 167, 3, 168, 3, 168, 3, 168,
	3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168,
	3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168,
	3, 168, 3, 168, 3, 168, 5, 168, 2967, 10, 168, 3, 169, 3, 169, 3, 169,
	3, 169, 3, 169, 7, 169, 2974, 10, 169, 12, 169, 14, 169, 2977, 11, 169,
	5, 169, 2979, 10, 169, 3, 169, 5, 169, 2982, 10, 169, 3, 169, 3, 169, 3,
	170, 3, 170, 3, 170, 3, 170, 3, 170, 7, 170, 2991, 10, 170, 12, 170, 14,
	170, 2994, 11, 170, 5, 170, 2996, 10, 170, 3, 170, 5, 170, 2999, 10, 170,
	3, 170, 3, 170, 3, 171, 3, 171, 7, 171, 3005, 10, 171, 12, 171, 14, 171,
	3008, 11, 171, 3, 171, 3, 171, 3, 172, 3, 172, 3, 172, 3, 172, 5, 172,
	3016, 10, 172, 3, 173, 3, 173, 3, 173, 3, 173, 3, 173, 3, 173, 3, 173,
	3, 173, 5, 173, 3026, 10, 173, 3, 174, 3, 174, 3, 174, 3, 174, 3, 174,
	3, 174, 3, 174, 3, 174, 5, 174, 3036, 10, 174, 3, 175, 3, 175, 3, 175,
	3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 5, 175, 3047, 10, 175,
	3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 5, 176,
	3057, 10, 176, 3, 177, 3, 177, 5, 177, 3061, 10, 177, 3, 177, 3, 177, 3,
	177, 3, 178, 3, 178, 3, 178, 5, 178, 3069, 10, 178, 3, 178, 3, 178, 3,
	178, 3, 178, 3, 179, 3, 179, 3, 179, 7, 179, 3078, 10, 179, 12, 179, 14,
	179, 3081, 11, 179, 3, 180, 3, 180, 3, 180, 7, 180, 3086, 10, 180, 12,
	180, 14, 180, 3089, 11, 180, 3, 181, 3, 181, 3, 181, 3, 181, 3, 181, 3,
	181, 3, 181, 3, 181, 3, 181, 3, 181, 3, 181, 5, 181, 3102, 10, 181, 3,
	182, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 3,
	182, 3, 182, 5, 182, 3115, 10, 182, 3, 183, 3, 183, 5, 183, 3119, 10, 183,
	3, 184, 3, 184, 5, 184, 3123, 10, 184, 3, 185, 3, 185, 3, 185, 3, 185,
	3, 185, 5, 185, 3130, 10, 185, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186,
	3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186,
	3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186,
	3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186,
	3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186,
	3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 5, 186, 3179, 10, 186,
	3, 187, 3, 187, 3, 188, 3, 188, 3, 189, 3, 189, 3, 190, 3, 190, 3, 191,
	3, 191, 3, 192, 3, 192, 3, 193, 3, 193, 3, 194, 3, 194, 3, 195, 3, 195,
	3, 196, 3, 196, 3, 197, 3, 197, 3, 198, 3, 198, 3, 199, 3, 199, 3, 200,
	3, 200, 3, 201, 3, 201, 3, 202, 3, 202, 3, 203, 3, 203, 3, 204, 3, 204,
	3, 204, 3, 204, 3, 204, 3, 204, 3, 204, 3, 204, 5, 204, 3223, 10, 204,
	3, 205, 3, 205, 5, 205, 3227, 10, 205, 3, 205, 3, 205, 3, 205, 3, 205,
	5, 205, 3233, 10, 205, 3, 205, 3, 205, 3, 205, 3, 205, 3, 206, 3, 206,
	5, 206, 3241, 10, 206, 3, 206, 3, 206, 3, 206, 3, 206, 5, 206, 3247, 10,
	206, 3, 206, 3, 206, 3, 206, 3, 206, 3, 207, 3, 207, 3, 208, 3, 208, 3,
	209, 3, 209, 3, 209, 3, 209, 3, 209, 3, 209, 3, 209, 3, 209, 3, 209, 3,
	209, 3, 209, 3, 209, 3, 209, 3, 209, 5, 209, 3271, 10, 209, 3, 210, 3,
	210, 3, 211, 3, 211, 3, 212, 3, 212, 3, 212, 3, 212, 3, 212, 3, 212, 5,
	212, 3283, 10, 212, 3, 213, 3, 213, 3, 213, 3, 213, 3, 213, 3, 213, 5,
	213, 3291, 10, 213, 3, 214, 3, 214, 3, 215, 3, 215, 3, 216, 3, 216, 3,
	217, 3, 217, 3, 218, 3, 218, 3, 219, 3, 219, 3, 220, 3, 220, 3, 221, 3,
	221, 3, 222, 3, 222, 3, 222, 3, 222, 7, 222, 3313, 10, 222, 12, 222, 14,
	222, 3316, 11, 222, 3, 222, 3, 222, 3, 223, 3, 223, 3, 223, 3, 223, 7,
	223, 3324, 10, 223, 12, 223, 14, 223, 3327, 11, 223, 3, 223, 3, 223, 3,
	224, 3, 224, 3, 224, 3, 224, 3, 224, 3, 225, 3, 225, 3, 225, 3, 225, 7,
	225, 3340, 10, 225, 12, 225, 14, 225, 3343, 11, 225, 3, 225, 3, 225, 3,
	226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 227, 3, 227, 3, 227, 3, 227, 3,
	227, 3, 228, 3, 228, 3, 228, 3, 228, 7, 228, 3361, 10, 228, 12, 228, 14,
	228, 3364, 11, 228, 3, 228, 3, 228, 3, 229, 3, 229, 3, 229, 3, 229, 3,
	229, 3, 229, 3, 229, 3, 229, 3, 229, 7, 229, 3377, 10, 229, 12, 229, 14,
	229, 3380, 11, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3,
	229, 3, 229, 7, 229, 3390, 10, 229, 12, 229, 14, 229, 3393, 11, 229, 3,
	229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3,
	229, 5, 229, 3405, 10, 229, 3, 230, 3, 230, 3, 230, 3, 230, 7, 230, 3411,
	10, 230, 12, 230, 14, 230, 3414, 11, 230, 3, 230, 3, 230, 3, 231, 3, 231,
	3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 7, 231, 3427, 10,
	231, 12, 231, 14, 231, 3430, 11, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3,
	231, 3, 231, 3, 231, 3, 231, 7, 231, 3440, 10, 231, 12, 231, 14, 231, 3443,
	11, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231, 3, 231,
	3, 231, 3, 231, 5, 231, 3455, 10, 231, 3, 232, 3, 232, 7, 232, 3459, 10,
	232, 12, 232, 14, 232, 3462, 11, 232, 3, 232, 3, 232, 3, 232, 3, 232, 7,
	232, 3468, 10, 232, 12, 232, 14, 232, 3471, 11, 232, 5, 232, 3473, 10,
	232, 3, 232, 3, 232, 3, 233, 3, 233, 7, 233, 3479, 10, 233, 12, 233, 14,
	233, 3482, 11, 233, 3, 233, 3, 233, 3, 233, 3, 233, 7, 233, 3488, 10, 233,
	12, 233, 14, 233, 3491, 11, 233, 5, 233, 3493, 10, 233, 3, 233, 3, 233,
	3, 234, 3, 234, 3, 234, 3, 234, 7, 234, 3501, 10, 234, 12, 234, 14, 234,
	3504, 11, 234, 5, 234, 3506, 10, 234, 3, 235, 3, 235, 7, 235, 3510, 10,
	235, 12, 235, 14, 235, 3513, 11, 235, 3, 235, 3, 235, 3, 235, 3, 235, 7,
	235, 3519, 10, 235, 12, 235, 14, 235, 3522, 11, 235, 5, 235, 3524, 10,
	235, 3, 235, 3, 235, 3, 236, 3, 236, 3, 237, 3, 237, 3, 238, 3, 238, 3,
	239, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 5, 239, 3541, 10,
	239, 3, 240, 3, 240, 3, 240, 3, 240, 3, 240, 3, 240, 3, 240, 3, 240, 3,
	240, 3, 240, 3, 240, 3, 240, 3, 240, 5, 240, 3556, 10, 240, 3, 241, 3,
	241, 3, 242, 3, 242, 3, 242, 7, 242, 3563, 10, 242, 12, 242, 14, 242, 3566,
	11, 242, 3, 242, 3, 242, 3, 242, 3, 242, 7, 242, 3572, 10, 242, 12, 242,
	14, 242, 3575, 11, 242, 3, 242, 3, 242, 3, 242, 3, 242, 7, 242, 3581, 10,
	242, 12, 242, 14, 242, 3584, 11, 242, 3, 243, 3, 243, 7, 243, 3588, 10,
	243, 12, 243, 14, 243, 3591, 11, 243, 3, 243, 3, 243, 3, 243, 3, 243, 3,
	243, 3, 243, 3, 243, 5, 243, 3600, 10, 243, 3, 244, 3, 244, 3, 245, 3,
	245, 3, 245, 3, 245, 3, 245, 3, 245, 5, 245, 3610, 10, 245, 3, 246, 3,
	246, 3, 246, 7, 246, 3615, 10, 246, 12, 246, 14, 246, 3618, 11, 246, 3,
	246, 3, 246, 3, 246, 3, 246, 3, 247, 3, 247, 3, 247, 7, 247, 3627, 10,
	247, 12, 247, 14, 247, 3630, 11, 247, 3, 247, 3, 247, 5, 247, 3634, 10,
	247, 3, 247, 3, 247, 7, 247, 3638, 10, 247, 12, 247, 14, 247, 3641, 11,
	247, 3, 247, 3, 247, 3, 247, 3, 247, 7, 247, 3647, 10, 247, 12, 247, 14,
	247, 3650, 11, 247, 3, 247, 3, 247, 3, 247, 3, 247, 7, 247, 3656, 10, 247,
	12, 247, 14, 247, 3659, 11, 247, 3, 248, 3, 248, 3, 248, 3, 248, 3, 248,
	3, 248, 5, 248, 3667, 10, 248, 3, 249, 3, 249, 3, 250, 3, 250, 3, 250,
	3, 250, 3, 250, 3, 250, 3, 250, 3, 250, 3, 250, 3, 250, 3, 250, 3, 250,
	3, 250, 5, 250, 3684, 10, 250, 3, 251, 3, 251, 3, 252, 3, 252, 3, 252,
	3, 252, 3, 252, 3, 252, 3, 252, 3, 252, 3, 252, 3, 252, 3, 252, 5, 252,
	3699, 10, 252, 3, 253, 3, 253, 3, 253, 3, 253, 3, 253, 3, 253, 3, 253,
	3, 253, 3, 253, 3, 253, 3, 253, 5, 253, 3712, 10, 253, 3, 254, 3, 254,
	3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254,
	6, 254, 3725, 10, 254, 13, 254, 14, 254, 3726, 3, 254, 3, 254, 3, 254,
	3, 254, 3, 254, 3, 254, 3, 254, 6, 254, 3736, 10, 254, 13, 254, 14, 254,
	3737, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3,
	254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3,
	254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3,
	254, 3, 254, 3, 254, 3, 254, 3, 254, 5, 254, 3771, 10, 254, 3, 255, 3,
	255, 3, 255, 3, 255, 3, 255, 3, 255, 3, 255, 3, 255, 3, 255, 7, 255, 3782,
	10, 255, 12, 255, 14, 255, 3785, 11, 255, 3, 255, 3, 255, 3, 255, 3, 255,
	3, 255, 3, 255, 3, 255, 3, 255, 7, 255, 3795, 10, 255, 12, 255, 14, 255,
	3798, 11, 255, 3, 255, 3, 255, 3, 255, 3, 255, 3, 255, 3, 255, 3, 255,
	3, 255, 3, 255, 3, 255, 5, 255, 3810, 10, 255, 3, 256, 3, 256, 3, 256,
	3, 256, 3, 256, 3, 256, 3, 256, 3, 256, 3, 256, 7, 256, 3821, 10, 256,
	12, 256, 14, 256, 3824, 11, 256, 3, 256, 3, 256, 3, 256, 3, 256, 3, 256,
	3, 256, 3, 256, 3, 256, 7, 256, 3834, 10, 256, 12, 256, 14, 256, 3837,
	11, 256, 3, 256, 3, 256, 3, 256, 3, 256, 3, 256, 3, 256, 3, 256, 3, 256,
	3, 256, 3, 256, 5, 256, 3849, 10, 256, 3, 257, 3, 257, 3, 258, 3, 258,
	3, 259, 3, 259, 3, 260, 3, 260, 3, 261, 3, 261, 3, 262, 3, 262, 3, 262,
	3, 262, 3, 262, 3, 263, 3, 263, 3, 263, 3, 263, 3, 264, 3, 264, 3, 264,
	3, 264, 3, 264, 7, 264, 3875, 10, 264, 12, 264, 14, 264, 3878, 11, 264,
	3, 264, 3, 264, 3, 264, 3, 265, 3, 265, 3, 265, 3, 265, 3, 265, 5, 265,
	3888, 10, 265, 3, 266, 3, 266, 3, 267, 3, 267, 5, 267, 3894, 10, 267, 3,
	268, 3, 268, 3, 269, 3, 269, 3, 270, 3, 270, 3, 271, 3, 271, 3, 272, 3,
	272, 5, 272, 3906, 10, 272, 3, 273, 3, 273, 3, 273, 3, 273, 3, 273, 7,
	273, 3913, 10, 273, 12, 273, 14, 273, 3916, 11, 273, 3, 274, 3, 274, 3,
	275, 3, 275, 3, 276, 3, 276, 3, 277, 3, 277, 3, 278, 3, 278, 3, 279, 3,
	279, 3, 280, 3, 280, 3, 281, 3, 281, 3, 282, 3, 282, 3, 283, 3, 283, 5,
	283, 3938, 10, 283, 3, 284, 3, 284, 3, 285, 3, 285, 3, 286, 3, 286, 3,
	287, 3, 287, 3, 288, 3, 288, 3, 289, 3, 289, 3, 290, 3, 290, 3, 291, 3,
	291, 3, 292, 3, 292, 3, 293, 3, 293, 3, 294, 3, 294, 3, 295, 3, 295, 3,
	296, 3, 296, 3, 297, 3, 297, 3, 298, 3, 298, 3, 299, 3, 299, 3, 300, 3,
	300, 5, 300, 3974, 10, 300, 3, 301, 3, 301, 3, 301, 5, 301, 3979, 10, 301,
	3, 302, 3, 302, 3, 303, 3, 303, 3, 304, 3, 304, 3, 305, 3, 305, 3, 306,
	3, 306, 3, 307, 3, 307, 3, 308, 3, 308, 3, 309, 3, 309, 3, 310, 3, 310,
	3, 311, 3, 311, 3, 312, 3, 312, 3, 312, 3, 312, 5, 312, 4005, 10, 312,
	3, 312, 3, 312, 3, 312, 3, 312, 3, 312, 5, 312, 4012, 10, 312, 7, 312,
	4014, 10, 312, 12, 312, 14, 312, 4017, 11, 312, 3, 313, 3, 313, 3, 313,
	3, 313, 5, 313, 4023, 10, 313, 3, 313, 3, 313, 3, 313, 3, 313, 3, 313,
	5, 313, 4030, 10, 313, 7, 313, 4032, 10, 313, 12, 313, 14, 313, 4035, 11,
	313, 3, 313, 2, 2, 314, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
	28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
	64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98,
	100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128,
	130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158,
	160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188,
	190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218,
	220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248,
	250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278,
	280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308,
	310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338,
	340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368,
	370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 398,
	400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426, 428,
	430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 458,
	460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482, 484, 486, 488,
	490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 512, 514, 516, 518,
	520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548,
	550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 576, 578,
	580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 602, 604, 606, 608,
	610, 612, 614, 616, 618, 620, 622, 624, 2, 25, 3, 2, 15, 16, 3, 2, 41,
	42, 3, 2, 43, 52, 4, 2, 28, 28, 31, 31, 4, 2, 43, 43, 56, 58, 4, 2, 44,
	44, 59, 61, 3, 2, 34, 36, 3, 2, 28, 31, 3, 2, 75, 76, 3, 2, 77, 80, 3,
	2, 81, 84, 3, 2, 85, 90, 3, 2, 91, 92, 3, 2, 93, 96, 3, 2, 97, 98, 3, 2,
	122, 123, 3, 2, 138, 139, 4, 2, 138, 139, 143, 151, 8, 2, 111, 111, 120,
	120, 138, 139, 145, 145, 147, 147, 149, 167, 3, 2, 143, 151, 7, 2, 145,
	145, 147, 147, 149, 151, 154, 155, 158, 159, 3, 2, 170, 174, 3, 2, 178,
	179, 2, 4292, 2, 626, 3, 2, 2, 2, 4, 638, 3, 2, 2, 2, 6, 667, 3, 2, 2,
	2, 8, 669, 3, 2, 2, 2, 10, 671, 3, 2, 2, 2, 12, 674, 3, 2, 2, 2, 14, 682,
	3, 2, 2, 2, 16, 689, 3, 2, 2, 2, 18, 697, 3, 2, 2, 2, 20, 708, 3, 2, 2,
	2, 22, 724, 3, 2, 2, 2, 24, 772, 3, 2, 2, 2, 26, 774, 3, 2, 2, 2, 28, 776,
	3, 2, 2, 2, 30, 788, 3, 2, 2, 2, 32, 812, 3, 2, 2, 2, 34, 825, 3, 2, 2,
	2, 36, 839, 3, 2, 2, 2, 38, 852, 3, 2, 2, 2, 40, 875, 3, 2, 2, 2, 42, 916,
	3, 2, 2, 2, 44, 967, 3, 2, 2, 2, 46, 1011, 3, 2, 2, 2, 48, 1023, 3, 2,
	2, 2, 50, 1025, 3, 2, 2, 2, 52, 1059, 3, 2, 2, 2, 54, 1061, 3, 2, 2, 2,
	56, 1084, 3, 2, 2, 2, 58, 1086, 3, 2, 2, 2, 60, 1093, 3, 2, 2, 2, 62, 1105,
	3, 2, 2, 2, 64, 1157, 3, 2, 2, 2, 66, 1159, 3, 2, 2, 2, 68, 1163, 3, 2,
	2, 2, 70, 1167, 3, 2, 2, 2, 72, 1171, 3, 2, 2, 2, 74, 1175, 3, 2, 2, 2,
	76, 1179, 3, 2, 2, 2, 78, 1183, 3, 2, 2, 2, 80, 1307, 3, 2, 2, 2, 82, 1309,
	3, 2, 2, 2, 84, 1311, 3, 2, 2, 2, 86, 1326, 3, 2, 2, 2, 88, 1341, 3, 2,
	2, 2, 90, 1379, 3, 2, 2, 2, 92, 1381, 3, 2, 2, 2, 94, 1383, 3, 2, 2, 2,
	96, 1394, 3, 2, 2, 2, 98, 1411, 3, 2, 2, 2, 100, 1424, 3, 2, 2, 2, 102,
	1430, 3, 2, 2, 2, 104, 1432, 3, 2, 2, 2, 106, 1458, 3, 2, 2, 2, 108, 1484,
	3, 2, 2, 2, 110, 1492, 3, 2, 2, 2, 112, 1500, 3, 2, 2, 2, 114, 1508, 3,
	2, 2, 2, 116, 1516, 3, 2, 2, 2, 118, 1524, 3, 2, 2, 2, 120, 1532, 3, 2,
	2, 2, 122, 1540, 3, 2, 2, 2, 124, 1556, 3, 2, 2, 2, 126, 1560, 3, 2, 2,
	2, 128, 1569, 3, 2, 2, 2, 130, 1596, 3, 2, 2, 2, 132, 1598, 3, 2, 2, 2,
	134, 1600, 3, 2, 2, 2, 136, 1602, 3, 2, 2, 2, 138, 1604, 3, 2, 2, 2, 140,
	1610, 3, 2, 2, 2, 142, 1665, 3, 2, 2, 2, 144, 1671, 3, 2, 2, 2, 146, 1673,
	3, 2, 2, 2, 148, 1684, 3, 2, 2, 2, 150, 1694, 3, 2, 2, 2, 152, 1731, 3,
	2, 2, 2, 154, 1743, 3, 2, 2, 2, 156, 1745, 3, 2, 2, 2, 158, 1756, 3, 2,
	2, 2, 160, 1781, 3, 2, 2, 2, 162, 1783, 3, 2, 2, 2, 164, 1786, 3, 2, 2,
	2, 166, 1844, 3, 2, 2, 2, 168, 1846, 3, 2, 2, 2, 170, 1856, 3, 2, 2, 2,
	172, 1873, 3, 2, 2, 2, 174, 2007, 3, 2, 2, 2, 176, 2010, 3, 2, 2, 2, 178,
	2023, 3, 2, 2, 2, 180, 2034, 3, 2, 2, 2, 182, 2045, 3, 2, 2, 2, 184, 2061,
	3, 2, 2, 2, 186, 2077, 3, 2, 2, 2, 188, 2086, 3, 2, 2, 2, 190, 2097, 3,
	2, 2, 2, 192, 2103, 3, 2, 2, 2, 194, 2123, 3, 2, 2, 2, 196, 2141, 3, 2,
	2, 2, 198, 2143, 3, 2, 2, 2, 200, 2145, 3, 2, 2, 2, 202, 2147, 3, 2, 2,
	2, 204, 2149, 3, 2, 2, 2, 206, 2151, 3, 2, 2, 2, 208, 2153, 3, 2, 2, 2,
	210, 2155, 3, 2, 2, 2, 212, 2157, 3, 2, 2, 2, 214, 2159, 3, 2, 2, 2, 216,
	2161, 3, 2, 2, 2, 218, 2163, 3, 2, 2, 2, 220, 2165, 3, 2, 2, 2, 222, 2167,
	3, 2, 2, 2, 224, 2169, 3, 2, 2, 2, 226, 2183, 3, 2, 2, 2, 228, 2204, 3,
	2, 2, 2, 230, 2206, 3, 2, 2, 2, 232, 2208, 3, 2, 2, 2, 234, 2216, 3, 2,
	2, 2, 236, 2221, 3, 2, 2, 2, 238, 2241, 3, 2, 2, 2, 240, 2246, 3, 2, 2,
	2, 242, 2255, 3, 2, 2, 2, 244, 2266, 3, 2, 2, 2, 246, 2277, 3, 2, 2, 2,
	248, 2284, 3, 2, 2, 2, 250, 2286, 3, 2, 2, 2, 252, 2295, 3, 2, 2, 2, 254,
	2324, 3, 2, 2, 2, 256, 2326, 3, 2, 2, 2, 258, 2336, 3, 2, 2, 2, 260, 2340,
	3, 2, 2, 2, 262, 2353, 3, 2, 2, 2, 264, 2363, 3, 2, 2, 2, 266, 2371, 3,
	2, 2, 2, 268, 2375, 3, 2, 2, 2, 270, 2378, 3, 2, 2, 2, 272, 2381, 3, 2,
	2, 2, 274, 2388, 3, 2, 2, 2, 276, 2407, 3, 2, 2, 2, 278, 2409, 3, 2, 2,
	2, 280, 2421, 3, 2, 2, 2, 282, 2423, 3, 2, 2, 2, 284, 2442, 3, 2, 2, 2,
	286, 2446, 3, 2, 2, 2, 288, 2465, 3, 2, 2, 2, 290, 2588, 3, 2, 2, 2, 292,
	2598, 3, 2, 2, 2, 294, 2651, 3, 2, 2, 2, 296, 2661, 3, 2, 2, 2, 298, 2670,
	3, 2, 2, 2, 300, 2680, 3, 2, 2, 2, 302, 2695, 3, 2, 2, 2, 304, 2697, 3,
	2, 2, 2, 306, 2701, 3, 2, 2, 2, 308, 2716, 3, 2, 2, 2, 310, 2718, 3, 2,
	2, 2, 312, 2721, 3, 2, 2, 2, 314, 2738, 3, 2, 2, 2, 316, 2740, 3, 2, 2,
	2, 318, 2762, 3, 2, 2, 2, 320, 2775, 3, 2, 2, 2, 322, 2777, 3, 2, 2, 2,
	324, 2837, 3, 2, 2, 2, 326, 2855, 3, 2, 2, 2, 328, 2896, 3, 2, 2, 2, 330,
	2914, 3, 2, 2, 2, 332, 2940, 3, 2, 2, 2, 334, 2966, 3, 2, 2, 2, 336, 2968,
	3, 2, 2, 2, 338, 2985, 3, 2, 2, 2, 340, 3002, 3, 2, 2, 2, 342, 3015, 3,
	2, 2, 2, 344, 3025, 3, 2, 2, 2, 346, 3035, 3, 2, 2, 2, 348, 3046, 3, 2,
	2, 2, 350, 3056, 3, 2, 2, 2, 352, 3058, 3, 2, 2, 2, 354, 3065, 3, 2, 2,
	2, 356, 3074, 3, 2, 2, 2, 358, 3082, 3, 2, 2, 2, 360, 3101, 3, 2, 2, 2,
	362, 3114, 3, 2, 2, 2, 364, 3118, 3, 2, 2, 2, 366, 3122, 3, 2, 2, 2, 368,
	3129, 3, 2, 2, 2, 370, 3178, 3, 2, 2, 2, 372, 3180, 3, 2, 2, 2, 374, 3182,
	3, 2, 2, 2, 376, 3184, 3, 2, 2, 2, 378, 3186, 3, 2, 2, 2, 380, 3188, 3,
	2, 2, 2, 382, 3190, 3, 2, 2, 2, 384, 3192, 3, 2, 2, 2, 386, 3194, 3, 2,
	2, 2, 388, 3196, 3, 2, 2, 2, 390, 3198, 3, 2, 2, 2, 392, 3200, 3, 2, 2,
	2, 394, 3202, 3, 2, 2, 2, 396, 3204, 3, 2, 2, 2, 398, 3206, 3, 2, 2, 2,
	400, 3208, 3, 2, 2, 2, 402, 3210, 3, 2, 2, 2, 404, 3212, 3, 2, 2, 2, 406,
	3222, 3, 2, 2, 2, 408, 3224, 3, 2, 2, 2, 410, 3238, 3, 2, 2, 2, 412, 3252,
	3, 2, 2, 2, 414, 3254, 3, 2, 2, 2, 416, 3270, 3, 2, 2, 2, 418, 3272, 3,
	2, 2, 2, 420, 3274, 3, 2, 2, 2, 422, 3282, 3, 2, 2, 2, 424, 3290, 3, 2,
	2, 2, 426, 3292, 3, 2, 2, 2, 428, 3294, 3, 2, 2, 2, 430, 3296, 3, 2, 2,
	2, 432, 3298, 3, 2, 2, 2, 434, 3300, 3, 2, 2, 2, 436, 3302, 3, 2, 2, 2,
	438, 3304, 3, 2, 2, 2, 440, 3306, 3, 2, 2, 2, 442, 3308, 3, 2, 2, 2, 444,
	3319, 3, 2, 2, 2, 446, 3330, 3, 2, 2, 2, 448, 3335, 3, 2, 2, 2, 450, 3346,
	3, 2, 2, 2, 452, 3351, 3, 2, 2, 2, 454, 3356, 3, 2, 2, 2, 456, 3404, 3,
	2, 2, 2, 458, 3406, 3, 2, 2, 2, 460, 3454, 3, 2, 2, 2, 462, 3456, 3, 2,
	2, 2, 464, 3476, 3, 2, 2, 2, 466, 3496, 3, 2, 2, 2, 468, 3507, 3, 2, 2,
	2, 470, 3527, 3, 2, 2, 2, 472, 3529, 3, 2, 2, 2, 474, 3531, 3, 2, 2, 2,
	476, 3540, 3, 2, 2, 2, 478, 3555, 3, 2, 2, 2, 480, 3557, 3, 2, 2, 2, 482,
	3559, 3, 2, 2, 2, 484, 3599, 3, 2, 2, 2, 486, 3601, 3, 2, 2, 2, 488, 3603,
	3, 2, 2, 2, 490, 3611, 3, 2, 2, 2, 492, 3633, 3, 2, 2, 2, 494, 3660, 3,
	2, 2, 2, 496, 3668, 3, 2, 2, 2, 498, 3683, 3, 2, 2, 2, 500, 3685, 3, 2,
	2, 2, 502, 3698, 3, 2, 2, 2, 504, 3711, 3, 2, 2, 2, 506, 3770, 3, 2, 2,
	2, 508, 3809, 3, 2, 2, 2, 510, 3848, 3, 2, 2, 2, 512, 3850, 3, 2, 2, 2,
	514, 3852, 3, 2, 2, 2, 516, 3854, 3, 2, 2, 2, 518, 3856, 3, 2, 2, 2, 520,
	3858, 3, 2, 2, 2, 522, 3860, 3, 2, 2, 2, 524, 3865, 3, 2, 2, 2, 526, 3869,
	3, 2, 2, 2, 528, 3887, 3, 2, 2, 2, 530, 3889, 3, 2, 2, 2, 532, 3893, 3,
	2, 2, 2, 534, 3895, 3, 2, 2, 2, 536, 3897, 3, 2, 2, 2, 538, 3899, 3, 2,
	2, 2, 540, 3901, 3, 2, 2, 2, 542, 3903, 3, 2, 2, 2, 544, 3907, 3, 2, 2,
	2, 546, 3917, 3, 2, 2, 2, 548, 3919, 3, 2, 2, 2, 550, 3921, 3, 2, 2, 2,
	552, 3923, 3, 2, 2, 2, 554, 3925, 3, 2, 2, 2, 556, 3927, 3, 2, 2, 2, 558,
	3929, 3, 2, 2, 2, 560, 3931, 3, 2, 2, 2, 562, 3933, 3, 2, 2, 2, 564, 3937,
	3, 2, 2, 2, 566, 3939, 3, 2, 2, 2, 568, 3941, 3, 2, 2, 2, 570, 3943, 3,
	2, 2, 2, 572, 3945, 3, 2, 2, 2, 574, 3947, 3, 2, 2, 2, 576, 3949, 3, 2,
	2, 2, 578, 3951, 3, 2, 2, 2, 580, 3953, 3, 2, 2, 2, 582, 3955, 3, 2, 2,
	2, 584, 3957, 3, 2, 2, 2, 586, 3959, 3, 2, 2, 2, 588, 3961, 3, 2, 2, 2,
	590, 3963, 3, 2, 2, 2, 592, 3965, 3, 2, 2, 2, 594, 3967, 3, 2, 2, 2, 596,
	3969, 3, 2, 2, 2, 598, 3971, 3, 2, 2, 2, 600, 3975, 3, 2, 2, 2, 602, 3980,
	3, 2, 2, 2, 604, 3982, 3, 2, 2, 2, 606, 3984, 3, 2, 2, 2, 608, 3986, 3,
	2, 2, 2, 610, 3988, 3, 2, 2, 2, 612, 3990, 3, 2, 2, 2, 614, 3992, 3, 2,
	2, 2, 616, 3994, 3, 2, 2, 2, 618, 3996, 3, 2, 2, 2, 620, 3998, 3, 2, 2,
	2, 622, 4000, 3, 2, 2, 2, 624, 4018, 3, 2, 2, 2, 626, 627, 7, 3, 2, 2,
	627, 628, 5, 538, 270, 2, 628, 629, 7, 4, 2, 2, 629, 633, 5, 4, 3, 2, 630,
	632, 5, 6, 4, 2, 631, 630, 3, 2, 2, 2, 632, 635, 3, 2, 2, 2, 633, 631,
	3, 2, 2, 2, 633, 634, 3, 2, 2, 2, 634, 636, 3, 2, 2, 2, 635, 633, 3, 2,
	2, 2, 636, 637, 7, 5, 2, 2, 637, 3, 3, 2, 2, 2, 638, 647, 7, 6, 2, 2, 639,
	640, 5, 580, 291, 2, 640, 641, 7, 7, 2, 2, 641, 643, 3, 2, 2, 2, 642, 639,
	3, 2, 2, 2, 642, 643, 3, 2, 2, 2, 643, 644, 3, 2, 2, 2, 644, 646, 5, 536,
	269, 2, 645, 642, 3, 2, 2, 2, 646, 649, 3, 2, 2, 2, 647, 645, 3, 2, 2,
	2, 647, 648, 3, 2, 2, 2, 648, 650, 3, 2, 2, 2, 649, 647, 3, 2, 2, 2, 650,
	651, 7, 4, 2, 2, 651, 5, 3, 2, 2, 2, 652, 653, 5, 8, 5, 2, 653, 654, 5,
	14, 8, 2, 654, 668, 3, 2, 2, 2, 655, 656, 5, 10, 6, 2, 656, 657, 5, 14,
	8, 2, 657, 668, 3, 2, 2, 2, 658, 659, 5, 10, 6, 2, 659, 660, 5, 18, 10,
	2, 660, 668, 3, 2, 2, 2, 661, 662, 5, 16, 9, 2, 662, 663, 5, 14, 8, 2,
	663, 668, 3, 2, 2, 2, 664, 665, 5, 16, 9, 2, 665, 666, 5, 18, 10, 2, 666,
	668, 3, 2, 2, 2, 667, 652, 3, 2, 2, 2, 667, 655, 3, 2, 2, 2, 667, 658,
	3, 2, 2, 2, 667, 661, 3, 2, 2, 2, 667, 664, 3, 2, 2, 2, 668, 7, 3, 2, 2,
	2, 669, 670, 7, 8, 2, 2, 670, 9, 3, 2, 2, 2, 671, 672, 7, 9, 2, 2, 672,
	673, 5, 12, 7, 2, 673, 11, 3, 2, 2, 2, 674, 679, 5, 614, 308, 2, 675, 676,
	7, 7, 2, 2, 676, 678, 5, 578, 290, 2, 677, 675, 3, 2, 2, 2, 678, 681, 3,
	2, 2, 2, 679, 677, 3, 2, 2, 2, 679, 680, 3, 2, 2, 2, 680, 13, 3, 2, 2,
	2, 681, 679, 3, 2, 2, 2, 682, 686, 7, 10, 2, 2, 683, 685, 5, 580, 291,
	2, 684, 683, 3, 2, 2, 2, 685, 688, 3, 2, 2, 2, 686, 684, 3, 2, 2, 2, 686,
	687, 3, 2, 2, 2, 687, 15, 3, 2, 2, 2, 688, 686, 3, 2, 2, 2, 689, 693, 7,
	11, 2, 2, 690, 691, 5, 580, 291, 2, 691, 692, 7, 7, 2, 2, 692, 694, 3,
	2, 2, 2, 693, 690, 3, 2, 2, 2, 693, 694, 3, 2, 2, 2, 694, 695, 3, 2, 2,
	2, 695, 696, 5, 536, 269, 2, 696, 17, 3, 2, 2, 2, 697, 701, 7, 12, 2, 2,
	698, 699, 5, 580, 291, 2, 699, 700, 7, 7, 2, 2, 700, 702, 3, 2, 2, 2, 701,
	698, 3, 2, 2, 2, 701, 702, 3, 2, 2, 2, 702, 703, 3, 2, 2, 2, 703, 705,
	5, 536, 269, 2, 704, 706, 7, 13, 2, 2, 705, 704, 3, 2, 2, 2, 705, 706,
	3, 2, 2, 2, 706, 19, 3, 2, 2, 2, 707, 709, 5, 522, 262, 2, 708, 707, 3,
	2, 2, 2, 708, 709, 3, 2, 2, 2, 709, 713, 3, 2, 2, 2, 710, 712, 5, 524,
	263, 2, 711, 710, 3, 2, 2, 2, 712, 715, 3, 2, 2, 2, 713, 711, 3, 2, 2,
	2, 713, 714, 3, 2, 2, 2, 714, 719, 3, 2, 2, 2, 715, 713, 3, 2, 2, 2, 716,
	718, 5, 22, 12, 2, 717, 716, 3, 2, 2, 2, 718, 721, 3, 2, 2, 2, 719, 717,
	3, 2, 2, 2, 719, 720, 3, 2, 2, 2, 720, 722, 3, 2, 2, 2, 721, 719, 3, 2,
	2, 2, 722, 723, 7, 2, 2, 3, 723, 21, 3, 2, 2, 2, 724, 725, 5, 24, 13, 2,
	725, 23, 3, 2, 2, 2, 726, 728, 5, 526, 264, 2, 727, 726, 3, 2, 2, 2, 728,
	731, 3, 2, 2, 2, 729, 727, 3, 2, 2, 2, 729, 730, 3, 2, 2, 2, 730, 732,
	3, 2, 2, 2, 731, 729, 3, 2, 2, 2, 732, 733, 5, 26, 14, 2, 733, 735, 5,
	584, 293, 2, 734, 736, 5, 28, 15, 2, 735, 734, 3, 2, 2, 2, 735, 736, 3,
	2, 2, 2, 736, 738, 3, 2, 2, 2, 737, 739, 5, 30, 16, 2, 738, 737, 3, 2,
	2, 2, 738, 739, 3, 2, 2, 2, 739, 740, 3, 2, 2, 2, 740, 744, 7, 4, 2, 2,
	741, 743, 5, 42, 22, 2, 742, 741, 3, 2, 2, 2, 743, 746, 3, 2, 2, 2, 744,
	742, 3, 2, 2, 2, 744, 745, 3, 2, 2, 2, 745, 747, 3, 2, 2, 2, 746, 744,
	3, 2, 2, 2, 747, 748, 7, 14, 2, 2, 748, 773, 3, 2, 2, 2, 749, 751, 5, 526,
	264, 2, 750, 749, 3, 2, 2, 2, 751, 754, 3, 2, 2, 2, 752, 750, 3, 2, 2,
	2, 752, 753, 3, 2, 2, 2, 753, 755, 3, 2, 2, 2, 754, 752, 3, 2, 2, 2, 755,
	756, 5, 26, 14, 2, 756, 758, 5, 584, 293, 2, 757, 759, 5, 28, 15, 2, 758,
	757, 3, 2, 2, 2, 758, 759, 3, 2, 2, 2, 759, 761, 3, 2, 2, 2, 760, 762,
	5, 32, 17, 2, 761, 760, 3, 2, 2, 2, 761, 762, 3, 2, 2, 2, 762, 763, 3,
	2, 2, 2, 763, 767, 7, 4, 2, 2, 764, 766, 5, 46, 24, 2, 765, 764, 3, 2,
	2, 2, 766, 769, 3, 2, 2, 2, 767, 765, 3, 2, 2, 2, 767, 768, 3, 2, 2, 2,
	768, 770, 3, 2, 2, 2, 769, 767, 3, 2, 2, 2, 770, 771, 7, 14, 2, 2, 771,
	773, 3, 2, 2, 2, 772, 729, 3, 2, 2, 2, 772, 752, 3, 2, 2, 2, 773, 25, 3,
	2, 2, 2, 774, 775, 9, 2, 2, 2, 775, 27, 3, 2, 2, 2, 776, 777, 7, 17, 2,
	2, 777, 778, 7, 18, 2, 2, 778, 783, 5, 56, 29, 2, 779, 780, 7, 19, 2, 2,
	780, 782, 5, 56, 29, 2, 781, 779, 3, 2, 2, 2, 782, 785, 3, 2, 2, 2, 783,
	781, 3, 2, 2, 2, 783, 784, 3, 2, 2, 2, 784, 786, 3, 2, 2, 2, 785, 783,
	3, 2, 2, 2, 786, 787, 7, 20, 2, 2, 787, 29, 3, 2, 2, 2, 788, 789, 7, 18,
	2, 2, 789, 794, 5, 34, 18, 2, 790, 791, 7, 19, 2, 2, 791, 793, 5, 34, 18,
	2, 792, 790, 3, 2, 2, 2, 793, 796, 3, 2, 2, 2, 794, 792, 3, 2, 2, 2, 794,
	795, 3, 2, 2, 2, 795, 797, 3, 2, 2, 2, 796, 794, 3, 2, 2, 2, 797, 798,
	7, 20, 2, 2, 798, 31, 3, 2, 2, 2, 799, 800, 7, 18, 2, 2, 800, 805, 5, 40,
	21, 2, 801, 802, 7, 19, 2, 2, 802, 804, 5, 40, 21, 2, 803, 801, 3, 2, 2,
	2, 804, 807, 3, 2, 2, 2, 805, 803, 3, 2, 2, 2, 805, 806, 3, 2, 2, 2, 806,
	808, 3, 2, 2, 2, 807, 805, 3, 2, 2, 2, 808, 809, 7, 20, 2, 2, 809, 813,
	3, 2, 2, 2, 810, 811, 7, 18, 2, 2, 811, 813, 7, 20, 2, 2, 812, 799, 3,
	2, 2, 2, 812, 810, 3, 2, 2, 2, 813, 33, 3, 2, 2, 2, 814, 816, 5, 36, 19,
	2, 815, 814, 3, 2, 2, 2, 815, 816, 3, 2, 2, 2, 816, 826, 3, 2, 2, 2, 817,
	818, 7, 7, 2, 2, 818, 819, 5, 594, 298, 2, 819, 821, 7, 18, 2, 2, 820,
	822, 5, 36, 19, 2, 821, 820, 3, 2, 2, 2, 821, 822, 3, 2, 2, 2, 822, 823,
	3, 2, 2, 2, 823, 824, 7, 20, 2, 2, 824, 826, 3, 2, 2, 2, 825, 815, 3, 2,
	2, 2, 825, 817, 3, 2, 2, 2, 826, 35, 3, 2, 2, 2, 827, 840, 5, 38, 20, 2,
	828, 829, 7, 21, 2, 2, 829, 834, 5, 38, 20, 2, 830, 831, 7, 19, 2, 2, 831,
	833, 5, 38, 20, 2, 832, 830, 3, 2, 2, 2, 833, 836, 3, 2, 2, 2, 834, 832,
	3, 2, 2, 2, 834, 835, 3, 2, 2, 2, 835, 837, 3, 2, 2, 2, 836, 834, 3, 2,
	2, 2, 837, 838, 7, 22, 2, 2, 838, 840, 3, 2, 2, 2, 839, 827, 3, 2, 2, 2,
	839, 828, 3, 2, 2, 2, 840, 37, 3, 2, 2, 2, 841, 853, 5, 594, 298, 2, 842,
	843, 5, 594, 298, 2, 843, 844, 7, 23, 2, 2, 844, 845, 5, 474, 238, 2, 845,
	846, 7, 24, 2, 2, 846, 853, 3, 2, 2, 2, 847, 848, 5, 594, 298, 2, 848,
	849, 7, 23, 2, 2, 849, 850, 5, 498, 250, 2, 850, 851, 7, 24, 2, 2, 851,
	853, 3, 2, 2, 2, 852, 841, 3, 2, 2, 2, 852, 842, 3, 2, 2, 2, 852, 847,
	3, 2, 2, 2, 853, 39, 3, 2, 2, 2, 854, 856, 5, 526, 264, 2, 855, 854, 3,
	2, 2, 2, 856, 859, 3, 2, 2, 2, 857, 855, 3, 2, 2, 2, 857, 858, 3, 2, 2,
	2, 858, 860, 3, 2, 2, 2, 859, 857, 3, 2, 2, 2, 860, 876, 5, 60, 31, 2,
	861, 863, 5, 526, 264, 2, 862, 861, 3, 2, 2, 2, 863, 866, 3, 2, 2, 2, 864,
	862, 3, 2, 2, 2, 864, 865, 3, 2, 2, 2, 865, 867, 3, 2, 2, 2, 866, 864,
	3, 2, 2, 2, 867, 876, 5, 62, 32, 2, 868, 870, 5, 526, 264, 2, 869, 868,
	3, 2, 2, 2, 870, 873, 3, 2, 2, 2, 871, 869, 3, 2, 2, 2, 871, 872, 3, 2,
	2, 2, 872, 874, 3, 2, 2, 2, 873, 871, 3, 2, 2, 2, 874, 876, 5, 64, 33,
	2, 875, 857, 3, 2, 2, 2, 875, 864, 3, 2, 2, 2, 875, 871, 3, 2, 2, 2, 876,
	41, 3, 2, 2, 2, 877, 917, 5, 44, 23, 2, 878, 879, 5, 40, 21, 2, 879, 880,
	7, 4, 2, 2, 880, 917, 3, 2, 2, 2, 881, 883, 5, 526, 264, 2, 882, 881, 3,
	2, 2, 2, 883, 886, 3, 2, 2, 2, 884, 882, 3, 2, 2, 2, 884, 885, 3, 2, 2,
	2, 885, 887, 3, 2, 2, 2, 886, 884, 3, 2, 2, 2, 887, 917, 5, 244, 123, 2,
	888, 890, 5, 526, 264, 2, 889, 888, 3, 2, 2, 2, 890, 893, 3, 2, 2, 2, 891,
	889, 3, 2, 2, 2, 891, 892, 3, 2, 2, 2, 892, 894, 3, 2, 2, 2, 893, 891,
	3, 2, 2, 2, 894, 917, 5, 52, 27, 2, 895, 897, 5, 526, 264, 2, 896, 895,
	3, 2, 2, 2, 897, 900, 3, 2, 2, 2, 898, 896, 3, 2, 2, 2, 898, 899, 3, 2,
	2, 2, 899, 901, 3, 2, 2, 2, 900, 898, 3, 2, 2, 2, 901, 917, 5, 54, 28,
	2, 902, 904, 5, 526, 264, 2, 903, 902, 3, 2, 2, 2, 904, 907, 3, 2, 2, 2,
	905, 903, 3, 2, 2, 2, 905, 906, 3, 2, 2, 2, 906, 908, 3, 2, 2, 2, 907,
	905, 3, 2, 2, 2, 908, 917, 5, 340, 171, 2, 909, 911, 5, 526, 264, 2, 910,
	909, 3, 2, 2, 2, 911, 914, 3, 2, 2, 2, 912, 910, 3, 2, 2, 2, 912, 913,
	3, 2, 2, 2, 913, 915, 3, 2, 2, 2, 914, 912, 3, 2, 2, 2, 915, 917, 5, 58,
	30, 2, 916, 877, 3, 2, 2, 2, 916, 878, 3, 2, 2, 2, 916, 884, 3, 2, 2, 2,
	916, 891, 3, 2, 2, 2, 916, 898, 3, 2, 2, 2, 916, 905, 3, 2, 2, 2, 916,
	912, 3, 2, 2, 2, 917, 43, 3, 2, 2, 2, 918, 920, 5, 526, 264, 2, 919, 918,
	3, 2, 2, 2, 920, 923, 3, 2, 2, 2, 921, 919, 3, 2, 2, 2, 921, 922, 3, 2,
	2, 2, 922, 924, 3, 2, 2, 2, 923, 921, 3, 2, 2, 2, 924, 968, 5, 48, 25,
	2, 925, 927, 5, 526, 264, 2, 926, 925, 3, 2, 2, 2, 927, 930, 3, 2, 2, 2,
	928, 926, 3, 2, 2, 2, 928, 929, 3, 2, 2, 2, 929, 931, 3, 2, 2, 2, 930,
	928, 3, 2, 2, 2, 931, 968, 5, 50, 26, 2, 932, 934, 5, 526, 264, 2, 933,
	932, 3, 2, 2, 2, 934, 937, 3, 2, 2, 2, 935, 933, 3, 2, 2, 2, 935, 936,
	3, 2, 2, 2, 936, 938, 3, 2, 2, 2, 937, 935, 3, 2, 2, 2, 938, 968, 5, 262,
	132, 2, 939, 941, 5, 526, 264, 2, 940, 939, 3, 2, 2, 2, 941, 944, 3, 2,
	2, 2, 942, 940, 3, 2, 2, 2, 942, 943, 3, 2, 2, 2, 943, 945, 3, 2, 2, 2,
	944, 942, 3, 2, 2, 2, 945, 968, 5, 174, 88, 2, 946, 948, 5, 526, 264, 2,
	947, 946, 3, 2, 2, 2, 948, 951, 3, 2, 2, 2, 949, 947, 3, 2, 2, 2, 949,
	950, 3, 2, 2, 2, 950, 952, 3, 2, 2, 2, 951, 949, 3, 2, 2, 2, 952, 968,
	5, 224, 113, 2, 953, 955, 5, 526, 264, 2, 954, 953, 3, 2, 2, 2, 955, 958,
	3, 2, 2, 2, 956, 954, 3, 2, 2, 2, 956, 957, 3, 2, 2, 2, 957, 959, 3, 2,
	2, 2, 958, 956, 3, 2, 2, 2, 959, 968, 5, 268, 135, 2, 960, 962, 5, 526,
	264, 2, 961, 960, 3, 2, 2, 2, 962, 965, 3, 2, 2, 2, 963, 961, 3, 2, 2,
	2, 963, 964, 3, 2, 2, 2, 964, 966, 3, 2, 2, 2, 965, 963, 3, 2, 2, 2, 966,
	968, 5, 270, 136, 2, 967, 921, 3, 2, 2, 2, 967, 928, 3, 2, 2, 2, 967, 935,
	3, 2, 2, 2, 967, 942, 3, 2, 2, 2, 967, 949, 3, 2, 2, 2, 967, 956, 3, 2,
	2, 2, 967, 963, 3, 2, 2, 2, 968, 45, 3, 2, 2, 2, 969, 971, 5, 526, 264,
	2, 970, 969, 3, 2, 2, 2, 971, 974, 3, 2, 2, 2, 972, 970, 3, 2, 2, 2, 972,
	973, 3, 2, 2, 2, 973, 975, 3, 2, 2, 2, 974, 972, 3, 2, 2, 2, 975, 1012,
	5, 244, 123, 2, 976, 978, 5, 526, 264, 2, 977, 976, 3, 2, 2, 2, 978, 981,
	3, 2, 2, 2, 979, 977, 3, 2, 2, 2, 979, 980, 3, 2, 2, 2, 980, 982, 3, 2,
	2, 2, 981, 979, 3, 2, 2, 2, 982, 1012, 5, 52, 27, 2, 983, 985, 5, 526,
	264, 2, 984, 983, 3, 2, 2, 2, 985, 988, 3, 2, 2, 2, 986, 984, 3, 2, 2,
	2, 986, 987, 3, 2, 2, 2, 987, 989, 3, 2, 2, 2, 988, 986, 3, 2, 2, 2, 989,
	1012, 5, 44, 23, 2, 990, 992, 5, 526, 264, 2, 991, 990, 3, 2, 2, 2, 992,
	995, 3, 2, 2, 2, 993, 991, 3, 2, 2, 2, 993, 994, 3, 2, 2, 2, 994, 996,
	3, 2, 2, 2, 995, 993, 3, 2, 2, 2, 996, 1012, 5, 54, 28, 2, 997, 999, 5,
	526, 264, 2, 998, 997, 3, 2, 2, 2, 999, 1002, 3, 2, 2, 2, 1000, 998, 3,
	2, 2, 2, 1000, 1001, 3, 2, 2, 2, 1001, 1003, 3, 2, 2, 2, 1002, 1000, 3,
	2, 2, 2, 1003, 1012, 5, 340, 171, 2, 1004, 1006, 5, 526, 264, 2, 1005,
	1004, 3, 2, 2, 2, 1006, 1009, 3, 2, 2, 2, 1007, 1005, 3, 2, 2, 2, 1007,
	1008, 3, 2, 2, 2, 1008, 1010, 3, 2, 2, 2, 1009, 1007, 3, 2, 2, 2, 1010,
	1012, 5, 58, 30, 2, 1011, 972, 3, 2, 2, 2, 1011, 979, 3, 2, 2, 2, 1011,
	986, 3, 2, 2, 2, 1011, 993, 3, 2, 2, 2, 1011, 1000, 3, 2, 2, 2, 1011, 1007,
	3, 2, 2, 2, 1012, 47, 3, 2, 2, 2, 1013, 1024, 5, 80, 41, 2, 1014, 1024,
	5, 78, 40, 2, 1015, 1024, 5, 70, 36, 2, 1016, 1024, 5, 74, 38, 2, 1017,
	1024, 5, 72, 37, 2, 1018, 1024, 5, 76, 39, 2, 1019, 1024, 5, 66, 34, 2,
	1020, 1024, 5, 68, 35, 2, 1021, 1024, 5, 152, 77, 2, 1022, 1024, 5, 142,
	72, 2, 1023, 1013, 3, 2, 2, 2, 1023, 1014, 3, 2, 2, 2, 1023, 1015, 3, 2,
	2, 2, 1023, 1016, 3, 2, 2, 2, 1023, 1017, 3, 2, 2, 2, 1023, 1018, 3, 2,
	2, 2, 1023, 1019, 3, 2, 2, 2, 1023, 1020, 3, 2, 2, 2, 1023, 1021, 3, 2,
	2, 2, 1023, 1022, 3, 2, 2, 2, 1024, 49, 3, 2, 2, 2, 1025, 1026, 7, 25,
	2, 2, 1026, 1027, 5, 114, 58, 2, 1027, 1028, 7, 4, 2, 2, 1028, 51, 3, 2,
	2, 2, 1029, 1031, 7, 26, 2, 2, 1030, 1032, 7, 27, 2, 2, 1031, 1030, 3,
	2, 2, 2, 1031, 1032, 3, 2, 2, 2, 1032, 1034, 3, 2, 2, 2, 1033, 1035, 5,
	140, 71, 2, 1034, 1033, 3, 2, 2, 2, 1034, 1035, 3, 2, 2, 2, 1035, 1036,
	3, 2, 2, 2, 1036, 1037, 5, 114, 58, 2, 1037, 1038, 7, 4, 2, 2, 1038, 1060,
	3, 2, 2, 2, 1039, 1040, 7, 26, 2, 2, 1040, 1041, 7, 28, 2, 2, 1041, 1042,
	5, 114, 58, 2, 1042, 1043, 7, 4, 2, 2, 1043, 1060, 3, 2, 2, 2, 1044, 1045,
	7, 26, 2, 2, 1045, 1046, 7, 29, 2, 2, 1046, 1047, 5, 114, 58, 2, 1047,
	1048, 7, 4, 2, 2, 1048, 1060, 3, 2, 2, 2, 1049, 1050, 7, 26, 2, 2, 1050,
	1051, 7, 30, 2, 2, 1051, 1052, 5, 114, 58, 2, 1052, 1053, 7, 4, 2, 2, 1053,
	1060, 3, 2, 2, 2, 1054, 1055, 7, 26, 2, 2, 1055, 1056, 7, 31, 2, 2, 1056,
	1057, 5, 114, 58, 2, 1057, 1058, 7, 4, 2, 2, 1058, 1060, 3, 2, 2, 2, 1059,
	1029, 3, 2, 2, 2, 1059, 1039, 3, 2, 2, 2, 1059, 1044, 3, 2, 2, 2, 1059,
	1049, 3, 2, 2, 2, 1059, 1054, 3, 2, 2, 2, 1060, 53, 3, 2, 2, 2, 1061, 1062,
	5, 56, 29, 2, 1062, 1063, 7, 4, 2, 2, 1063, 55, 3, 2, 2, 2, 1064, 1066,
	7, 32, 2, 2, 1065, 1067, 7, 27, 2, 2, 1066, 1065, 3, 2, 2, 2, 1066, 1067,
	3, 2, 2, 2, 1067, 1069, 3, 2, 2, 2, 1068, 1070, 5, 140, 71, 2, 1069, 1068,
	3, 2, 2, 2, 1069, 1070, 3, 2, 2, 2, 1070, 1071, 3, 2, 2, 2, 1071, 1085,
	5, 114, 58, 2, 1072, 1073, 7, 32, 2, 2, 1073, 1074, 7, 28, 2, 2, 1074,
	1085, 5, 114, 58, 2, 1075, 1076, 7, 32, 2, 2, 1076, 1077, 7, 29, 2, 2,
	1077, 1085, 5, 114, 58, 2, 1078, 1079, 7, 32, 2, 2, 1079, 1080, 7, 30,
	2, 2, 1080, 1085, 5, 114, 58, 2, 1081, 1082, 7, 32, 2, 2, 1082, 1083, 7,
	31, 2, 2, 1083, 1085, 5, 114, 58, 2, 1084, 1064, 3, 2, 2, 2, 1084, 1072,
	3, 2, 2, 2, 1084, 1075, 3, 2, 2, 2, 1084, 1078, 3, 2, 2, 2, 1084, 1081,
	3, 2, 2, 2, 1085, 57, 3, 2, 2, 2, 1086, 1088, 7, 33, 2, 2, 1087, 1089,
	5, 140, 71, 2, 1088, 1087, 3, 2, 2, 2, 1088, 1089, 3, 2, 2, 2, 1089, 1090,
	3, 2, 2, 2, 1090, 1091, 5, 116, 59, 2, 1091, 1092, 7, 4, 2, 2, 1092, 59,
	3, 2, 2, 2, 1093, 1095, 7, 34, 2, 2, 1094, 1096, 5, 82, 42, 2, 1095, 1094,
	3, 2, 2, 2, 1095, 1096, 3, 2, 2, 2, 1096, 1098, 3, 2, 2, 2, 1097, 1099,
	7, 27, 2, 2, 1098, 1097, 3, 2, 2, 2, 1098, 1099, 3, 2, 2, 2, 1099, 1101,
	3, 2, 2, 2, 1100, 1102, 5, 140, 71, 2, 1101, 1100, 3, 2, 2, 2, 1101, 1102,
	3, 2, 2, 2, 1102, 1103, 3, 2, 2, 2, 1103, 1104, 5, 110, 56, 2, 1104, 61,
	3, 2, 2, 2, 1105, 1107, 7, 35, 2, 2, 1106, 1108, 5, 82, 42, 2, 1107, 1106,
	3, 2, 2, 2, 1107, 1108, 3, 2, 2, 2, 1108, 1110, 3, 2, 2, 2, 1109, 1111,
	7, 27, 2, 2, 1110, 1109, 3, 2, 2, 2, 1110, 1111, 3, 2, 2, 2, 1111, 1113,
	3, 2, 2, 2, 1112, 1114, 5, 140, 71, 2, 1113, 1112, 3, 2, 2, 2, 1113, 1114,
	3, 2, 2, 2, 1114, 1115, 3, 2, 2, 2, 1115, 1116, 5, 110, 56, 2, 1116, 63,
	3, 2, 2, 2, 1117, 1119, 7, 36, 2, 2, 1118, 1120, 5, 82, 42, 2, 1119, 1118,
	3, 2, 2, 2, 1119, 1120, 3, 2, 2, 2, 1120, 1122, 3, 2, 2, 2, 1121, 1123,
	7, 27, 2, 2, 1122, 1121, 3, 2, 2, 2, 1122, 1123, 3, 2, 2, 2, 1123, 1125,
	3, 2, 2, 2, 1124, 1126, 5, 140, 71, 2, 1125, 1124, 3, 2, 2, 2, 1125, 1126,
	3, 2, 2, 2, 1126, 1127, 3, 2, 2, 2, 1127, 1158, 5, 110, 56, 2, 1128, 1130,
	7, 36, 2, 2, 1129, 1131, 7, 37, 2, 2, 1130, 1129, 3, 2, 2, 2, 1130, 1131,
	3, 2, 2, 2, 1131, 1133, 3, 2, 2, 2, 1132, 1134, 7, 27, 2, 2, 1133, 1132,
	3, 2, 2, 2, 1133, 1134, 3, 2, 2, 2, 1134, 1136, 3, 2, 2, 2, 1135, 1137,
	5, 140, 71, 2, 1136, 1135, 3, 2, 2, 2, 1136, 1137, 3, 2, 2, 2, 1137, 1138,
	3, 2, 2, 2, 1138, 1158, 5, 110, 56, 2, 1139, 1140, 7, 36, 2, 2, 1140, 1142,
	7, 37, 2, 2, 1141, 1143, 7, 27, 2, 2, 1142, 1141, 3, 2, 2, 2, 1142, 1143,
	3, 2, 2, 2, 1143, 1145, 3, 2, 2, 2, 1144, 1146, 5, 140, 71, 2, 1145, 1144,
	3, 2, 2, 2, 1145, 1146, 3, 2, 2, 2, 1146, 1147, 3, 2, 2, 2, 1147, 1158,
	5, 122, 62, 2, 1148, 1150, 7, 36, 2, 2, 1149, 1151, 5, 84, 43, 2, 1150,
	1149, 3, 2, 2, 2, 1150, 1151, 3, 2, 2, 2, 1151, 1152, 3, 2, 2, 2, 1152,
	1158, 5, 110, 56, 2, 1153, 1154, 7, 36, 2, 2, 1154, 1155, 5, 84, 43, 2,
	1155, 1156, 5, 122, 62, 2, 1156, 1158, 3, 2, 2, 2, 1157, 1117, 3, 2, 2,
	2, 1157, 1128, 3, 2, 2, 2, 1157, 1139, 3, 2, 2, 2, 1157, 1148, 3, 2, 2,
	2, 1157, 1153, 3, 2, 2, 2, 1158, 65, 3, 2, 2, 2, 1159, 1160, 7, 38, 2,
	2, 1160, 1161, 5, 104, 53, 2, 1161, 1162, 7, 4, 2, 2, 1162, 67, 3, 2, 2,
	2, 1163, 1164, 7, 39, 2, 2, 1164, 1165, 5, 108, 55, 2, 1165, 1166, 7, 4,
	2, 2, 1166, 69, 3, 2, 2, 2, 1167, 1168, 7, 28, 2, 2, 1168, 1169, 5, 120,
	61, 2, 1169, 1170, 7, 4, 2, 2, 1170, 71, 3, 2, 2, 2, 1171, 1172, 7, 31,
	2, 2, 1172, 1173, 5, 120, 61, 2, 1173, 1174, 7, 4, 2, 2, 1174, 73, 3, 2,
	2, 2, 1175, 1176, 7, 29, 2, 2, 1176, 1177, 5, 118, 60, 2, 1177, 1178, 7,
	4, 2, 2, 1178, 75, 3, 2, 2, 2, 1179, 1180, 7, 30, 2, 2, 1180, 1181, 5,
	118, 60, 2, 1181, 1182, 7, 4, 2, 2, 1182, 77, 3, 2, 2, 2, 1183, 1185, 7,
	37, 2, 2, 1184, 1186, 7, 27, 2, 2, 1185, 1184, 3, 2, 2, 2, 1185, 1186,
	3, 2, 2, 2, 1186, 1188, 3, 2, 2, 2, 1187, 1189, 5, 140, 71, 2, 1188, 1187,
	3, 2, 2, 2, 1188, 1189, 3, 2, 2, 2, 1189, 1190, 3, 2, 2, 2, 1190, 1191,
	5, 120, 61, 2, 1191, 1192, 7, 4, 2, 2, 1192, 79, 3, 2, 2, 2, 1193, 1195,
	5, 82, 42, 2, 1194, 1196, 7, 27, 2, 2, 1195, 1194, 3, 2, 2, 2, 1195, 1196,
	3, 2, 2, 2, 1196, 1198, 3, 2, 2, 2, 1197, 1199, 5, 98, 50, 2, 1198, 1197,
	3, 2, 2, 2, 1198, 1199, 3, 2, 2, 2, 1199, 1200, 3, 2, 2, 2, 1200, 1201,
	5, 106, 54, 2, 1201, 1202, 7, 4, 2, 2, 1202, 1308, 3, 2, 2, 2, 1203, 1205,
	5, 82, 42, 2, 1204, 1206, 5, 90, 46, 2, 1205, 1204, 3, 2, 2, 2, 1205, 1206,
	3, 2, 2, 2, 1206, 1208, 3, 2, 2, 2, 1207, 1209, 7, 27, 2, 2, 1208, 1207,
	3, 2, 2, 2, 1208, 1209, 3, 2, 2, 2, 1209, 1211, 3, 2, 2, 2, 1210, 1212,
	5, 98, 50, 2, 1211, 1210, 3, 2, 2, 2, 1211, 1212, 3, 2, 2, 2, 1212, 1213,
	3, 2, 2, 2, 1213, 1214, 5, 112, 57, 2, 1214, 1215, 7, 4, 2, 2, 1215, 1308,
	3, 2, 2, 2, 1216, 1218, 7, 40, 2, 2, 1217, 1219, 5, 90, 46, 2, 1218, 1217,
	3, 2, 2, 2, 1218, 1219, 3, 2, 2, 2, 1219, 1221, 3, 2, 2, 2, 1220, 1222,
	7, 27, 2, 2, 1221, 1220, 3, 2, 2, 2, 1221, 1222, 3, 2, 2, 2, 1222, 1224,
	3, 2, 2, 2, 1223, 1225, 5, 98, 50, 2, 1224, 1223, 3, 2, 2, 2, 1224, 1225,
	3, 2, 2, 2, 1225, 1226, 3, 2, 2, 2, 1226, 1227, 5, 112, 57, 2, 1227, 1228,
	7, 4, 2, 2, 1228, 1308, 3, 2, 2, 2, 1229, 1231, 7, 40, 2, 2, 1230, 1232,
	5, 96, 49, 2, 1231, 1230, 3, 2, 2, 2, 1231, 1232, 3, 2, 2, 2, 1232, 1234,
	3, 2, 2, 2, 1233, 1235, 7, 27, 2, 2, 1234, 1233, 3, 2, 2, 2, 1234, 1235,
	3, 2, 2, 2, 1235, 1237, 3, 2, 2, 2, 1236, 1238, 5, 98, 50, 2, 1237, 1236,
	3, 2, 2, 2, 1237, 1238, 3, 2, 2, 2, 1238, 1239, 3, 2, 2, 2, 1239, 1240,
	5, 106, 54, 2, 1240, 1241, 7, 4, 2, 2, 1241, 1308, 3, 2, 2, 2, 1242, 1244,
	7, 40, 2, 2, 1243, 1245, 5, 96, 49, 2, 1244, 1243, 3, 2, 2, 2, 1244, 1245,
	3, 2, 2, 2, 1245, 1247, 3, 2, 2, 2, 1246, 1248, 9, 3, 2, 2, 1247, 1246,
	3, 2, 2, 2, 1247, 1248, 3, 2, 2, 2, 1248, 1250, 3, 2, 2, 2, 1249, 1251,
	7, 27, 2, 2, 1250, 1249, 3, 2, 2, 2, 1250, 1251, 3, 2, 2, 2, 1251, 1252,
	3, 2, 2, 2, 1252, 1254, 5, 140, 71, 2, 1253, 1255, 5, 98, 50, 2, 1254,
	1253, 3, 2, 2, 2, 1254, 1255, 3, 2, 2, 2, 1255, 1256, 3, 2, 2, 2, 1256,
	1257, 5, 106, 54, 2, 1257, 1258, 7, 4, 2, 2, 1258, 1308, 3, 2, 2, 2, 1259,
	1261, 7, 40, 2, 2, 1260, 1262, 5, 90, 46, 2, 1261, 1260, 3, 2, 2, 2, 1261,
	1262, 3, 2, 2, 2, 1262, 1264, 3, 2, 2, 2, 1263, 1265, 9, 3, 2, 2, 1264,
	1263, 3, 2, 2, 2, 1264, 1265, 3, 2, 2, 2, 1265, 1267, 3, 2, 2, 2, 1266,
	1268, 7, 27, 2, 2, 1267, 1266, 3, 2, 2, 2, 1267, 1268, 3, 2, 2, 2, 1268,
	1269, 3, 2, 2, 2, 1269, 1271, 5, 140, 71, 2, 1270, 1272, 5, 98, 50, 2,
	1271, 1270, 3, 2, 2, 2, 1271, 1272, 3, 2, 2, 2, 1272, 1273, 3, 2, 2, 2,
	1273, 1274, 5, 112, 57, 2, 1274, 1275, 7, 4, 2, 2, 1275, 1308, 3, 2, 2,
	2, 1276, 1278, 5, 82, 42, 2, 1277, 1279, 5, 90, 46, 2, 1278, 1277, 3, 2,
	2, 2, 1278, 1279, 3, 2, 2, 2, 1279, 1281, 3, 2, 2, 2, 1280, 1282, 9, 3,
	2, 2, 1281, 1280, 3, 2, 2, 2, 1281, 1282, 3, 2, 2, 2, 1282, 1284, 3, 2,
	2, 2, 1283, 1285, 7, 27, 2, 2, 1284, 1283, 3, 2, 2, 2, 1284, 1285, 3, 2,
	2, 2, 1285, 1286, 3, 2, 2, 2, 1286, 1288, 5, 140, 71, 2, 1287, 1289, 5,
	98, 50, 2, 1288, 1287, 3, 2, 2, 2, 1288, 1289, 3, 2, 2, 2, 1289, 1290,
	3, 2, 2, 2, 1290, 1291, 5, 112, 57, 2, 1291, 1292, 7, 4, 2, 2, 1292, 1308,
	3, 2, 2, 2, 1293, 1295, 5, 82, 42, 2, 1294, 1296, 9, 3, 2, 2, 1295, 1294,
	3, 2, 2, 2, 1295, 1296, 3, 2, 2, 2, 1296, 1298, 3, 2, 2, 2, 1297, 1299,
	7, 27, 2, 2, 1298, 1297, 3, 2, 2, 2, 1298, 1299, 3, 2, 2, 2, 1299, 1300,
	3, 2, 2, 2, 1300, 1302, 5, 140, 71, 2, 1301, 1303, 5, 98, 50, 2, 1302,
	1301, 3, 2, 2, 2, 1302, 1303, 3, 2, 2, 2, 1303, 1304, 3, 2, 2, 2, 1304,
	1305, 5, 106, 54, 2, 1305, 1306, 7, 4, 2, 2, 1306, 1308, 3, 2, 2, 2, 1307,
	1193, 3, 2, 2, 2, 1307, 1203, 3, 2, 2, 2, 1307, 1216, 3, 2, 2, 2, 1307,
	1229, 3, 2, 2, 2, 1307, 1242, 3, 2, 2, 2, 1307, 1259, 3, 2, 2, 2, 1307,
	1276, 3, 2, 2, 2, 1307, 1293, 3, 2, 2, 2, 1308, 81, 3, 2, 2, 2, 1309, 1310,
	9, 4, 2, 2, 1310, 83, 3, 2, 2, 2, 1311, 1312, 9, 5, 2, 2, 1312, 85, 3,
	2, 2, 2, 1313, 1316, 5, 596, 299, 2, 1314, 1315, 7, 53, 2, 2, 1315, 1317,
	5, 474, 238, 2, 1316, 1314, 3, 2, 2, 2, 1316, 1317, 3, 2, 2, 2, 1317, 1327,
	3, 2, 2, 2, 1318, 1319, 5, 596, 299, 2, 1319, 1323, 5, 138, 70, 2, 1320,
	1322, 5, 138, 70, 2, 1321, 1320, 3, 2, 2, 2, 1322, 1325, 3, 2, 2, 2, 1323,
	1321, 3, 2, 2, 2, 1323, 1324, 3, 2, 2, 2, 1324, 1327, 3, 2, 2, 2, 1325,
	1323, 3, 2, 2, 2, 1326, 1313, 3, 2, 2, 2, 1326, 1318, 3, 2, 2, 2, 1327,
	87, 3, 2, 2, 2, 1328, 1331, 5, 620, 311, 2, 1329, 1330, 7, 53, 2, 2, 1330,
	1332, 5, 474, 238, 2, 1331, 1329, 3, 2, 2, 2, 1331, 1332, 3, 2, 2, 2, 1332,
	1342, 3, 2, 2, 2, 1333, 1334, 5, 620, 311, 2, 1334, 1338, 5, 138, 70, 2,
	1335, 1337, 5, 138, 70, 2, 1336, 1335, 3, 2, 2, 2, 1337, 1340, 3, 2, 2,
	2, 1338, 1336, 3, 2, 2, 2, 1338, 1339, 3, 2, 2, 2, 1339, 1342, 3, 2, 2,
	2, 1340, 1338, 3, 2, 2, 2, 1341, 1328, 3, 2, 2, 2, 1341, 1333, 3, 2, 2,
	2, 1342, 89, 3, 2, 2, 2, 1343, 1344, 7, 18, 2, 2, 1344, 1345, 5, 92, 47,
	2, 1345, 1346, 7, 19, 2, 2, 1346, 1347, 5, 94, 48, 2, 1347, 1348, 7, 20,
	2, 2, 1348, 1380, 3, 2, 2, 2, 1349, 1350, 7, 18, 2, 2, 1350, 1351, 5, 94,
	48, 2, 1351, 1352, 7, 19, 2, 2, 1352, 1353, 5, 92, 47, 2, 1353, 1354, 7,
	20, 2, 2, 1354, 1380, 3, 2, 2, 2, 1355, 1356, 7, 18, 2, 2, 1356, 1357,
	5, 92, 47, 2, 1357, 1358, 7, 19, 2, 2, 1358, 1359, 7, 54, 2, 2, 1359, 1360,
	7, 20, 2, 2, 1360, 1380, 3, 2, 2, 2, 1361, 1362, 7, 18, 2, 2, 1362, 1363,
	5, 94, 48, 2, 1363, 1364, 7, 19, 2, 2, 1364, 1365, 7, 55, 2, 2, 1365, 1366,
	7, 20, 2, 2, 1366, 1380, 3, 2, 2, 2, 1367, 1368, 7, 18, 2, 2, 1368, 1369,
	7, 55, 2, 2, 1369, 1370, 7, 19, 2, 2, 1370, 1371, 5, 94, 48, 2, 1371, 1372,
	7, 20, 2, 2, 1372, 1380, 3, 2, 2, 2, 1373, 1374, 7, 18, 2, 2, 1374, 1375,
	7, 54, 2, 2, 1375, 1376, 7, 19, 2, 2, 1376, 1377, 5, 92, 47, 2, 1377, 1378,
	7, 20, 2, 2, 1378, 1380, 3, 2, 2, 2, 1379, 1343, 3, 2, 2, 2, 1379, 1349,
	3, 2, 2, 2, 1379, 1355, 3, 2, 2, 2, 1379, 1361, 3, 2, 2, 2, 1379, 1367,
	3, 2, 2, 2, 1379, 1373, 3, 2, 2, 2, 1380, 91, 3, 2, 2, 2, 1381, 1382, 9,
	6, 2, 2, 1382, 93, 3, 2, 2, 2, 1383, 1384, 9, 7, 2, 2, 1384, 95, 3, 2,
	2, 2, 1385, 1386, 7, 18, 2, 2, 1386, 1387, 7, 62, 2, 2, 1387, 1395, 7,
	20, 2, 2, 1388, 1389, 7, 18, 2, 2, 1389, 1390, 7, 63, 2, 2, 1390, 1395,
	7, 20, 2, 2, 1391, 1392, 7, 18, 2, 2, 1392, 1393, 7, 64, 2, 2, 1393, 1395,
	7, 20, 2, 2, 1394, 1385, 3, 2, 2, 2, 1394, 1388, 3, 2, 2, 2, 1394, 1391,
	3, 2, 2, 2, 1395, 97, 3, 2, 2, 2, 1396, 1397, 7, 17, 2, 2, 1397, 1412,
	5, 102, 52, 2, 1398, 1399, 7, 17, 2, 2, 1399, 1400, 7, 18, 2, 2, 1400,
	1407, 5, 102, 52, 2, 1401, 1402, 7, 19, 2, 2, 1402, 1405, 5, 102, 52, 2,
	1403, 1404, 7, 19, 2, 2, 1404, 1406, 5, 102, 52, 2, 1405, 1403, 3, 2, 2,
	2, 1405, 1406, 3, 2, 2, 2, 1406, 1408, 3, 2, 2, 2, 1407, 1401, 3, 2, 2,
	2, 1407, 1408, 3, 2, 2, 2, 1408, 1409, 3, 2, 2, 2, 1409, 1410, 7, 20, 2,
	2, 1410, 1412, 3, 2, 2, 2, 1411, 1396, 3, 2, 2, 2, 1411, 1398, 3, 2, 2,
	2, 1412, 99, 3, 2, 2, 2, 1413, 1414, 7, 17, 2, 2, 1414, 1425, 5, 102, 52,
	2, 1415, 1416, 7, 17, 2, 2, 1416, 1417, 7, 18, 2, 2, 1417, 1420, 5, 102,
	52, 2, 1418, 1419, 7, 19, 2, 2, 1419, 1421, 5, 102, 52, 2, 1420, 1418,
	3, 2, 2, 2, 1420, 1421, 3, 2, 2, 2, 1421, 1422, 3, 2, 2, 2, 1422, 1423,
	7, 20, 2, 2, 1423, 1425, 3, 2, 2, 2, 1424, 1413, 3, 2, 2, 2, 1424, 1415,
	3, 2, 2, 2, 1425, 101, 3, 2, 2, 2, 1426, 1431, 7, 171, 2, 2, 1427, 1431,
	5, 592, 297, 2, 1428, 1431, 5, 602, 302, 2, 1429, 1431, 5, 488, 245, 2,
	1430, 1426, 3, 2, 2, 2, 1430, 1427, 3, 2, 2, 2, 1430, 1428, 3, 2, 2, 2,
	1430, 1429, 3, 2, 2, 2, 1431, 103, 3, 2, 2, 2, 1432, 1440, 5, 546, 274,
	2, 1433, 1437, 5, 138, 70, 2, 1434, 1436, 5, 138, 70, 2, 1435, 1434, 3,
	2, 2, 2, 1436, 1439, 3, 2, 2, 2, 1437, 1435, 3, 2, 2, 2, 1437, 1438, 3,
	2, 2, 2, 1438, 1441, 3, 2, 2, 2, 1439, 1437, 3, 2, 2, 2, 1440, 1433, 3,
	2, 2, 2, 1440, 1441, 3, 2, 2, 2, 1441, 1455, 3, 2, 2, 2, 1442, 1443, 7,
	19, 2, 2, 1443, 1451, 5, 546, 274, 2, 1444, 1448, 5, 138, 70, 2, 1445,
	1447, 5, 138, 70, 2, 1446, 1445, 3, 2, 2, 2, 1447, 1450, 3, 2, 2, 2, 1448,
	1446, 3, 2, 2, 2, 1448, 1449, 3, 2, 2, 2, 1449, 1452, 3, 2, 2, 2, 1450,
	1448, 3, 2, 2, 2, 1451, 1444, 3, 2, 2, 2, 1451, 1452, 3, 2, 2, 2, 1452,
	1454, 3, 2, 2, 2, 1453, 1442, 3, 2, 2, 2, 1454, 1457, 3, 2, 2, 2, 1455,
	1453, 3, 2, 2, 2, 1455, 1456, 3, 2, 2, 2, 1456, 105, 3, 2, 2, 2, 1457,
	1455, 3, 2, 2, 2, 1458, 1466, 5, 588, 295, 2, 1459, 1463, 5, 138, 70, 2,
	1460, 1462, 5, 138, 70, 2, 1461, 1460, 3, 2, 2, 2, 1462, 1465, 3, 2, 2,
	2, 1463, 1461, 3, 2, 2, 2, 1463, 1464, 3, 2, 2, 2, 1464, 1467, 3, 2, 2,
	2, 1465, 1463, 3, 2, 2, 2, 1466, 1459, 3, 2, 2, 2, 1466, 1467, 3, 2, 2,
	2, 1467, 1481, 3, 2, 2, 2, 1468, 1469, 7, 19, 2, 2, 1469, 1477, 5, 588,
	295, 2, 1470, 1474, 5, 138, 70, 2, 1471, 1473, 5, 138, 70, 2, 1472, 1471,
	3, 2, 2, 2, 1473, 1476, 3, 2, 2, 2, 1474, 1472, 3, 2, 2, 2, 1474, 1475,
	3, 2, 2, 2, 1475, 1478, 3, 2, 2, 2, 1476, 1474, 3, 2, 2, 2, 1477, 1470,
	3, 2, 2, 2, 1477, 1478, 3, 2, 2, 2, 1478, 1480, 3, 2, 2, 2, 1479, 1468,
	3, 2, 2, 2, 1480, 1483, 3, 2, 2, 2, 1481, 1479, 3, 2, 2, 2, 1481, 1482,
	3, 2, 2, 2, 1482, 107, 3, 2, 2, 2, 1483, 1481, 3, 2, 2, 2, 1484, 1489,
	5, 556, 279, 2, 1485, 1486, 7, 19, 2, 2, 1486, 1488, 5, 556, 279, 2, 1487,
	1485, 3, 2, 2, 2, 1488, 1491, 3, 2, 2, 2, 1489, 1487, 3, 2, 2, 2, 1489,
	1490, 3, 2, 2, 2, 1490, 109, 3, 2, 2, 2, 1491, 1489, 3, 2, 2, 2, 1492,
	1497, 5, 594, 298, 2, 1493, 1494, 7, 19, 2, 2, 1494, 1496, 5, 594, 298,
	2, 1495, 1493, 3, 2, 2, 2, 1496, 1499, 3, 2, 2, 2, 1497, 1495, 3, 2, 2,
	2, 1497, 1498, 3, 2, 2, 2, 1498, 111, 3, 2, 2, 2, 1499, 1497, 3, 2, 2,
	2, 1500, 1505, 5, 124, 63, 2, 1501, 1502, 7, 19, 2, 2, 1502, 1504, 5, 124,
	63, 2, 1503, 1501, 3, 2, 2, 2, 1504, 1507, 3, 2, 2, 2, 1505, 1503, 3, 2,
	2, 2, 1505, 1506, 3, 2, 2, 2, 1506, 113, 3, 2, 2, 2, 1507, 1505, 3, 2,
	2, 2, 1508, 1513, 5, 126, 64, 2, 1509, 1510, 7, 19, 2, 2, 1510, 1512, 5,
	126, 64, 2, 1511, 1509, 3, 2, 2, 2, 1512, 1515, 3, 2, 2, 2, 1513, 1511,
	3, 2, 2, 2, 1513, 1514, 3, 2, 2, 2, 1514, 115, 3, 2, 2, 2, 1515, 1513,
	3, 2, 2, 2, 1516, 1521, 5, 128, 65, 2, 1517, 1518, 7, 19, 2, 2, 1518, 1520,
	5, 128, 65, 2, 1519, 1517, 3, 2, 2, 2, 1520, 1523, 3, 2, 2, 2, 1521, 1519,
	3, 2, 2, 2, 1521, 1522, 3, 2, 2, 2, 1522, 117, 3, 2, 2, 2, 1523, 1521,
	3, 2, 2, 2, 1524, 1529, 5, 86, 44, 2, 1525, 1526, 7, 19, 2, 2, 1526, 1528,
	5, 86, 44, 2, 1527, 1525, 3, 2, 2, 2, 1528, 1531, 3, 2, 2, 2, 1529, 1527,
	3, 2, 2, 2, 1529, 1530, 3, 2, 2, 2, 1530, 119, 3, 2, 2, 2, 1531, 1529,
	3, 2, 2, 2, 1532, 1537, 5, 88, 45, 2, 1533, 1534, 7, 19, 2, 2, 1534, 1536,
	5, 88, 45, 2, 1535, 1533, 3, 2, 2, 2, 1536, 1539, 3, 2, 2, 2, 1537, 1535,
	3, 2, 2, 2, 1537, 1538, 3, 2, 2, 2, 1538, 121, 3, 2, 2, 2, 1539, 1537,
	3, 2, 2, 2, 1540, 1543, 5, 594, 298, 2, 1541, 1542, 7, 53, 2, 2, 1542,
	1544, 5, 474, 238, 2, 1543, 1541, 3, 2, 2, 2, 1543, 1544, 3, 2, 2, 2, 1544,
	1553, 3, 2, 2, 2, 1545, 1546, 7, 19, 2, 2, 1546, 1549, 5, 594, 298, 2,
	1547, 1548, 7, 53, 2, 2, 1548, 1550, 5, 474, 238, 2, 1549, 1547, 3, 2,
	2, 2, 1549, 1550, 3, 2, 2, 2, 1550, 1552, 3, 2, 2, 2, 1551, 1545, 3, 2,
	2, 2, 1552, 1555, 3, 2, 2, 2, 1553, 1551, 3, 2, 2, 2, 1553, 1554, 3, 2,
	2, 2, 1554, 123, 3, 2, 2, 2, 1555, 1553, 3, 2, 2, 2, 1556, 1557, 5, 588,
	295, 2, 1557, 1558, 7, 53, 2, 2, 1558, 1559, 5, 482, 242, 2, 1559, 125,
	3, 2, 2, 2, 1560, 1561, 5, 592, 297, 2, 1561, 1562, 7, 53, 2, 2, 1562,
	1563, 5, 474, 238, 2, 1563, 127, 3, 2, 2, 2, 1564, 1565, 5, 602, 302, 2,
	1565, 1566, 7, 53, 2, 2, 1566, 1567, 5, 476, 239, 2, 1567, 1570, 3, 2,
	2, 2, 1568, 1570, 5, 130, 66, 2, 1569, 1564, 3, 2, 2, 2, 1569, 1568, 3,
	2, 2, 2, 1570, 129, 3, 2, 2, 2, 1571, 1572, 7, 65, 2, 2, 1572, 1573, 7,
	53, 2, 2, 1573, 1574, 7, 18, 2, 2, 1574, 1577, 5, 134, 68, 2, 1575, 1576,
	7, 19, 2, 2, 1576, 1578, 5, 132, 67, 2, 1577, 1575, 3, 2, 2, 2, 1577, 1578,
	3, 2, 2, 2, 1578, 1579, 3, 2, 2, 2, 1579, 1580, 7, 20, 2, 2, 1580, 1581,
	7, 4, 2, 2, 1581, 1597, 3, 2, 2, 2, 1582, 1583, 7, 65, 2, 2, 1583, 1584,
	5, 360, 181, 2, 1584, 1585, 7, 66, 2, 2, 1585, 1586, 5, 362, 182, 2, 1586,
	1587, 7, 53, 2, 2, 1587, 1588, 7, 18, 2, 2, 1588, 1591, 5, 134, 68, 2,
	1589, 1590, 7, 19, 2, 2, 1590, 1592, 5, 132, 67, 2, 1591, 1589, 3, 2, 2,
	2, 1591, 1592, 3, 2, 2, 2, 1592, 1593, 3, 2, 2, 2, 1593, 1594, 7, 20, 2,
	2, 1594, 1595, 7, 4, 2, 2, 1595, 1597, 3, 2, 2, 2, 1596, 1571, 3, 2, 2,
	2, 1596, 1582, 3, 2, 2, 2, 1597, 131, 3, 2, 2, 2, 1598, 1599, 5, 136, 69,
	2, 1599, 133, 3, 2, 2, 2, 1600, 1601, 5, 136, 69, 2, 1601, 135, 3, 2, 2,
	2, 1602, 1603, 5, 476, 239, 2, 1603, 137, 3, 2, 2, 2, 1604, 1605, 7, 23,
	2, 2, 1605, 1606, 5, 480, 241, 2, 1606, 1607, 7, 67, 2, 2, 1607, 1608,
	5, 480, 241, 2, 1608, 1609, 7, 24, 2, 2, 1609, 139, 3, 2, 2, 2, 1610, 1611,
	7, 23, 2, 2, 1611, 1612, 5, 496, 249, 2, 1612, 1613, 7, 67, 2, 2, 1613,
	1614, 5, 486, 244, 2, 1614, 1615, 7, 24, 2, 2, 1615, 141, 3, 2, 2, 2, 1616,
	1618, 7, 68, 2, 2, 1617, 1619, 7, 69, 2, 2, 1618, 1617, 3, 2, 2, 2, 1618,
	1619, 3, 2, 2, 2, 1619, 1621, 3, 2, 2, 2, 1620, 1622, 7, 27, 2, 2, 1621,
	1620, 3, 2, 2, 2, 1621, 1622, 3, 2, 2, 2, 1622, 1624, 3, 2, 2, 2, 1623,
	1625, 5, 150, 76, 2, 1624, 1623, 3, 2, 2, 2, 1624, 1625, 3, 2, 2, 2, 1625,
	1626, 3, 2, 2, 2, 1626, 1627, 5, 548, 275, 2, 1627, 1631, 7, 4, 2, 2, 1628,
	1630, 5, 144, 73, 2, 1629, 1628, 3, 2, 2, 2, 1630, 1633, 3, 2, 2, 2, 1631,
	1629, 3, 2, 2, 2, 1631, 1632, 3, 2, 2, 2, 1632, 1635, 3, 2, 2, 2, 1633,
	1631, 3, 2, 2, 2, 1634, 1636, 5, 294, 148, 2, 1635, 1634, 3, 2, 2, 2, 1635,
	1636, 3, 2, 2, 2, 1636, 1637, 3, 2, 2, 2, 1637, 1638, 7, 70, 2, 2, 1638,
	1666, 3, 2, 2, 2, 1639, 1641, 7, 68, 2, 2, 1640, 1642, 7, 69, 2, 2, 1641,
	1640, 3, 2, 2, 2, 1641, 1642, 3, 2, 2, 2, 1642, 1644, 3, 2, 2, 2, 1643,
	1645, 7, 27, 2, 2, 1644, 1643, 3, 2, 2, 2, 1644, 1645, 3, 2, 2, 2, 1645,
	1647, 3, 2, 2, 2, 1646, 1648, 5, 150, 76, 2, 1647, 1646, 3, 2, 2, 2, 1647,
	1648, 3, 2, 2, 2, 1648, 1649, 3, 2, 2, 2, 1649, 1650, 5, 548, 275, 2, 1650,
	1651, 7, 18, 2, 2, 1651, 1652, 5, 146, 74, 2, 1652, 1653, 7, 20, 2, 2,
	1653, 1657, 7, 4, 2, 2, 1654, 1656, 5, 166, 84, 2, 1655, 1654, 3, 2, 2,
	2, 1656, 1659, 3, 2, 2, 2, 1657, 1655, 3, 2, 2, 2, 1657, 1658, 3, 2, 2,
	2, 1658, 1661, 3, 2, 2, 2, 1659, 1657, 3, 2, 2, 2, 1660, 1662, 5, 294,
	148, 2, 1661, 1660, 3, 2, 2, 2, 1661, 1662, 3, 2, 2, 2, 1662, 1663, 3,
	2, 2, 2, 1663, 1664, 7, 70, 2, 2, 1664, 1666, 3, 2, 2, 2, 1665, 1616, 3,
	2, 2, 2, 1665, 1639, 3, 2, 2, 2, 1666, 143, 3, 2, 2, 2, 1667, 1672, 5,
	166, 84, 2, 1668, 1669, 5, 162, 82, 2, 1669, 1670, 7, 4, 2, 2, 1670, 1672,
	3, 2, 2, 2, 1671, 1667, 3, 2, 2, 2, 1671, 1668, 3, 2, 2, 2, 1672, 145,
	3, 2, 2, 2, 1673, 1678, 5, 148, 75, 2, 1674, 1675, 7, 19, 2, 2, 1675, 1677,
	5, 148, 75, 2, 1676, 1674, 3, 2, 2, 2, 1677, 1680, 3, 2, 2, 2, 1678, 1676,
	3, 2, 2, 2, 1678, 1679, 3, 2, 2, 2, 1679, 147, 3, 2, 2, 2, 1680, 1678,
	3, 2, 2, 2, 1681, 1683, 5, 526, 264, 2, 1682, 1681, 3, 2, 2, 2, 1683, 1686,
	3, 2, 2, 2, 1684, 1682, 3, 2, 2, 2, 1684, 1685, 3, 2, 2, 2, 1685, 1687,
	3, 2, 2, 2, 1686, 1684, 3, 2, 2, 2, 1687, 1688, 5, 162, 82, 2, 1688, 149,
	3, 2, 2, 2, 1689, 1695, 5, 140, 71, 2, 1690, 1695, 7, 28, 2, 2, 1691, 1695,
	7, 29, 2, 2, 1692, 1695, 7, 30, 2, 2, 1693, 1695, 7, 31, 2, 2, 1694, 1689,
	3, 2, 2, 2, 1694, 1690, 3, 2, 2, 2, 1694, 1691, 3, 2, 2, 2, 1694, 1692,
	3, 2, 2, 2, 1694, 1693, 3, 2, 2, 2, 1695, 151, 3, 2, 2, 2, 1696, 1698,
	7, 71, 2, 2, 1697, 1699, 7, 69, 2, 2, 1698, 1697, 3, 2, 2, 2, 1698, 1699,
	3, 2, 2, 2, 1699, 1700, 3, 2, 2, 2, 1700, 1701, 5, 608, 305, 2, 1701, 1705,
	7, 4, 2, 2, 1702, 1704, 5, 154, 78, 2, 1703, 1702, 3, 2, 2, 2, 1704, 1707,
	3, 2, 2, 2, 1705, 1703, 3, 2, 2, 2, 1705, 1706, 3, 2, 2, 2, 1706, 1708,
	3, 2, 2, 2, 1707, 1705, 3, 2, 2, 2, 1708, 1709, 5, 290, 146, 2, 1709, 1710,
	7, 72, 2, 2, 1710, 1732, 3, 2, 2, 2, 1711, 1713, 7, 71, 2, 2, 1712, 1714,
	7, 69, 2, 2, 1713, 1712, 3, 2, 2, 2, 1713, 1714, 3, 2, 2, 2, 1714, 1715,
	3, 2, 2, 2, 1715, 1716, 5, 608, 305, 2, 1716, 1718, 7, 18, 2, 2, 1717,
	1719, 5, 156, 79, 2, 1718, 1717, 3, 2, 2, 2, 1718, 1719, 3, 2, 2, 2, 1719,
	1720, 3, 2, 2, 2, 1720, 1721, 7, 20, 2, 2, 1721, 1725, 7, 4, 2, 2, 1722,
	1724, 5, 166, 84, 2, 1723, 1722, 3, 2, 2, 2, 1724, 1727, 3, 2, 2, 2, 1725,
	1723, 3, 2, 2, 2, 1725, 1726, 3, 2, 2, 2, 1726, 1728, 3, 2, 2, 2, 1727,
	1725, 3, 2, 2, 2, 1728, 1729, 5, 290, 146, 2, 1729, 1730, 7, 72, 2, 2,
	1730, 1732, 3, 2, 2, 2, 1731, 1696, 3, 2, 2, 2, 1731, 1711, 3, 2, 2, 2,
	1732, 153, 3, 2, 2, 2, 1733, 1744, 5, 166, 84, 2, 1734, 1736, 5, 526, 264,
	2, 1735, 1734, 3, 2, 2, 2, 1736, 1739, 3, 2, 2, 2, 1737, 1735, 3, 2, 2,
	2, 1737, 1738, 3, 2, 2, 2, 1738, 1740, 3, 2, 2, 2, 1739, 1737, 3, 2, 2,
	2, 1740, 1741, 5, 162, 82, 2, 1741, 1742, 7, 4, 2, 2, 1742, 1744, 3, 2,
	2, 2, 1743, 1733, 3, 2, 2, 2, 1743, 1737, 3, 2, 2, 2, 1744, 155, 3, 2,
	2, 2, 1745, 1750, 5, 158, 80, 2, 1746, 1747, 7, 19, 2, 2, 1747, 1749, 5,
	158, 80, 2, 1748, 1746, 3, 2, 2, 2, 1749, 1752, 3, 2, 2, 2, 1750, 1748,
	3, 2, 2, 2, 1750, 1751, 3, 2, 2, 2, 1751, 157, 3, 2, 2, 2, 1752, 1750,
	3, 2, 2, 2, 1753, 1755, 5, 526, 264, 2, 1754, 1753, 3, 2, 2, 2, 1755, 1758,
	3, 2, 2, 2, 1756, 1754, 3, 2, 2, 2, 1756, 1757, 3, 2, 2, 2, 1757, 1759,
	3, 2, 2, 2, 1758, 1756, 3, 2, 2, 2, 1759, 1760, 5, 162, 82, 2, 1760, 159,
	3, 2, 2, 2, 1761, 1763, 9, 8, 2, 2, 1762, 1764, 5, 82, 42, 2, 1763, 1762,
	3, 2, 2, 2, 1763, 1764, 3, 2, 2, 2, 1764, 1766, 3, 2, 2, 2, 1765, 1767,
	7, 37, 2, 2, 1766, 1765, 3, 2, 2, 2, 1766, 1767, 3, 2, 2, 2, 1767, 1769,
	3, 2, 2, 2, 1768, 1770, 7, 27, 2, 2, 1769, 1768, 3, 2, 2, 2, 1769, 1770,
	3, 2, 2, 2, 1770, 1772, 3, 2, 2, 2, 1771, 1773, 5, 140, 71, 2, 1772, 1771,
	3, 2, 2, 2, 1772, 1773, 3, 2, 2, 2, 1773, 1782, 3, 2, 2, 2, 1774, 1776,
	9, 8, 2, 2, 1775, 1777, 5, 82, 42, 2, 1776, 1775, 3, 2, 2, 2, 1776, 1777,
	3, 2, 2, 2, 1777, 1779, 3, 2, 2, 2, 1778, 1780, 5, 164, 83, 2, 1779, 1778,
	3, 2, 2, 2, 1779, 1780, 3, 2, 2, 2, 1780, 1782, 3, 2, 2, 2, 1781, 1761,
	3, 2, 2, 2, 1781, 1774, 3, 2, 2, 2, 1782, 161, 3, 2, 2, 2, 1783, 1784,
	5, 160, 81, 2, 1784, 1785, 5, 110, 56, 2, 1785, 163, 3, 2, 2, 2, 1786,
	1787, 9, 9, 2, 2, 1787, 165, 3, 2, 2, 2, 1788, 1790, 5, 526, 264, 2, 1789,
	1788, 3, 2, 2, 2, 1790, 1793, 3, 2, 2, 2, 1791, 1789, 3, 2, 2, 2, 1791,
	1792, 3, 2, 2, 2, 1792, 1794, 3, 2, 2, 2, 1793, 1791, 3, 2, 2, 2, 1794,
	1845, 5, 168, 85, 2, 1795, 1797, 5, 526, 264, 2, 1796, 1795, 3, 2, 2, 2,
	1797, 1800, 3, 2, 2, 2, 1798, 1796, 3, 2, 2, 2, 1798, 1799, 3, 2, 2, 2,
	1799, 1801, 3, 2, 2, 2, 1800, 1798, 3, 2, 2, 2, 1801, 1845, 5, 66, 34,
	2, 1802, 1804, 5, 526, 264, 2, 1803, 1802, 3, 2, 2, 2, 1804, 1807, 3, 2,
	2, 2, 1805, 1803, 3, 2, 2, 2, 1805, 1806, 3, 2, 2, 2, 1806, 1808, 3, 2,
	2, 2, 1807, 1805, 3, 2, 2, 2, 1808, 1845, 5, 70, 36, 2, 1809, 1811, 5,
	526, 264, 2, 1810, 1809, 3, 2, 2, 2, 1811, 1814, 3, 2, 2, 2, 1812, 1810,
	3, 2, 2, 2, 1812, 1813, 3, 2, 2, 2, 1813, 1815, 3, 2, 2, 2, 1814, 1812,
	3, 2, 2, 2, 1815, 1845, 5, 52, 27, 2, 1816, 1818, 5, 526, 264, 2, 1817,
	1816, 3, 2, 2, 2, 1818, 1821, 3, 2, 2, 2, 1819, 1817, 3, 2, 2, 2, 1819,
	1820, 3, 2, 2, 2, 1820, 1822, 3, 2, 2, 2, 1821, 1819, 3, 2, 2, 2, 1822,
	1845, 5, 54, 28, 2, 1823, 1825, 5, 526, 264, 2, 1824, 1823, 3, 2, 2, 2,
	1825, 1828, 3, 2, 2, 2, 1826, 1824, 3, 2, 2, 2, 1826, 1827, 3, 2, 2, 2,
	1827, 1829, 3, 2, 2, 2, 1828, 1826, 3, 2, 2, 2, 1829, 1845, 5, 74, 38,
	2, 1830, 1832, 5, 526, 264, 2, 1831, 1830, 3, 2, 2, 2, 1832, 1835, 3, 2,
	2, 2, 1833, 1831, 3, 2, 2, 2, 1833, 1834, 3, 2, 2, 2, 1834, 1836, 3, 2,
	2, 2, 1835, 1833, 3, 2, 2, 2, 1836, 1845, 5, 76, 39, 2, 1837, 1839, 5,
	526, 264, 2, 1838, 1837, 3, 2, 2, 2, 1839, 1842, 3, 2, 2, 2, 1840, 1838,
	3, 2, 2, 2, 1840, 1841, 3, 2, 2, 2, 1841, 1843, 3, 2, 2, 2, 1842, 1840,
	3, 2, 2, 2, 1843, 1845, 5, 72, 37, 2, 1844, 1791, 3, 2, 2, 2, 1844, 1798,
	3, 2, 2, 2, 1844, 1805, 3, 2, 2, 2, 1844, 1812, 3, 2, 2, 2, 1844, 1819,
	3, 2, 2, 2, 1844, 1826, 3, 2, 2, 2, 1844, 1833, 3, 2, 2, 2, 1844, 1840,
	3, 2, 2, 2, 1845, 167, 3, 2, 2, 2, 1846, 1848, 7, 37, 2, 2, 1847, 1849,
	7, 27, 2, 2, 1848, 1847, 3, 2, 2, 2, 1848, 1849, 3, 2, 2, 2, 1849, 1851,
	3, 2, 2, 2, 1850, 1852, 5, 140, 71, 2, 1851, 1850, 3, 2, 2, 2, 1851, 1852,
	3, 2, 2, 2, 1852, 1853, 3, 2, 2, 2, 1853, 1854, 5, 170, 86, 2, 1854, 1855,
	7, 4, 2, 2, 1855, 169, 3, 2, 2, 2, 1856, 1861, 5, 172, 87, 2, 1857, 1858,
	7, 19, 2, 2, 1858, 1860, 5, 172, 87, 2, 1859, 1857, 3, 2, 2, 2, 1860, 1863,
	3, 2, 2, 2, 1861, 1859, 3, 2, 2, 2, 1861, 1862, 3, 2, 2, 2, 1862, 171,
	3, 2, 2, 2, 1863, 1861, 3, 2, 2, 2, 1864, 1874, 5, 620, 311, 2, 1865, 1866,
	5, 620, 311, 2, 1866, 1870, 5, 138, 70, 2, 1867, 1869, 5, 138, 70, 2, 1868,
	1867, 3, 2, 2, 2, 1869, 1872, 3, 2, 2, 2, 1870, 1868, 3, 2, 2, 2, 1870,
	1871, 3, 2, 2, 2, 1871, 1874, 3, 2, 2, 2, 1872, 1870, 3, 2, 2, 2, 1873,
	1864, 3, 2, 2, 2, 1873, 1865, 3, 2, 2, 2, 1874, 173, 3, 2, 2, 2, 1875,
	1877, 5, 210, 106, 2, 1876, 1878, 5, 98, 50, 2, 1877, 1876, 3, 2, 2, 2,
	1877, 1878, 3, 2, 2, 2, 1878, 1879, 3, 2, 2, 2, 1879, 1884, 5, 176, 89,
	2, 1880, 1881, 7, 19, 2, 2, 1881, 1883, 5, 176, 89, 2, 1882, 1880, 3, 2,
	2, 2, 1883, 1886, 3, 2, 2, 2, 1884, 1882, 3, 2, 2, 2, 1884, 1885, 3, 2,
	2, 2, 1885, 1887, 3, 2, 2, 2, 1886, 1884, 3, 2, 2, 2, 1887, 1888, 7, 4,
	2, 2, 1888, 2008, 3, 2, 2, 2, 1889, 1891, 5, 214, 108, 2, 1890, 1892, 5,
	98, 50, 2, 1891, 1890, 3, 2, 2, 2, 1891, 1892, 3, 2, 2, 2, 1892, 1893,
	3, 2, 2, 2, 1893, 1898, 5, 180, 91, 2, 1894, 1895, 7, 19, 2, 2, 1895, 1897,
	5, 180, 91, 2, 1896, 1894, 3, 2, 2, 2, 1897, 1900, 3, 2, 2, 2, 1898, 1896,
	3, 2, 2, 2, 1898, 1899, 3, 2, 2, 2, 1899, 1901, 3, 2, 2, 2, 1900, 1898,
	3, 2, 2, 2, 1901, 1902, 7, 4, 2, 2, 1902, 2008, 3, 2, 2, 2, 1903, 1904,
	5, 222, 112, 2, 1904, 1909, 5, 186, 94, 2, 1905, 1906, 7, 19, 2, 2, 1906,
	1908, 5, 186, 94, 2, 1907, 1905, 3, 2, 2, 2, 1908, 1911, 3, 2, 2, 2, 1909,
	1907, 3, 2, 2, 2, 1909, 1910, 3, 2, 2, 2, 1910, 1912, 3, 2, 2, 2, 1911,
	1909, 3, 2, 2, 2, 1912, 1913, 7, 4, 2, 2, 1913, 2008, 3, 2, 2, 2, 1914,
	1916, 7, 73, 2, 2, 1915, 1917, 5, 194, 98, 2, 1916, 1915, 3, 2, 2, 2, 1916,
	1917, 3, 2, 2, 2, 1917, 1918, 3, 2, 2, 2, 1918, 1923, 5, 190, 96, 2, 1919,
	1920, 7, 19, 2, 2, 1920, 1922, 5, 190, 96, 2, 1921, 1919, 3, 2, 2, 2, 1922,
	1925, 3, 2, 2, 2, 1923, 1921, 3, 2, 2, 2, 1923, 1924, 3, 2, 2, 2, 1924,
	1926, 3, 2, 2, 2, 1925, 1923, 3, 2, 2, 2, 1926, 1927, 7, 4, 2, 2, 1927,
	2008, 3, 2, 2, 2, 1928, 1930, 7, 74, 2, 2, 1929, 1931, 5, 196, 99, 2, 1930,
	1929, 3, 2, 2, 2, 1930, 1931, 3, 2, 2, 2, 1931, 1932, 3, 2, 2, 2, 1932,
	1937, 5, 190, 96, 2, 1933, 1934, 7, 19, 2, 2, 1934, 1936, 5, 190, 96, 2,
	1935, 1933, 3, 2, 2, 2, 1936, 1939, 3, 2, 2, 2, 1937, 1935, 3, 2, 2, 2,
	1937, 1938, 3, 2, 2, 2, 1938, 1940, 3, 2, 2, 2, 1939, 1937, 3, 2, 2, 2,
	1940, 1941, 7, 4, 2, 2, 1941, 2008, 3, 2, 2, 2, 1942, 1944, 5, 212, 107,
	2, 1943, 1945, 5, 90, 46, 2, 1944, 1943, 3, 2, 2, 2, 1944, 1945, 3, 2,
	2, 2, 1945, 1947, 3, 2, 2, 2, 1946, 1948, 5, 98, 50, 2, 1947, 1946, 3,
	2, 2, 2, 1947, 1948, 3, 2, 2, 2, 1948, 1949, 3, 2, 2, 2, 1949, 1954, 5,
	178, 90, 2, 1950, 1951, 7, 19, 2, 2, 1951, 1953, 5, 178, 90, 2, 1952, 1950,
	3, 2, 2, 2, 1953, 1956, 3, 2, 2, 2, 1954, 1952, 3, 2, 2, 2, 1954, 1955,
	3, 2, 2, 2, 1955, 1957, 3, 2, 2, 2, 1956, 1954, 3, 2, 2, 2, 1957, 1958,
	7, 4, 2, 2, 1958, 2008, 3, 2, 2, 2, 1959, 1961, 5, 216, 109, 2, 1960, 1962,
	5, 90, 46, 2, 1961, 1960, 3, 2, 2, 2, 1961, 1962, 3, 2, 2, 2, 1962, 1964,
	3, 2, 2, 2, 1963, 1965, 5, 100, 51, 2, 1964, 1963, 3, 2, 2, 2, 1964, 1965,
	3, 2, 2, 2, 1965, 1966, 3, 2, 2, 2, 1966, 1971, 5, 182, 92, 2, 1967, 1968,
	7, 19, 2, 2, 1968, 1970, 5, 182, 92, 2, 1969, 1967, 3, 2, 2, 2, 1970, 1973,
	3, 2, 2, 2, 1971, 1969, 3, 2, 2, 2, 1971, 1972, 3, 2, 2, 2, 1972, 1974,
	3, 2, 2, 2, 1973, 1971, 3, 2, 2, 2, 1974, 1975, 7, 4, 2, 2, 1975, 2008,
	3, 2, 2, 2, 1976, 1978, 5, 218, 110, 2, 1977, 1979, 5, 90, 46, 2, 1978,
	1977, 3, 2, 2, 2, 1978, 1979, 3, 2, 2, 2, 1979, 1981, 3, 2, 2, 2, 1980,
	1982, 5, 100, 51, 2, 1981, 1980, 3, 2, 2, 2, 1981, 1982, 3, 2, 2, 2, 1982,
	1983, 3, 2, 2, 2, 1983, 1988, 5, 184, 93, 2, 1984, 1985, 7, 19, 2, 2, 1985,
	1987, 5, 184, 93, 2, 1986, 1984, 3, 2, 2, 2, 1987, 1990, 3, 2, 2, 2, 1988,
	1986, 3, 2, 2, 2, 1988, 1989, 3, 2, 2, 2, 1989, 1991, 3, 2, 2, 2, 1990,
	1988, 3, 2, 2, 2, 1991, 1992, 7, 4, 2, 2, 1992, 2008, 3, 2, 2, 2, 1993,
	1995, 5, 220, 111, 2, 1994, 1996, 5, 100, 51, 2, 1995, 1994, 3, 2, 2, 2,
	1995, 1996, 3, 2, 2, 2, 1996, 1997, 3, 2, 2, 2, 1997, 2002, 5, 188, 95,
	2, 1998, 1999, 7, 19, 2, 2, 1999, 2001, 5, 188, 95, 2, 2000, 1998, 3, 2,
	2, 2, 2001, 2004, 3, 2, 2, 2, 2002, 2000, 3, 2, 2, 2, 2002, 2003, 3, 2,
	2, 2, 2003, 2005, 3, 2, 2, 2, 2004, 2002, 3, 2, 2, 2, 2005, 2006, 7, 4,
	2, 2, 2006, 2008, 3, 2, 2, 2, 2007, 1875, 3, 2, 2, 2, 2007, 1889, 3, 2,
	2, 2, 2007, 1903, 3, 2, 2, 2, 2007, 1914, 3, 2, 2, 2, 2007, 1928, 3, 2,
	2, 2, 2007, 1942, 3, 2, 2, 2, 2007, 1959, 3, 2, 2, 2, 2007, 1976, 3, 2,
	2, 2, 2007, 1993, 3, 2, 2, 2, 2008, 175, 3, 2, 2, 2, 2009, 2011, 5, 192,
	97, 2, 2010, 2009, 3, 2, 2, 2, 2010, 2011, 3, 2, 2, 2, 2011, 2012, 3, 2,
	2, 2, 2012, 2013, 7, 18, 2, 2, 2013, 2014, 5, 208, 105, 2, 2014, 2015,
	7, 19, 2, 2, 2015, 2016, 5, 204, 103, 2, 2016, 2017, 7, 19, 2, 2, 2017,
	2018, 5, 200, 101, 2, 2018, 2019, 7, 19, 2, 2, 2019, 2020, 5, 202, 102,
	2, 2020, 2021, 7, 20, 2, 2, 2021, 177, 3, 2, 2, 2, 2022, 2024, 5, 192,
	97, 2, 2023, 2022, 3, 2, 2, 2, 2023, 2024, 3, 2, 2, 2, 2024, 2025, 3, 2,
	2, 2, 2025, 2026, 7, 18, 2, 2, 2026, 2027, 5, 208, 105, 2, 2027, 2028,
	7, 19, 2, 2, 2028, 2029, 5, 204, 103, 2, 2029, 2030, 7, 19, 2, 2, 2030,
	2031, 5, 198, 100, 2, 2031, 2032, 7, 20, 2, 2, 2032, 179, 3, 2, 2, 2, 2033,
	2035, 5, 192, 97, 2, 2034, 2033, 3, 2, 2, 2, 2034, 2035, 3, 2, 2, 2, 2035,
	2036, 3, 2, 2, 2, 2036, 2037, 7, 18, 2, 2, 2037, 2038, 5, 208, 105, 2,
	2038, 2039, 7, 19, 2, 2, 2039, 2040, 5, 204, 103, 2, 2040, 2041, 7, 19,
	2, 2, 2041, 2042, 5, 198, 100, 2, 2042, 2043, 7, 20, 2, 2, 2043, 181, 3,
	2, 2, 2, 2044, 2046, 5, 192, 97, 2, 2045, 2044, 3, 2, 2, 2, 2045, 2046,
	3, 2, 2, 2, 2046, 2047, 3, 2, 2, 2, 2047, 2048, 7, 18, 2, 2, 2048, 2049,
	5, 208, 105, 2, 2049, 2050, 7, 19, 2, 2, 2050, 2055, 5, 204, 103, 2, 2051,
	2052, 7, 19, 2, 2, 2052, 2054, 5, 204, 103, 2, 2053, 2051, 3, 2, 2, 2,
	2054, 2057, 3, 2, 2, 2, 2055, 2053, 3, 2, 2, 2, 2055, 2056, 3, 2, 2, 2,
	2056, 2058, 3, 2, 2, 2, 2057, 2055, 3, 2, 2, 2, 2058, 2059, 7, 20, 2, 2,
	2059, 183, 3, 2, 2, 2, 2060, 2062, 5, 192, 97, 2, 2061, 2060, 3, 2, 2,
	2, 2061, 2062, 3, 2, 2, 2, 2062, 2063, 3, 2, 2, 2, 2063, 2064, 7, 18, 2,
	2, 2064, 2069, 5, 208, 105, 2, 2065, 2066, 7, 19, 2, 2, 2066, 2068, 5,
	208, 105, 2, 2067, 2065, 3, 2, 2, 2, 2068, 2071, 3, 2, 2, 2, 2069, 2067,
	3, 2, 2, 2, 2069, 2070, 3, 2, 2, 2, 2070, 2072, 3, 2, 2, 2, 2071, 2069,
	3, 2, 2, 2, 2072, 2073, 7, 19, 2, 2, 2073, 2074, 5, 204, 103, 2, 2074,
	2075, 7, 20, 2, 2, 2075, 185, 3, 2, 2, 2, 2076, 2078, 5, 192, 97, 2, 2077,
	2076, 3, 2, 2, 2, 2077, 2078, 3, 2, 2, 2, 2078, 2079, 3, 2, 2, 2, 2079,
	2080, 7, 18, 2, 2, 2080, 2081, 5, 206, 104, 2, 2081, 2082, 7, 19, 2, 2,
	2082, 2083, 5, 206, 104, 2, 2083, 2084, 7, 20, 2, 2, 2084, 187, 3, 2, 2,
	2, 2085, 2087, 5, 192, 97, 2, 2086, 2085, 3, 2, 2, 2, 2086, 2087, 3, 2,
	2, 2, 2087, 2088, 3, 2, 2, 2, 2088, 2089, 7, 18, 2, 2, 2089, 2090, 5, 206,
	104, 2, 2090, 2091, 7, 19, 2, 2, 2091, 2092, 5, 206, 104, 2, 2092, 2093,
	7, 19, 2, 2, 2093, 2094, 5, 198, 100, 2, 2094, 2095, 7, 20, 2, 2, 2095,
	189, 3, 2, 2, 2, 2096, 2098, 5, 192, 97, 2, 2097, 2096, 3, 2, 2, 2, 2097,
	2098, 3, 2, 2, 2, 2098, 2099, 3, 2, 2, 2, 2099, 2100, 7, 18, 2, 2, 2100,
	2101, 5, 208, 105, 2, 2101, 2102, 7, 20, 2, 2, 2102, 191, 3, 2, 2, 2, 2103,
	2105, 5, 550, 276, 2, 2104, 2106, 5, 140, 71, 2, 2105, 2104, 3, 2, 2, 2,
	2105, 2106, 3, 2, 2, 2, 2106, 193, 3, 2, 2, 2, 2107, 2108, 7, 18, 2, 2,
	2108, 2109, 5, 92, 47, 2, 2109, 2110, 7, 19, 2, 2, 2110, 2111, 5, 94, 48,
	2, 2111, 2112, 7, 20, 2, 2, 2112, 2124, 3, 2, 2, 2, 2113, 2114, 7, 18,
	2, 2, 2114, 2115, 5, 94, 48, 2, 2115, 2116, 7, 19, 2, 2, 2116, 2117, 5,
	92, 47, 2, 2117, 2118, 7, 20, 2, 2, 2118, 2124, 3, 2, 2, 2, 2119, 2120,
	7, 18, 2, 2, 2120, 2121, 5, 92, 47, 2, 2121, 2122, 7, 20, 2, 2, 2122, 2124,
	3, 2, 2, 2, 2123, 2107, 3, 2, 2, 2, 2123, 2113, 3, 2, 2, 2, 2123, 2119,
	3, 2, 2, 2, 2124, 195, 3, 2, 2, 2, 2125, 2126, 7, 18, 2, 2, 2126, 2127,
	5, 92, 47, 2, 2127, 2128, 7, 19, 2, 2, 2128, 2129, 5, 94, 48, 2, 2129,
	2130, 7, 20, 2, 2, 2130, 2142, 3, 2, 2, 2, 2131, 2132, 7, 18, 2, 2, 2132,
	2133, 5, 94, 48, 2, 2133, 2134, 7, 19, 2, 2, 2134, 2135, 5, 92, 47, 2,
	2135, 2136, 7, 20, 2, 2, 2136, 2142, 3, 2, 2, 2, 2137, 2138, 7, 18, 2,
	2, 2138, 2139, 5, 94, 48, 2, 2139, 2140, 7, 20, 2, 2, 2140, 2142, 3, 2,
	2, 2, 2141, 2125, 3, 2, 2, 2, 2141, 2131, 3, 2, 2, 2, 2141, 2137, 3, 2,
	2, 2, 2142, 197, 3, 2, 2, 2, 2143, 2144, 5, 482, 242, 2, 2144, 199, 3,
	2, 2, 2, 2145, 2146, 5, 482, 242, 2, 2146, 201, 3, 2, 2, 2, 2147, 2148,
	5, 482, 242, 2, 2148, 203, 3, 2, 2, 2, 2149, 2150, 5, 482, 242, 2, 2150,
	205, 3, 2, 2, 2, 2151, 2152, 5, 508, 255, 2, 2152, 207, 3, 2, 2, 2, 2153,
	2154, 5, 508, 255, 2, 2154, 209, 3, 2, 2, 2, 2155, 2156, 9, 10, 2, 2, 2156,
	211, 3, 2, 2, 2, 2157, 2158, 9, 11, 2, 2, 2158, 213, 3, 2, 2, 2, 2159,
	2160, 9, 12, 2, 2, 2160, 215, 3, 2, 2, 2, 2161, 2162, 9, 13, 2, 2, 2162,
	217, 3, 2, 2, 2, 2163, 2164, 9, 14, 2, 2, 2164, 219, 3, 2, 2, 2, 2165,
	2166, 9, 15, 2, 2, 2166, 221, 3, 2, 2, 2, 2167, 2168, 9, 16, 2, 2, 2168,
	223, 3, 2, 2, 2, 2169, 2171, 5, 584, 293, 2, 2170, 2172, 5, 226, 114, 2,
	2171, 2170, 3, 2, 2, 2, 2171, 2172, 3, 2, 2, 2, 2172, 2173, 3, 2, 2, 2,
	2173, 2178, 5, 234, 118, 2, 2174, 2175, 7, 19, 2, 2, 2175, 2177, 5, 234,
	118, 2, 2176, 2174, 3, 2, 2, 2, 2177, 2180, 3, 2, 2, 2, 2178, 2176, 3,
	2, 2, 2, 2178, 2179, 3, 2, 2, 2, 2179, 2181, 3, 2, 2, 2, 2180, 2178, 3,
	2, 2, 2, 2181, 2182, 7, 4, 2, 2, 2182, 225, 3, 2, 2, 2, 2183, 2184, 7,
	17, 2, 2, 2184, 2185, 7, 18, 2, 2, 2185, 2186, 5, 228, 115, 2, 2186, 2187,
	7, 20, 2, 2, 2187, 227, 3, 2, 2, 2, 2188, 2193, 5, 230, 116, 2, 2189, 2190,
	7, 19, 2, 2, 2190, 2192, 5, 230, 116, 2, 2191, 2189, 3, 2, 2, 2, 2192,
	2195, 3, 2, 2, 2, 2193, 2191, 3, 2, 2, 2, 2193, 2194, 3, 2, 2, 2, 2194,
	2205, 3, 2, 2, 2, 2195, 2193, 3, 2, 2, 2, 2196, 2201, 5, 232, 117, 2, 2197,
	2198, 7, 19, 2, 2, 2198, 2200, 5, 232, 117, 2, 2199, 2197, 3, 2, 2, 2,
	2200, 2203, 3, 2, 2, 2, 2201, 2199, 3, 2, 2, 2, 2201, 2202, 3, 2, 2, 2,
	2202, 2205, 3, 2, 2, 2, 2203, 2201, 3, 2, 2, 2, 2204, 2188, 3, 2, 2, 2,
	2204, 2196, 3, 2, 2, 2, 2205, 229, 3, 2, 2, 2, 2206, 2207, 5, 482, 242,
	2, 2207, 231, 3, 2, 2, 2, 2208, 2209, 7, 7, 2, 2, 2209, 2210, 5, 592, 297,
	2, 2210, 2212, 7, 18, 2, 2, 2211, 2213, 5, 482, 242, 2, 2212, 2211, 3,
	2, 2, 2, 2212, 2213, 3, 2, 2, 2, 2213, 2214, 3, 2, 2, 2, 2214, 2215, 7,
	20, 2, 2, 2215, 233, 3, 2, 2, 2, 2216, 2217, 5, 236, 119, 2, 2217, 2218,
	7, 18, 2, 2, 2218, 2219, 5, 238, 120, 2, 2219, 2220, 7, 20, 2, 2, 2220,
	235, 3, 2, 2, 2, 2221, 2223, 5, 586, 294, 2, 2222, 2224, 5, 140, 71, 2,
	2223, 2222, 3, 2, 2, 2, 2223, 2224, 3, 2, 2, 2, 2224, 237, 3, 2, 2, 2,
	2225, 2230, 5, 240, 121, 2, 2226, 2227, 7, 19, 2, 2, 2227, 2229, 5, 240,
	121, 2, 2228, 2226, 3, 2, 2, 2, 2229, 2232, 3, 2, 2, 2, 2230, 2228, 3,
	2, 2, 2, 2230, 2231, 3, 2, 2, 2, 2231, 2242, 3, 2, 2, 2, 2232, 2230, 3,
	2, 2, 2, 2233, 2238, 5, 242, 122, 2, 2234, 2235, 7, 19, 2, 2, 2235, 2237,
	5, 242, 122, 2, 2236, 2234, 3, 2, 2, 2, 2237, 2240, 3, 2, 2, 2, 2238, 2236,
	3, 2, 2, 2, 2238, 2239, 3, 2, 2, 2, 2239, 2242, 3, 2, 2, 2, 2240, 2238,
	3, 2, 2, 2, 2241, 2225, 3, 2, 2, 2, 2241, 2233, 3, 2, 2, 2, 2242, 239,
	3, 2, 2, 2, 2243, 2245, 5, 526, 264, 2, 2244, 2243, 3, 2, 2, 2, 2245, 2248,
	3, 2, 2, 2, 2246, 2244, 3, 2, 2, 2, 2246, 2247, 3, 2, 2, 2, 2247, 2250,
	3, 2, 2, 2, 2248, 2246, 3, 2, 2, 2, 2249, 2251, 5, 482, 242, 2, 2250, 2249,
	3, 2, 2, 2, 2250, 2251, 3, 2, 2, 2, 2251, 241, 3, 2, 2, 2, 2252, 2254,
	5, 526, 264, 2, 2253, 2252, 3, 2, 2, 2, 2254, 2257, 3, 2, 2, 2, 2255, 2253,
	3, 2, 2, 2, 2255, 2256, 3, 2, 2, 2, 2256, 2258, 3, 2, 2, 2, 2257, 2255,
	3, 2, 2, 2, 2258, 2259, 7, 7, 2, 2, 2259, 2260, 5, 594, 298, 2, 2260, 2262,
	7, 18, 2, 2, 2261, 2263, 5, 482, 242, 2, 2262, 2261, 3, 2, 2, 2, 2262,
	2263, 3, 2, 2, 2, 2263, 2264, 3, 2, 2, 2, 2264, 2265, 7, 20, 2, 2, 2265,
	243, 3, 2, 2, 2, 2266, 2270, 7, 99, 2, 2, 2267, 2269, 5, 248, 125, 2, 2268,
	2267, 3, 2, 2, 2, 2269, 2272, 3, 2, 2, 2, 2270, 2268, 3, 2, 2, 2, 2270,
	2271, 3, 2, 2, 2, 2271, 2273, 3, 2, 2, 2, 2272, 2270, 3, 2, 2, 2, 2273,
	2274, 7, 100, 2, 2, 2274, 245, 3, 2, 2, 2, 2275, 2278, 5, 248, 125, 2,
	2276, 2278, 7, 4, 2, 2, 2277, 2275, 3, 2, 2, 2, 2277, 2276, 3, 2, 2, 2,
	2278, 247, 3, 2, 2, 2, 2279, 2285, 5, 250, 126, 2, 2280, 2285, 5, 252,
	127, 2, 2281, 2285, 5, 256, 129, 2, 2282, 2285, 5, 260, 131, 2, 2283, 2285,
	5, 44, 23, 2, 2284, 2279, 3, 2, 2, 2, 2284, 2280, 3, 2, 2, 2, 2284, 2281,
	3, 2, 2, 2, 2284, 2282, 3, 2, 2, 2, 2284, 2283, 3, 2, 2, 2, 2285, 249,
	3, 2, 2, 2, 2286, 2287, 7, 101, 2, 2, 2287, 2288, 7, 18, 2, 2, 2288, 2289,
	5, 474, 238, 2, 2289, 2290, 7, 20, 2, 2, 2290, 2293, 5, 246, 124, 2, 2291,
	2292, 7, 102, 2, 2, 2292, 2294, 5, 246, 124, 2, 2293, 2291, 3, 2, 2, 2,
	2293, 2294, 3, 2, 2, 2, 2294, 251, 3, 2, 2, 2, 2295, 2296, 7, 103, 2, 2,
	2296, 2297, 7, 18, 2, 2, 2297, 2298, 5, 474, 238, 2, 2298, 2299, 7, 20,
	2, 2, 2299, 2303, 5, 254, 128, 2, 2300, 2302, 5, 254, 128, 2, 2301, 2300,
	3, 2, 2, 2, 2302, 2305, 3, 2, 2, 2, 2303, 2301, 3, 2, 2, 2, 2303, 2304,
	3, 2, 2, 2, 2304, 2306, 3, 2, 2, 2, 2305, 2303, 3, 2, 2, 2, 2306, 2307,
	7, 104, 2, 2, 2307, 253, 3, 2, 2, 2, 2308, 2313, 5, 474, 238, 2, 2309,
	2310, 7, 19, 2, 2, 2310, 2312, 5, 474, 238, 2, 2311, 2309, 3, 2, 2, 2,
	2312, 2315, 3, 2, 2, 2, 2313, 2311, 3, 2, 2, 2, 2313, 2314, 3, 2, 2, 2,
	2314, 2316, 3, 2, 2, 2, 2315, 2313, 3, 2, 2, 2, 2316, 2317, 7, 67, 2, 2,
	2317, 2318, 5, 246, 124, 2, 2318, 2325, 3, 2, 2, 2, 2319, 2321, 7, 8, 2,
	2, 2320, 2322, 7, 67, 2, 2, 2321, 2320, 3, 2, 2, 2, 2321, 2322, 3, 2, 2,
	2, 2322, 2323, 3, 2, 2, 2, 2323, 2325, 5, 246, 124, 2, 2324, 2308, 3, 2,
	2, 2, 2324, 2319, 3, 2, 2, 2, 2325, 255, 3, 2, 2, 2, 2326, 2327, 7, 105,
	2, 2, 2327, 2328, 7, 18, 2, 2, 2328, 2329, 5, 258, 130, 2, 2329, 2330,
	7, 4, 2, 2, 2330, 2331, 5, 474, 238, 2, 2331, 2332, 7, 4, 2, 2, 2332, 2333,
	5, 258, 130, 2, 2333, 2334, 7, 20, 2, 2, 2334, 2335, 5, 260, 131, 2, 2335,
	257, 3, 2, 2, 2, 2336, 2337, 5, 556, 279, 2, 2337, 2338, 7, 53, 2, 2, 2338,
	2339, 5, 474, 238, 2, 2339, 259, 3, 2, 2, 2, 2340, 2343, 7, 106, 2, 2,
	2341, 2342, 7, 67, 2, 2, 2342, 2344, 5, 552, 277, 2, 2343, 2341, 3, 2,
	2, 2, 2343, 2344, 3, 2, 2, 2, 2344, 2348, 3, 2, 2, 2, 2345, 2347, 5, 248,
	125, 2, 2346, 2345, 3, 2, 2, 2, 2347, 2350, 3, 2, 2, 2, 2348, 2346, 3,
	2, 2, 2, 2348, 2349, 3, 2, 2, 2, 2349, 2351, 3, 2, 2, 2, 2350, 2348, 3,
	2, 2, 2, 2351, 2352, 7, 107, 2, 2, 2352, 261, 3, 2, 2, 2, 2353, 2355, 7,
	108, 2, 2, 2354, 2356, 5, 90, 46, 2, 2355, 2354, 3, 2, 2, 2, 2355, 2356,
	3, 2, 2, 2, 2356, 2358, 3, 2, 2, 2, 2357, 2359, 5, 98, 50, 2, 2358, 2357,
	3, 2, 2, 2, 2358, 2359, 3, 2, 2, 2, 2359, 2360, 3, 2, 2, 2, 2360, 2361,
	5, 264, 133, 2, 2361, 2362, 7, 4, 2, 2, 2362, 263, 3, 2, 2, 2, 2363, 2368,
	5, 266, 134, 2, 2364, 2365, 7, 19, 2, 2, 2365, 2367, 5, 266, 134, 2, 2366,
	2364, 3, 2, 2, 2, 2367, 2370, 3, 2, 2, 2, 2368, 2366, 3, 2, 2, 2, 2368,
	2369, 3, 2, 2, 2, 2369, 265, 3, 2, 2, 2, 2370, 2368, 3, 2, 2, 2, 2371,
	2372, 5, 508, 255, 2, 2372, 2373, 7, 53, 2, 2, 2373, 2374, 5, 482, 242,
	2, 2374, 267, 3, 2, 2, 2, 2375, 2376, 7, 109, 2, 2, 2376, 2377, 5, 290,
	146, 2, 2377, 269, 3, 2, 2, 2, 2378, 2379, 7, 110, 2, 2, 2379, 2380, 5,
	290, 146, 2, 2380, 271, 3, 2, 2, 2, 2381, 2382, 5, 510, 256, 2, 2382, 2384,
	7, 53, 2, 2, 2383, 2385, 5, 296, 149, 2, 2384, 2383, 3, 2, 2, 2, 2384,
	2385, 3, 2, 2, 2, 2385, 2386, 3, 2, 2, 2, 2386, 2387, 5, 482, 242, 2, 2387,
	273, 3, 2, 2, 2, 2388, 2389, 5, 510, 256, 2, 2389, 2391, 7, 111, 2, 2,
	2390, 2392, 5, 296, 149, 2, 2391, 2390, 3, 2, 2, 2, 2391, 2392, 3, 2, 2,
	2, 2392, 2393, 3, 2, 2, 2, 2393, 2394, 5, 482, 242, 2, 2394, 275, 3, 2,
	2, 2, 2395, 2396, 7, 108, 2, 2, 2396, 2408, 5, 284, 143, 2, 2397, 2398,
	7, 112, 2, 2, 2398, 2408, 5, 510, 256, 2, 2399, 2400, 7, 113, 2, 2, 2400,
	2408, 5, 284, 143, 2, 2401, 2402, 7, 113, 2, 2, 2402, 2408, 5, 266, 134,
	2, 2403, 2404, 7, 114, 2, 2, 2404, 2408, 5, 510, 256, 2, 2405, 2406, 7,
	114, 2, 2, 2406, 2408, 5, 508, 255, 2, 2407, 2395, 3, 2, 2, 2, 2407, 2397,
	3, 2, 2, 2, 2407, 2399, 3, 2, 2, 2, 2407, 2401, 3, 2, 2, 2, 2407, 2403,
	3, 2, 2, 2, 2407, 2405, 3, 2, 2, 2, 2408, 277, 3, 2, 2, 2, 2409, 2410,
	5, 510, 256, 2, 2410, 2411, 7, 53, 2, 2, 2411, 2412, 5, 482, 242, 2, 2412,
	279, 3, 2, 2, 2, 2413, 2422, 5, 294, 148, 2, 2414, 2416, 5, 526, 264, 2,
	2415, 2414, 3, 2, 2, 2, 2416, 2419, 3, 2, 2, 2, 2417, 2415, 3, 2, 2, 2,
	2417, 2418, 3, 2, 2, 2, 2418, 2420, 3, 2, 2, 2, 2419, 2417, 3, 2, 2, 2,
	2420, 2422, 7, 4, 2, 2, 2421, 2413, 3, 2, 2, 2, 2421, 2417, 3, 2, 2, 2,
	2422, 281, 3, 2, 2, 2, 2423, 2432, 7, 106, 2, 2, 2424, 2425, 7, 67, 2,
	2, 2425, 2429, 5, 534, 268, 2, 2426, 2428, 5, 166, 84, 2, 2427, 2426, 3,
	2, 2, 2, 2428, 2431, 3, 2, 2, 2, 2429, 2427, 3, 2, 2, 2, 2429, 2430, 3,
	2, 2, 2, 2430, 2433, 3, 2, 2, 2, 2431, 2429, 3, 2, 2, 2, 2432, 2424, 3,
	2, 2, 2, 2432, 2433, 3, 2, 2, 2, 2433, 2437, 3, 2, 2, 2, 2434, 2436, 5,
	294, 148, 2, 2435, 2434, 3, 2, 2, 2, 2436, 2439, 3, 2, 2, 2, 2437, 2435,
	3, 2, 2, 2, 2437, 2438, 3, 2, 2, 2, 2438, 2440, 3, 2, 2, 2, 2439, 2437,
	3, 2, 2, 2, 2440, 2441, 7, 107, 2, 2, 2441, 283, 3, 2, 2, 2, 2442, 2443,
	5, 510, 256, 2, 2443, 2444, 7, 53, 2, 2, 2444, 2445, 5, 482, 242, 2, 2445,
	285, 3, 2, 2, 2, 2446, 2455, 7, 115, 2, 2, 2447, 2448, 7, 67, 2, 2, 2448,
	2452, 5, 534, 268, 2, 2449, 2451, 5, 166, 84, 2, 2450, 2449, 3, 2, 2, 2,
	2451, 2454, 3, 2, 2, 2, 2452, 2450, 3, 2, 2, 2, 2452, 2453, 3, 2, 2, 2,
	2453, 2456, 3, 2, 2, 2, 2454, 2452, 3, 2, 2, 2, 2455, 2447, 3, 2, 2, 2,
	2455, 2456, 3, 2, 2, 2, 2456, 2460, 3, 2, 2, 2, 2457, 2459, 5, 290, 146,
	2, 2458, 2457, 3, 2, 2, 2, 2459, 2462, 3, 2, 2, 2, 2460, 2458, 3, 2, 2,
	2, 2460, 2461, 3, 2, 2, 2, 2461, 2463, 3, 2, 2, 2, 2462, 2460, 3, 2, 2,
	2, 2463, 2464, 7, 116, 2, 2, 2464, 287, 3, 2, 2, 2, 2465, 2474, 7, 106,
	2, 2, 2466, 2467, 7, 67, 2, 2, 2467, 2471, 5, 534, 268, 2, 2468, 2470,
	5, 166, 84, 2, 2469, 2468, 3, 2, 2, 2, 2470, 2473, 3, 2, 2, 2, 2471, 2469,
	3, 2, 2, 2, 2471, 2472, 3, 2, 2, 2, 2472, 2475, 3, 2, 2, 2, 2473, 2471,
	3, 2, 2, 2, 2474, 2466, 3, 2, 2, 2, 2474, 2475, 3, 2, 2, 2, 2475, 2479,
	3, 2, 2, 2, 2476, 2478, 5, 290, 146, 2, 2477, 2476, 3, 2, 2, 2, 2478, 2481,
	3, 2, 2, 2, 2479, 2477, 3, 2, 2, 2, 2479, 2480, 3, 2, 2, 2, 2480, 2482,
	3, 2, 2, 2, 2481, 2479, 3, 2, 2, 2, 2482, 2483, 7, 107, 2, 2, 2483, 289,
	3, 2, 2, 2, 2484, 2486, 5, 526, 264, 2, 2485, 2484, 3, 2, 2, 2, 2486, 2489,
	3, 2, 2, 2, 2487, 2485, 3, 2, 2, 2, 2487, 2488, 3, 2, 2, 2, 2488, 2490,
	3, 2, 2, 2, 2489, 2487, 3, 2, 2, 2, 2490, 2491, 5, 272, 137, 2, 2491, 2492,
	7, 4, 2, 2, 2492, 2589, 3, 2, 2, 2, 2493, 2495, 5, 526, 264, 2, 2494, 2493,
	3, 2, 2, 2, 2495, 2498, 3, 2, 2, 2, 2496, 2494, 3, 2, 2, 2, 2496, 2497,
	3, 2, 2, 2, 2497, 2499, 3, 2, 2, 2, 2498, 2496, 3, 2, 2, 2, 2499, 2589,
	5, 324, 163, 2, 2500, 2502, 5, 526, 264, 2, 2501, 2500, 3, 2, 2, 2, 2502,
	2505, 3, 2, 2, 2, 2503, 2501, 3, 2, 2, 2, 2503, 2504, 3, 2, 2, 2, 2504,
	2506, 3, 2, 2, 2, 2505, 2503, 3, 2, 2, 2, 2506, 2589, 5, 314, 158, 2, 2507,
	2509, 5, 526, 264, 2, 2508, 2507, 3, 2, 2, 2, 2509, 2512, 3, 2, 2, 2, 2510,
	2508, 3, 2, 2, 2, 2510, 2511, 3, 2, 2, 2, 2511, 2513, 3, 2, 2, 2, 2512,
	2510, 3, 2, 2, 2, 2513, 2589, 5, 300, 151, 2, 2514, 2516, 5, 526, 264,
	2, 2515, 2514, 3, 2, 2, 2, 2516, 2519, 3, 2, 2, 2, 2517, 2515, 3, 2, 2,
	2, 2517, 2518, 3, 2, 2, 2, 2518, 2520, 3, 2, 2, 2, 2519, 2517, 3, 2, 2,
	2, 2520, 2589, 5, 304, 153, 2, 2521, 2523, 5, 526, 264, 2, 2522, 2521,
	3, 2, 2, 2, 2523, 2526, 3, 2, 2, 2, 2524, 2522, 3, 2, 2, 2, 2524, 2525,
	3, 2, 2, 2, 2525, 2527, 3, 2, 2, 2, 2526, 2524, 3, 2, 2, 2, 2527, 2589,
	5, 334, 168, 2, 2528, 2530, 5, 526, 264, 2, 2529, 2528, 3, 2, 2, 2, 2530,
	2533, 3, 2, 2, 2, 2531, 2529, 3, 2, 2, 2, 2531, 2532, 3, 2, 2, 2, 2532,
	2534, 3, 2, 2, 2, 2533, 2531, 3, 2, 2, 2, 2534, 2535, 5, 274, 138, 2, 2535,
	2536, 7, 4, 2, 2, 2536, 2589, 3, 2, 2, 2, 2537, 2539, 5, 526, 264, 2, 2538,
	2537, 3, 2, 2, 2, 2539, 2542, 3, 2, 2, 2, 2540, 2538, 3, 2, 2, 2, 2540,
	2541, 3, 2, 2, 2, 2541, 2543, 3, 2, 2, 2, 2542, 2540, 3, 2, 2, 2, 2543,
	2589, 5, 286, 144, 2, 2544, 2546, 5, 526, 264, 2, 2545, 2544, 3, 2, 2,
	2, 2546, 2549, 3, 2, 2, 2, 2547, 2545, 3, 2, 2, 2, 2547, 2548, 3, 2, 2,
	2, 2548, 2550, 3, 2, 2, 2, 2549, 2547, 3, 2, 2, 2, 2550, 2551, 5, 276,
	139, 2, 2551, 2552, 7, 4, 2, 2, 2552, 2589, 3, 2, 2, 2, 2553, 2555, 5,
	526, 264, 2, 2554, 2553, 3, 2, 2, 2, 2555, 2558, 3, 2, 2, 2, 2556, 2554,
	3, 2, 2, 2, 2556, 2557, 3, 2, 2, 2, 2557, 2559, 3, 2, 2, 2, 2558, 2556,
	3, 2, 2, 2, 2559, 2589, 5, 310, 156, 2, 2560, 2562, 5, 526, 264, 2, 2561,
	2560, 3, 2, 2, 2, 2562, 2565, 3, 2, 2, 2, 2563, 2561, 3, 2, 2, 2, 2563,
	2564, 3, 2, 2, 2, 2564, 2566, 3, 2, 2, 2, 2565, 2563, 3, 2, 2, 2, 2566,
	2589, 5, 288, 145, 2, 2567, 2569, 5, 526, 264, 2, 2568, 2567, 3, 2, 2,
	2, 2569, 2572, 3, 2, 2, 2, 2570, 2568, 3, 2, 2, 2, 2570, 2571, 3, 2, 2,
	2, 2571, 2573, 3, 2, 2, 2, 2572, 2570, 3, 2, 2, 2, 2573, 2589, 5, 336,
	169, 2, 2574, 2576, 5, 526, 264, 2, 2575, 2574, 3, 2, 2, 2, 2576, 2579,
	3, 2, 2, 2, 2577, 2575, 3, 2, 2, 2, 2577, 2578, 3, 2, 2, 2, 2578, 2580,
	3, 2, 2, 2, 2579, 2577, 3, 2, 2, 2, 2580, 2589, 5, 338, 170, 2, 2581, 2583,
	5, 526, 264, 2, 2582, 2581, 3, 2, 2, 2, 2583, 2586, 3, 2, 2, 2, 2584, 2582,
	3, 2, 2, 2, 2584, 2585, 3, 2, 2, 2, 2585, 2587, 3, 2, 2, 2, 2586, 2584,
	3, 2, 2, 2, 2587, 2589, 5, 312, 157, 2, 2588, 2487, 3, 2, 2, 2, 2588, 2496,
	3, 2, 2, 2, 2588, 2503, 3, 2, 2, 2, 2588, 2510, 3, 2, 2, 2, 2588, 2517,
	3, 2, 2, 2, 2588, 2524, 3, 2, 2, 2, 2588, 2531, 3, 2, 2, 2, 2588, 2540,
	3, 2, 2, 2, 2588, 2547, 3, 2, 2, 2, 2588, 2556, 3, 2, 2, 2, 2588, 2563,
	3, 2, 2, 2, 2588, 2570, 3, 2, 2, 2, 2588, 2577, 3, 2, 2, 2, 2588, 2584,
	3, 2, 2, 2, 2589, 291, 3, 2, 2, 2, 2590, 2599, 5, 290, 146, 2, 2591, 2593,
	5, 526, 264, 2, 2592, 2591, 3, 2, 2, 2, 2593, 2596, 3, 2, 2, 2, 2594, 2592,
	3, 2, 2, 2, 2594, 2595, 3, 2, 2, 2, 2595, 2597, 3, 2, 2, 2, 2596, 2594,
	3, 2, 2, 2, 2597, 2599, 7, 4, 2, 2, 2598, 2590, 3, 2, 2, 2, 2598, 2594,
	3, 2, 2, 2, 2599, 293, 3, 2, 2, 2, 2600, 2602, 5, 526, 264, 2, 2601, 2600,
	3, 2, 2, 2, 2602, 2605, 3, 2, 2, 2, 2603, 2601, 3, 2, 2, 2, 2603, 2604,
	3, 2, 2, 2, 2604, 2606, 3, 2, 2, 2, 2605, 2603, 3, 2, 2, 2, 2606, 2607,
	5, 278, 140, 2, 2607, 2608, 7, 4, 2, 2, 2608, 2652, 3, 2, 2, 2, 2609, 2611,
	5, 526, 264, 2, 2610, 2609, 3, 2, 2, 2, 2611, 2614, 3, 2, 2, 2, 2612, 2610,
	3, 2, 2, 2, 2612, 2613, 3, 2, 2, 2, 2613, 2615, 3, 2, 2, 2, 2614, 2612,
	3, 2, 2, 2, 2615, 2652, 5, 328, 165, 2, 2616, 2618, 5, 526, 264, 2, 2617,
	2616, 3, 2, 2, 2, 2618, 2621, 3, 2, 2, 2, 2619, 2617, 3, 2, 2, 2, 2619,
	2620, 3, 2, 2, 2, 2620, 2622, 3, 2, 2, 2, 2621, 2619, 3, 2, 2, 2, 2622,
	2652, 5, 320, 161, 2, 2623, 2625, 5, 526, 264, 2, 2624, 2623, 3, 2, 2,
	2, 2625, 2628, 3, 2, 2, 2, 2626, 2624, 3, 2, 2, 2, 2626, 2627, 3, 2, 2,
	2, 2627, 2629, 3, 2, 2, 2, 2628, 2626, 3, 2, 2, 2, 2629, 2652, 5, 332,
	167, 2, 2630, 2632, 5, 526, 264, 2, 2631, 2630, 3, 2, 2, 2, 2632, 2635,
	3, 2, 2, 2, 2633, 2631, 3, 2, 2, 2, 2633, 2634, 3, 2, 2, 2, 2634, 2636,
	3, 2, 2, 2, 2635, 2633, 3, 2, 2, 2, 2636, 2652, 5, 282, 142, 2, 2637, 2639,
	5, 526, 264, 2, 2638, 2637, 3, 2, 2, 2, 2639, 2642, 3, 2, 2, 2, 2640, 2638,
	3, 2, 2, 2, 2640, 2641, 3, 2, 2, 2, 2641, 2643, 3, 2, 2, 2, 2642, 2640,
	3, 2, 2, 2, 2643, 2652, 5, 300, 151, 2, 2644, 2646, 5, 526, 264, 2, 2645,
	2644, 3, 2, 2, 2, 2646, 2649, 3, 2, 2, 2, 2647, 2645, 3, 2, 2, 2, 2647,
	2648, 3, 2, 2, 2, 2648, 2650, 3, 2, 2, 2, 2649, 2647, 3, 2, 2, 2, 2650,
	2652, 5, 336, 169, 2, 2651, 2603, 3, 2, 2, 2, 2651, 2612, 3, 2, 2, 2, 2651,
	2619, 3, 2, 2, 2, 2651, 2626, 3, 2, 2, 2, 2651, 2633, 3, 2, 2, 2, 2651,
	2640, 3, 2, 2, 2, 2651, 2647, 3, 2, 2, 2, 2652, 295, 3, 2, 2, 2, 2653,
	2662, 5, 298, 150, 2, 2654, 2662, 5, 302, 152, 2, 2655, 2656, 7, 117, 2,
	2, 2656, 2657, 7, 18, 2, 2, 2657, 2658, 5, 482, 242, 2, 2658, 2659, 7,
	20, 2, 2, 2659, 2660, 5, 302, 152, 2, 2660, 2662, 3, 2, 2, 2, 2661, 2653,
	3, 2, 2, 2, 2661, 2654, 3, 2, 2, 2, 2661, 2655, 3, 2, 2, 2, 2662, 297,
	3, 2, 2, 2, 2663, 2664, 7, 17, 2, 2, 2664, 2671, 5, 102, 52, 2, 2665, 2666,
	7, 17, 2, 2, 2666, 2667, 7, 18, 2, 2, 2667, 2668, 5, 488, 245, 2, 2668,
	2669, 7, 20, 2, 2, 2669, 2671, 3, 2, 2, 2, 2670, 2663, 3, 2, 2, 2, 2670,
	2665, 3, 2, 2, 2, 2671, 299, 3, 2, 2, 2, 2672, 2673, 7, 118, 2, 2, 2673,
	2674, 5, 570, 286, 2, 2674, 2675, 7, 4, 2, 2, 2675, 2681, 3, 2, 2, 2, 2676,
	2677, 7, 118, 2, 2, 2677, 2678, 5, 558, 280, 2, 2678, 2679, 7, 4, 2, 2,
	2679, 2681, 3, 2, 2, 2, 2680, 2672, 3, 2, 2, 2, 2680, 2676, 3, 2, 2, 2,
	2681, 301, 3, 2, 2, 2, 2682, 2683, 7, 119, 2, 2, 2683, 2696, 5, 546, 274,
	2, 2684, 2685, 7, 119, 2, 2, 2685, 2686, 7, 18, 2, 2, 2686, 2687, 5, 306,
	154, 2, 2687, 2688, 7, 20, 2, 2, 2688, 2696, 3, 2, 2, 2, 2689, 2690, 7,
	119, 2, 2, 2690, 2696, 7, 120, 2, 2, 2691, 2692, 7, 119, 2, 2, 2692, 2693,
	7, 18, 2, 2, 2693, 2694, 7, 120, 2, 2, 2694, 2696, 7, 20, 2, 2, 2695, 2682,
	3, 2, 2, 2, 2695, 2684, 3, 2, 2, 2, 2695, 2689, 3, 2, 2, 2, 2695, 2691,
	3, 2, 2, 2, 2696, 303, 3, 2, 2, 2, 2697, 2698, 7, 121, 2, 2, 2698, 2699,
	5, 560, 281, 2, 2699, 2700, 7, 4, 2, 2, 2700, 305, 3, 2, 2, 2, 2701, 2708,
	5, 308, 155, 2, 2702, 2703, 7, 87, 2, 2, 2703, 2707, 5, 308, 155, 2, 2704,
	2705, 7, 19, 2, 2, 2705, 2707, 5, 308, 155, 2, 2706, 2702, 3, 2, 2, 2,
	2706, 2704, 3, 2, 2, 2, 2707, 2710, 3, 2, 2, 2, 2708, 2706, 3, 2, 2, 2,
	2708, 2709, 3, 2, 2, 2, 2709, 307, 3, 2, 2, 2, 2710, 2708, 3, 2, 2, 2,
	2711, 2717, 5, 482, 242, 2, 2712, 2713, 7, 122, 2, 2, 2713, 2717, 5, 482,
	242, 2, 2714, 2715, 7, 123, 2, 2, 2715, 2717, 5, 482, 242, 2, 2716, 2711,
	3, 2, 2, 2, 2716, 2712, 3, 2, 2, 2, 2716, 2714, 3, 2, 2, 2, 2717, 309,
	3, 2, 2, 2, 2718, 2719, 5, 296, 149, 2, 2719, 2720, 5, 292, 147, 2, 2720,
	311, 3, 2, 2, 2, 2721, 2722, 7, 124, 2, 2, 2722, 2723, 7, 18, 2, 2, 2723,
	2724, 5, 482, 242, 2, 2724, 2725, 7, 20, 2, 2, 2725, 2726, 5, 292, 147,
	2, 2726, 313, 3, 2, 2, 2, 2727, 2728, 7, 101, 2, 2, 2728, 2729, 7, 18,
	2, 2, 2729, 2730, 5, 482, 242, 2, 2730, 2731, 7, 20, 2, 2, 2731, 2735,
	5, 292, 147, 2, 2732, 2733, 5, 318, 160, 2, 2733, 2734, 5, 292, 147, 2,
	2734, 2736, 3, 2, 2, 2, 2735, 2732, 3, 2, 2, 2, 2735, 2736, 3, 2, 2, 2,
	2736, 2739, 3, 2, 2, 2, 2737, 2739, 5, 316, 159, 2, 2738, 2727, 3, 2, 2,
	2, 2738, 2737, 3, 2, 2, 2, 2739, 315, 3, 2, 2, 2, 2740, 2741, 7, 101, 2,
	2, 2741, 2742, 7, 18, 2, 2, 2742, 2743, 5, 482, 242, 2, 2743, 2744, 7,
	20, 2, 2, 2744, 2754, 5, 292, 147, 2, 2745, 2746, 5, 318, 160, 2, 2746,
	2747, 7, 101, 2, 2, 2747, 2748, 7, 18, 2, 2, 2748, 2749, 5, 482, 242, 2,
	2749, 2750, 7, 20, 2, 2, 2750, 2751, 5, 292, 147, 2, 2751, 2753, 3, 2,
	2, 2, 2752, 2745, 3, 2, 2, 2, 2753, 2756, 3, 2, 2, 2, 2754, 2752, 3, 2,
	2, 2, 2754, 2755, 3, 2, 2, 2, 2755, 2760, 3, 2, 2, 2, 2756, 2754, 3, 2,
	2, 2, 2757, 2758, 5, 318, 160, 2, 2758, 2759, 5, 292, 147, 2, 2759, 2761,
	3, 2, 2, 2, 2760, 2757, 3, 2, 2, 2, 2760, 2761, 3, 2, 2, 2, 2761, 317,
	3, 2, 2, 2, 2762, 2763, 7, 102, 2, 2, 2763, 319, 3, 2, 2, 2, 2764, 2765,
	7, 101, 2, 2, 2765, 2766, 7, 18, 2, 2, 2766, 2767, 5, 482, 242, 2, 2767,
	2768, 7, 20, 2, 2, 2768, 2772, 5, 280, 141, 2, 2769, 2770, 5, 318, 160,
	2, 2770, 2771, 5, 280, 141, 2, 2771, 2773, 3, 2, 2, 2, 2772, 2769, 3, 2,
	2, 2, 2772, 2773, 3, 2, 2, 2, 2773, 2776, 3, 2, 2, 2, 2774, 2776, 5, 322,
	162, 2, 2775, 2764, 3, 2, 2, 2, 2775, 2774, 3, 2, 2, 2, 2776, 321, 3, 2,
	2, 2, 2777, 2778, 7, 101, 2, 2, 2778, 2779, 7, 18, 2, 2, 2779, 2780, 5,
	482, 242, 2, 2780, 2781, 7, 20, 2, 2, 2781, 2791, 5, 280, 141, 2, 2782,
	2783, 7, 102, 2, 2, 2783, 2784, 7, 101, 2, 2, 2784, 2785, 7, 18, 2, 2,
	2785, 2786, 5, 482, 242, 2, 2786, 2787, 7, 20, 2, 2, 2787, 2788, 5, 280,
	141, 2, 2788, 2790, 3, 2, 2, 2, 2789, 2782, 3, 2, 2, 2, 2790, 2793, 3,
	2, 2, 2, 2791, 2789, 3, 2, 2, 2, 2791, 2792, 3, 2, 2, 2, 2792, 2796, 3,
	2, 2, 2, 2793, 2791, 3, 2, 2, 2, 2794, 2795, 7, 102, 2, 2, 2795, 2797,
	5, 280, 141, 2, 2796, 2794, 3, 2, 2, 2, 2796, 2797, 3, 2, 2, 2, 2797, 323,
	3, 2, 2, 2, 2798, 2799, 7, 103, 2, 2, 2799, 2800, 7, 18, 2, 2, 2800, 2801,
	5, 482, 242, 2, 2801, 2802, 7, 20, 2, 2, 2802, 2806, 5, 326, 164, 2, 2803,
	2805, 5, 326, 164, 2, 2804, 2803, 3, 2, 2, 2, 2805, 2808, 3, 2, 2, 2, 2806,
	2804, 3, 2, 2, 2, 2806, 2807, 3, 2, 2, 2, 2807, 2809, 3, 2, 2, 2, 2808,
	2806, 3, 2, 2, 2, 2809, 2810, 7, 104, 2, 2, 2810, 2838, 3, 2, 2, 2, 2811,
	2812, 7, 125, 2, 2, 2812, 2813, 7, 18, 2, 2, 2813, 2814, 5, 482, 242, 2,
	2814, 2815, 7, 20, 2, 2, 2815, 2819, 5, 326, 164, 2, 2816, 2818, 5, 326,
	164, 2, 2817, 2816, 3, 2, 2, 2, 2818, 2821, 3, 2, 2, 2, 2819, 2817, 3,
	2, 2, 2, 2819, 2820, 3, 2, 2, 2, 2820, 2822, 3, 2, 2, 2, 2821, 2819, 3,
	2, 2, 2, 2822, 2823, 7, 104, 2, 2, 2823, 2838, 3, 2, 2, 2, 2824, 2825,
	7, 126, 2, 2, 2825, 2826, 7, 18, 2, 2, 2826, 2827, 5, 482, 242, 2, 2827,
	2828, 7, 20, 2, 2, 2828, 2832, 5, 326, 164, 2, 2829, 2831, 5, 326, 164,
	2, 2830, 2829, 3, 2, 2, 2, 2831, 2834, 3, 2, 2, 2, 2832, 2830, 3, 2, 2,
	2, 2832, 2833, 3, 2, 2, 2, 2833, 2835, 3, 2, 2, 2, 2834, 2832, 3, 2, 2,
	2, 2835, 2836, 7, 104, 2, 2, 2836, 2838, 3, 2, 2, 2, 2837, 2798, 3, 2,
	2, 2, 2837, 2811, 3, 2, 2, 2, 2837, 2824, 3, 2, 2, 2, 2838, 325, 3, 2,
	2, 2, 2839, 2844, 5, 482, 242, 2, 2840, 2841, 7, 19, 2, 2, 2841, 2843,
	5, 482, 242, 2, 2842, 2840, 3, 2, 2, 2, 2843, 2846, 3, 2, 2, 2, 2844, 2842,
	3, 2, 2, 2, 2844, 2845, 3, 2, 2, 2, 2845, 2847, 3, 2, 2, 2, 2846, 2844,
	3, 2, 2, 2, 2847, 2848, 7, 67, 2, 2, 2848, 2849, 5, 292, 147, 2, 2849,
	2856, 3, 2, 2, 2, 2850, 2852, 7, 8, 2, 2, 2851, 2853, 7, 67, 2, 2, 2852,
	2851, 3, 2, 2, 2, 2852, 2853, 3, 2, 2, 2, 2853, 2854, 3, 2, 2, 2, 2854,
	2856, 5, 292, 147, 2, 2855, 2839, 3, 2, 2, 2, 2855, 2850, 3, 2, 2, 2, 2856,
	327, 3, 2, 2, 2, 2857, 2858, 7, 103, 2, 2, 2858, 2859, 7, 18, 2, 2, 2859,
	2860, 5, 482, 242, 2, 2860, 2861, 7, 20, 2, 2, 2861, 2865, 5, 330, 166,
	2, 2862, 2864, 5, 330, 166, 2, 2863, 2862, 3, 2, 2, 2, 2864, 2867, 3, 2,
	2, 2, 2865, 2863, 3, 2, 2, 2, 2865, 2866, 3, 2, 2, 2, 2866, 2868, 3, 2,
	2, 2, 2867, 2865, 3, 2, 2, 2, 2868, 2869, 7, 104, 2, 2, 2869, 2897, 3,
	2, 2, 2, 2870, 2871, 7, 125, 2, 2, 2871, 2872, 7, 18, 2, 2, 2872, 2873,
	5, 482, 242, 2, 2873, 2874, 7, 20, 2, 2, 2874, 2878, 5, 330, 166, 2, 2875,
	2877, 5, 330, 166, 2, 2876, 2875, 3, 2, 2, 2, 2877, 2880, 3, 2, 2, 2, 2878,
	2876, 3, 2, 2, 2, 2878, 2879, 3, 2, 2, 2, 2879, 2881, 3, 2, 2, 2, 2880,
	2878, 3, 2, 2, 2, 2881, 2882, 7, 104, 2, 2, 2882, 2897, 3, 2, 2, 2, 2883,
	2884, 7, 126, 2, 2, 2884, 2885, 7, 18, 2, 2, 2885, 2886, 5, 482, 242, 2,
	2886, 2887, 7, 20, 2, 2, 2887, 2891, 5, 330, 166, 2, 2888, 2890, 5, 330,
	166, 2, 2889, 2888, 3, 2, 2, 2, 2890, 2893, 3, 2, 2, 2, 2891, 2889, 3,
	2, 2, 2, 2891, 2892, 3, 2, 2, 2, 2892, 2894, 3, 2, 2, 2, 2893, 2891, 3,
	2, 2, 2, 2894, 2895, 7, 104, 2, 2, 2895, 2897, 3, 2, 2, 2, 2896, 2857,
	3, 2, 2, 2, 2896, 2870, 3, 2, 2, 2, 2896, 2883, 3, 2, 2, 2, 2897, 329,
	3, 2, 2, 2, 2898, 2903, 5, 482, 242, 2, 2899, 2900, 7, 19, 2, 2, 2900,
	2902, 5, 482, 242, 2, 2901, 2899, 3, 2, 2, 2, 2902, 2905, 3, 2, 2, 2, 2903,
	2901, 3, 2, 2, 2, 2903, 2904, 3, 2, 2, 2, 2904, 2906, 3, 2, 2, 2, 2905,
	2903, 3, 2, 2, 2, 2906, 2907, 7, 67, 2, 2, 2907, 2908, 5, 280, 141, 2,
	2908, 2915, 3, 2, 2, 2, 2909, 2911, 7, 8, 2, 2, 2910, 2912, 7, 67, 2, 2,
	2911, 2910, 3, 2, 2, 2, 2911, 2912, 3, 2, 2, 2, 2912, 2913, 3, 2, 2, 2,
	2913, 2915, 5, 280, 141, 2, 2914, 2898, 3, 2, 2, 2, 2914, 2909, 3, 2, 2,
	2, 2915, 331, 3, 2, 2, 2, 2916, 2917, 7, 127, 2, 2, 2917, 2941, 5, 294,
	148, 2, 2918, 2919, 7, 117, 2, 2, 2919, 2920, 7, 18, 2, 2, 2920, 2921,
	5, 482, 242, 2, 2921, 2922, 7, 20, 2, 2, 2922, 2923, 5, 294, 148, 2, 2923,
	2941, 3, 2, 2, 2, 2924, 2925, 7, 128, 2, 2, 2925, 2926, 7, 18, 2, 2, 2926,
	2927, 5, 482, 242, 2, 2927, 2928, 7, 20, 2, 2, 2928, 2929, 5, 294, 148,
	2, 2929, 2941, 3, 2, 2, 2, 2930, 2931, 7, 105, 2, 2, 2931, 2932, 7, 18,
	2, 2, 2932, 2933, 5, 284, 143, 2, 2933, 2934, 7, 4, 2, 2, 2934, 2935, 5,
	482, 242, 2, 2935, 2936, 7, 4, 2, 2, 2936, 2937, 5, 284, 143, 2, 2937,
	2938, 7, 20, 2, 2, 2938, 2939, 5, 294, 148, 2, 2939, 2941, 3, 2, 2, 2,
	2940, 2916, 3, 2, 2, 2, 2940, 2918, 3, 2, 2, 2, 2940, 2924, 3, 2, 2, 2,
	2940, 2930, 3, 2, 2, 2, 2941, 333, 3, 2, 2, 2, 2942, 2943, 7, 127, 2, 2,
	2943, 2967, 5, 290, 146, 2, 2944, 2945, 7, 117, 2, 2, 2945, 2946, 7, 18,
	2, 2, 2946, 2947, 5, 482, 242, 2, 2947, 2948, 7, 20, 2, 2, 2948, 2949,
	5, 290, 146, 2, 2949, 2967, 3, 2, 2, 2, 2950, 2951, 7, 128, 2, 2, 2951,
	2952, 7, 18, 2, 2, 2952, 2953, 5, 482, 242, 2, 2953, 2954, 7, 20, 2, 2,
	2954, 2955, 5, 290, 146, 2, 2955, 2967, 3, 2, 2, 2, 2956, 2957, 7, 105,
	2, 2, 2957, 2958, 7, 18, 2, 2, 2958, 2959, 5, 284, 143, 2, 2959, 2960,
	7, 4, 2, 2, 2960, 2961, 5, 482, 242, 2, 2961, 2962, 7, 4, 2, 2, 2962, 2963,
	5, 284, 143, 2, 2963, 2964, 7, 20, 2, 2, 2964, 2965, 5, 290, 146, 2, 2965,
	2967, 3, 2, 2, 2, 2966, 2942, 3, 2, 2, 2, 2966, 2944, 3, 2, 2, 2, 2966,
	2950, 3, 2, 2, 2, 2966, 2956, 3, 2, 2, 2, 2967, 335, 3, 2, 2, 2, 2968,
	2981, 5, 606, 304, 2, 2969, 2978, 7, 18, 2, 2, 2970, 2975, 5, 482, 242,
	2, 2971, 2972, 7, 19, 2, 2, 2972, 2974, 5, 482, 242, 2, 2973, 2971, 3,
	2, 2, 2, 2974, 2977, 3, 2, 2, 2, 2975, 2973, 3, 2, 2, 2, 2975, 2976, 3,
	2, 2, 2, 2976, 2979, 3, 2, 2, 2, 2977, 2975, 3, 2, 2, 2, 2978, 2970, 3,
	2, 2, 2, 2978, 2979, 3, 2, 2, 2, 2979, 2980, 3, 2, 2, 2, 2980, 2982, 7,
	20, 2, 2, 2981, 2969, 3, 2, 2, 2, 2981, 2982, 3, 2, 2, 2, 2982, 2983, 3,
	2, 2, 2, 2983, 2984, 7, 4, 2, 2, 2984, 337, 3, 2, 2, 2, 2985, 2998, 5,
	570, 286, 2, 2986, 2995, 7, 18, 2, 2, 2987, 2992, 5, 482, 242, 2, 2988,
	2989, 7, 19, 2, 2, 2989, 2991, 5, 482, 242, 2, 2990, 2988, 3, 2, 2, 2,
	2991, 2994, 3, 2, 2, 2, 2992, 2990, 3, 2, 2, 2, 2992, 2993, 3, 2, 2, 2,
	2993, 2996, 3, 2, 2, 2, 2994, 2992, 3, 2, 2, 2, 2995, 2987, 3, 2, 2, 2,
	2995, 2996, 3, 2, 2, 2, 2996, 2997, 3, 2, 2, 2, 2997, 2999, 7, 20, 2, 2,
	2998, 2986, 3, 2, 2, 2, 2998, 2999, 3, 2, 2, 2, 2999, 3000, 3, 2, 2, 2,
	3000, 3001, 7, 4, 2, 2, 3001, 339, 3, 2, 2, 2, 3002, 3006, 7, 129, 2, 2,
	3003, 3005, 5, 342, 172, 2, 3004, 3003, 3, 2, 2, 2, 3005, 3008, 3, 2, 2,
	2, 3006, 3004, 3, 2, 2, 2, 3006, 3007, 3, 2, 2, 2, 3007, 3009, 3, 2, 2,
	2, 3008, 3006, 3, 2, 2, 2, 3009, 3010, 7, 130, 2, 2, 3010, 341, 3, 2, 2,
	2, 3011, 3016, 5, 58, 30, 2, 3012, 3016, 5, 344, 173, 2, 3013, 3016, 5,
	346, 174, 2, 3014, 3016, 5, 348, 175, 2, 3015, 3011, 3, 2, 2, 2, 3015,
	3012, 3, 2, 2, 2, 3015, 3013, 3, 2, 2, 2, 3015, 3014, 3, 2, 2, 2, 3016,
	343, 3, 2, 2, 2, 3017, 3018, 7, 131, 2, 2, 3018, 3019, 5, 358, 180, 2,
	3019, 3020, 7, 4, 2, 2, 3020, 3026, 3, 2, 2, 2, 3021, 3022, 7, 132, 2,
	2, 3022, 3023, 5, 358, 180, 2, 3023, 3024, 7, 4, 2, 2, 3024, 3026, 3, 2,
	2, 2, 3025, 3017, 3, 2, 2, 2, 3025, 3021, 3, 2, 2, 2, 3026, 345, 3, 2,
	2, 2, 3027, 3028, 7, 133, 2, 2, 3028, 3029, 5, 358, 180, 2, 3029, 3030,
	7, 4, 2, 2, 3030, 3036, 3, 2, 2, 2, 3031, 3032, 7, 134, 2, 2, 3032, 3033,
	5, 358, 180, 2, 3033, 3034, 7, 4, 2, 2, 3034, 3036, 3, 2, 2, 2, 3035, 3027,
	3, 2, 2, 2, 3035, 3031, 3, 2, 2, 2, 3036, 347, 3, 2, 2, 2, 3037, 3038,
	5, 350, 176, 2, 3038, 3039, 7, 4, 2, 2, 3039, 3047, 3, 2, 2, 2, 3040, 3041,
	5, 406, 204, 2, 3041, 3042, 7, 4, 2, 2, 3042, 3047, 3, 2, 2, 2, 3043, 3044,
	5, 416, 209, 2, 3044, 3045, 7, 4, 2, 2, 3045, 3047, 3, 2, 2, 2, 3046, 3037,
	3, 2, 2, 2, 3046, 3040, 3, 2, 2, 2, 3046, 3043, 3, 2, 2, 2, 3047, 349,
	3, 2, 2, 2, 3048, 3049, 5, 352, 177, 2, 3049, 3050, 7, 53, 2, 2, 3050,
	3051, 5, 368, 185, 2, 3051, 3057, 3, 2, 2, 2, 3052, 3053, 5, 354, 178,
	2, 3053, 3054, 7, 53, 2, 2, 3054, 3055, 5, 368, 185, 2, 3055, 3057, 3,
	2, 2, 2, 3056, 3048, 3, 2, 2, 2, 3056, 3052, 3, 2, 2, 2, 3057, 351, 3,
	2, 2, 2, 3058, 3060, 5, 360, 181, 2, 3059, 3061, 5, 418, 210, 2, 3060,
	3059, 3, 2, 2, 2, 3060, 3061, 3, 2, 2, 2, 3061, 3062, 3, 2, 2, 2, 3062,
	3063, 7, 135, 2, 2, 3063, 3064, 5, 362, 182, 2, 3064, 353, 3, 2, 2, 2,
	3065, 3066, 7, 18, 2, 2, 3066, 3068, 5, 356, 179, 2, 3067, 3069, 5, 418,
	210, 2, 3068, 3067, 3, 2, 2, 2, 3068, 3069, 3, 2, 2, 2, 3069, 3070, 3,
	2, 2, 2, 3070, 3071, 7, 136, 2, 2, 3071, 3072, 5, 358, 180, 2, 3072, 3073,
	7, 20, 2, 2, 3073, 355, 3, 2, 2, 2, 3074, 3079, 5, 360, 181, 2, 3075, 3076,
	7, 19, 2, 2, 3076, 3078, 5, 360, 181, 2, 3077, 3075, 3, 2, 2, 2, 3078,
	3081, 3, 2, 2, 2, 3079, 3077, 3, 2, 2, 2, 3079, 3080, 3, 2, 2, 2, 3080,
	357, 3, 2, 2, 2, 3081, 3079, 3, 2, 2, 2, 3082, 3087, 5, 362, 182, 2, 3083,
	3084, 7, 19, 2, 2, 3084, 3086, 5, 362, 182, 2, 3085, 3083, 3, 2, 2, 2,
	3086, 3089, 3, 2, 2, 2, 3087, 3085, 3, 2, 2, 2, 3087, 3088, 3, 2, 2, 2,
	3088, 359, 3, 2, 2, 2, 3089, 3087, 3, 2, 2, 2, 3090, 3102, 5, 364, 183,
	2, 3091, 3092, 5, 364, 183, 2, 3092, 3093, 7, 23, 2, 2, 3093, 3094, 5,
	474, 238, 2, 3094, 3095, 7, 24, 2, 2, 3095, 3102, 3, 2, 2, 2, 3096, 3097,
	5, 364, 183, 2, 3097, 3098, 7, 23, 2, 2, 3098, 3099, 5, 498, 250, 2, 3099,
	3100, 7, 24, 2, 2, 3100, 3102, 3, 2, 2, 2, 3101, 3090, 3, 2, 2, 2, 3101,
	3091, 3, 2, 2, 2, 3101, 3096, 3, 2, 2, 2, 3102, 361, 3, 2, 2, 2, 3103,
	3115, 5, 366, 184, 2, 3104, 3105, 5, 366, 184, 2, 3105, 3106, 7, 23, 2,
	2, 3106, 3107, 5, 474, 238, 2, 3107, 3108, 7, 24, 2, 2, 3108, 3115, 3,
	2, 2, 2, 3109, 3110, 5, 366, 184, 2, 3110, 3111, 7, 23, 2, 2, 3111, 3112,
	5, 498, 250, 2, 3112, 3113, 7, 24, 2, 2, 3113, 3115, 3, 2, 2, 2, 3114,
	3103, 3, 2, 2, 2, 3114, 3104, 3, 2, 2, 2, 3114, 3109, 3, 2, 2, 2, 3115,
	363, 3, 2, 2, 2, 3116, 3119, 5, 576, 289, 2, 3117, 3119, 5, 574, 288, 2,
	3118, 3116, 3, 2, 2, 2, 3118, 3117, 3, 2, 2, 2, 3119, 365, 3, 2, 2, 2,
	3120, 3123, 5, 590, 296, 2, 3121, 3123, 5, 574, 288, 2, 3122, 3120, 3,
	2, 2, 2, 3122, 3121, 3, 2, 2, 2, 3123, 367, 3, 2, 2, 2, 3124, 3130, 5,
	370, 186, 2, 3125, 3126, 7, 18, 2, 2, 3126, 3127, 5, 370, 186, 2, 3127,
	3128, 7, 20, 2, 2, 3128, 3130, 3, 2, 2, 2, 3129, 3124, 3, 2, 2, 2, 3129,
	3125, 3, 2, 2, 2, 3130, 369, 3, 2, 2, 2, 3131, 3179, 5, 372, 187, 2, 3132,
	3133, 5, 374, 188, 2, 3133, 3134, 7, 19, 2, 2, 3134, 3135, 5, 376, 189,
	2, 3135, 3179, 3, 2, 2, 2, 3136, 3137, 5, 374, 188, 2, 3137, 3138, 7, 19,
	2, 2, 3138, 3139, 5, 376, 189, 2, 3139, 3140, 7, 19, 2, 2, 3140, 3141,
	5, 378, 190, 2, 3141, 3179, 3, 2, 2, 2, 3142, 3143, 5, 380, 191, 2, 3143,
	3144, 7, 19, 2, 2, 3144, 3145, 5, 382, 192, 2, 3145, 3146, 7, 19, 2, 2,
	3146, 3147, 5, 384, 193, 2, 3147, 3148, 7, 19, 2, 2, 3148, 3149, 5, 386,
	194, 2, 3149, 3150, 7, 19, 2, 2, 3150, 3151, 5, 388, 195, 2, 3151, 3152,
	7, 19, 2, 2, 3152, 3153, 5, 390, 196, 2, 3153, 3179, 3, 2, 2, 2, 3154,
	3155, 5, 380, 191, 2, 3155, 3156, 7, 19, 2, 2, 3156, 3157, 5, 382, 192,
	2, 3157, 3158, 7, 19, 2, 2, 3158, 3159, 5, 384, 193, 2, 3159, 3160, 7,
	19, 2, 2, 3160, 3161, 5, 386, 194, 2, 3161, 3162, 7, 19, 2, 2, 3162, 3163,
	5, 388, 195, 2, 3163, 3164, 7, 19, 2, 2, 3164, 3165, 5, 390, 196, 2, 3165,
	3166, 7, 19, 2, 2, 3166, 3167, 5, 392, 197, 2, 3167, 3168, 7, 19, 2, 2,
	3168, 3169, 5, 394, 198, 2, 3169, 3170, 7, 19, 2, 2, 3170, 3171, 5, 396,
	199, 2, 3171, 3172, 7, 19, 2, 2, 3172, 3173, 5, 398, 200, 2, 3173, 3174,
	7, 19, 2, 2, 3174, 3175, 5, 400, 201, 2, 3175, 3176, 7, 19, 2, 2, 3176,
	3177, 5, 402, 202, 2, 3177, 3179, 3, 2, 2, 2, 3178, 3131, 3, 2, 2, 2, 3178,
	3132, 3, 2, 2, 2, 3178, 3136, 3, 2, 2, 2, 3178, 3142, 3, 2, 2, 2, 3178,
	3154, 3, 2, 2, 2, 3179, 371, 3, 2, 2, 2, 3180, 3181, 5, 404, 203, 2, 3181,
	373, 3, 2, 2, 2, 3182, 3183, 5, 404, 203, 2, 3183, 375, 3, 2, 2, 2, 3184,
	3185, 5, 404, 203, 2, 3185, 377, 3, 2, 2, 2, 3186, 3187, 5, 404, 203, 2,
	3187, 379, 3, 2, 2, 2, 3188, 3189, 5, 404, 203, 2, 3189, 381, 3, 2, 2,
	2, 3190, 3191, 5, 404, 203, 2, 3191, 383, 3, 2, 2, 2, 3192, 3193, 5, 404,
	203, 2, 3193, 385, 3, 2, 2, 2, 3194, 3195, 5, 404, 203, 2, 3195, 387, 3,
	2, 2, 2, 3196, 3197, 5, 404, 203, 2, 3197, 389, 3, 2, 2, 2, 3198, 3199,
	5, 404, 203, 2, 3199, 391, 3, 2, 2, 2, 3200, 3201, 5, 404, 203, 2, 3201,
	393, 3, 2, 2, 2, 3202, 3203, 5, 404, 203, 2, 3203, 395, 3, 2, 2, 2, 3204,
	3205, 5, 404, 203, 2, 3205, 397, 3, 2, 2, 2, 3206, 3207, 5, 404, 203, 2,
	3207, 399, 3, 2, 2, 2, 3208, 3209, 5, 404, 203, 2, 3209, 401, 3, 2, 2,
	2, 3210, 3211, 5, 404, 203, 2, 3211, 403, 3, 2, 2, 2, 3212, 3213, 5, 476,
	239, 2, 3213, 405, 3, 2, 2, 2, 3214, 3215, 5, 408, 205, 2, 3215, 3216,
	7, 53, 2, 2, 3216, 3217, 5, 368, 185, 2, 3217, 3223, 3, 2, 2, 2, 3218,
	3219, 5, 410, 206, 2, 3219, 3220, 7, 53, 2, 2, 3220, 3221, 5, 368, 185,
	2, 3221, 3223, 3, 2, 2, 2, 3222, 3214, 3, 2, 2, 2, 3222, 3218, 3, 2, 2,
	2, 3223, 407, 3, 2, 2, 2, 3224, 3226, 7, 18, 2, 2, 3225, 3227, 5, 414,
	208, 2, 3226, 3225, 3, 2, 2, 2, 3226, 3227, 3, 2, 2, 2, 3227, 3228, 3,
	2, 2, 2, 3228, 3229, 5, 360, 181, 2, 3229, 3230, 7, 135, 2, 2, 3230, 3232,
	5, 362, 182, 2, 3231, 3233, 5, 418, 210, 2, 3232, 3231, 3, 2, 2, 2, 3232,
	3233, 3, 2, 2, 2, 3233, 3234, 3, 2, 2, 2, 3234, 3235, 7, 67, 2, 2, 3235,
	3236, 5, 412, 207, 2, 3236, 3237, 7, 20, 2, 2, 3237, 409, 3, 2, 2, 2, 3238,
	3240, 7, 18, 2, 2, 3239, 3241, 5, 414, 208, 2, 3240, 3239, 3, 2, 2, 2,
	3240, 3241, 3, 2, 2, 2, 3241, 3242, 3, 2, 2, 2, 3242, 3243, 5, 356, 179,
	2, 3243, 3244, 7, 136, 2, 2, 3244, 3246, 5, 358, 180, 2, 3245, 3247, 5,
	418, 210, 2, 3246, 3245, 3, 2, 2, 2, 3246, 3247, 3, 2, 2, 2, 3247, 3248,
	3, 2, 2, 2, 3248, 3249, 7, 67, 2, 2, 3249, 3250, 5, 412, 207, 2, 3250,
	3251, 7, 20, 2, 2, 3251, 411, 3, 2, 2, 2, 3252, 3253, 5, 482, 242, 2, 3253,
	413, 3, 2, 2, 2, 3254, 3255, 9, 17, 2, 2, 3255, 415, 3, 2, 2, 2, 3256,
	3257, 7, 101, 2, 2, 3257, 3258, 7, 18, 2, 2, 3258, 3259, 5, 492, 247, 2,
	3259, 3260, 7, 20, 2, 2, 3260, 3261, 5, 350, 176, 2, 3261, 3271, 3, 2,
	2, 2, 3262, 3263, 7, 101, 2, 2, 3263, 3264, 7, 18, 2, 2, 3264, 3265, 5,
	492, 247, 2, 3265, 3266, 7, 20, 2, 2, 3266, 3267, 5, 406, 204, 2, 3267,
	3271, 3, 2, 2, 2, 3268, 3269, 7, 137, 2, 2, 3269, 3271, 5, 350, 176, 2,
	3270, 3256, 3, 2, 2, 2, 3270, 3262, 3, 2, 2, 2, 3270, 3268, 3, 2, 2, 2,
	3271, 417, 3, 2, 2, 2, 3272, 3273, 9, 18, 2, 2, 3273, 419, 3, 2, 2, 2,
	3274, 3275, 5, 488, 245, 2, 3275, 421, 3, 2, 2, 2, 3276, 3283, 5, 610,
	306, 2, 3277, 3278, 5, 610, 306, 2, 3278, 3279, 7, 23, 2, 2, 3279, 3280,
	5, 476, 239, 2, 3280, 3281, 7, 24, 2, 2, 3281, 3283, 3, 2, 2, 2, 3282,
	3276, 3, 2, 2, 2, 3282, 3277, 3, 2, 2, 2, 3283, 423, 3, 2, 2, 2, 3284,
	3291, 5, 610, 306, 2, 3285, 3286, 5, 610, 306, 2, 3286, 3287, 7, 23, 2,
	2, 3287, 3288, 5, 476, 239, 2, 3288, 3289, 7, 24, 2, 2, 3289, 3291, 3,
	2, 2, 2, 3290, 3284, 3, 2, 2, 2, 3290, 3285, 3, 2, 2, 2, 3291, 425, 3,
	2, 2, 2, 3292, 3293, 5, 488, 245, 2, 3293, 427, 3, 2, 2, 2, 3294, 3295,
	5, 474, 238, 2, 3295, 429, 3, 2, 2, 2, 3296, 3297, 5, 620, 311, 2, 3297,
	431, 3, 2, 2, 2, 3298, 3299, 5, 476, 239, 2, 3299, 433, 3, 2, 2, 2, 3300,
	3301, 5, 488, 245, 2, 3301, 435, 3, 2, 2, 2, 3302, 3303, 5, 488, 245, 2,
	3303, 437, 3, 2, 2, 2, 3304, 3305, 5, 474, 238, 2, 3305, 439, 3, 2, 2,
	2, 3306, 3307, 5, 482, 242, 2, 3307, 441, 3, 2, 2, 2, 3308, 3309, 7, 21,
	2, 2, 3309, 3314, 5, 482, 242, 2, 3310, 3311, 7, 19, 2, 2, 3311, 3313,
	5, 482, 242, 2, 3312, 3310, 3, 2, 2, 2, 3313, 3316, 3, 2, 2, 2, 3314, 3312,
	3, 2, 2, 2, 3314, 3315, 3, 2, 2, 2, 3315, 3317, 3, 2, 2, 2, 3316, 3314,
	3, 2, 2, 2, 3317, 3318, 7, 22, 2, 2, 3318, 443, 3, 2, 2, 2, 3319, 3320,
	7, 21, 2, 2, 3320, 3325, 5, 474, 238, 2, 3321, 3322, 7, 19, 2, 2, 3322,
	3324, 5, 474, 238, 2, 3323, 3321, 3, 2, 2, 2, 3324, 3327, 3, 2, 2, 2, 3325,
	3323, 3, 2, 2, 2, 3325, 3326, 3, 2, 2, 2, 3326, 3328, 3, 2, 2, 2, 3327,
	3325, 3, 2, 2, 2, 3328, 3329, 7, 22, 2, 2, 3329, 445, 3, 2, 2, 2, 3330,
	3331, 7, 21, 2, 2, 3331, 3332, 5, 474, 238, 2, 3332, 3333, 5, 444, 223,
	2, 3333, 3334, 7, 22, 2, 2, 3334, 447, 3, 2, 2, 2, 3335, 3336, 7, 21, 2,
	2, 3336, 3341, 5, 492, 247, 2, 3337, 3338, 7, 19, 2, 2, 3338, 3340, 5,
	492, 247, 2, 3339, 3337, 3, 2, 2, 2, 3340, 3343, 3, 2, 2, 2, 3341, 3339,
	3, 2, 2, 2, 3341, 3342, 3, 2, 2, 2, 3342, 3344, 3, 2, 2, 2, 3343, 3341,
	3, 2, 2, 2, 3344, 3345, 7, 22, 2, 2, 3345, 449, 3, 2, 2, 2, 3346, 3347,
	7, 21, 2, 2, 3347, 3348, 5, 474, 238, 2, 3348, 3349, 5, 448, 225, 2, 3349,
	3350, 7, 22, 2, 2, 3350, 451, 3, 2, 2, 2, 3351, 3352, 7, 21, 2, 2, 3352,
	3353, 5, 474, 238, 2, 3353, 3354, 5, 442, 222, 2, 3354, 3355, 7, 22, 2,
	2, 3355, 453, 3, 2, 2, 2, 3356, 3357, 7, 21, 2, 2, 3357, 3362, 5, 456,
	229, 2, 3358, 3359, 7, 19, 2, 2, 3359, 3361, 5, 456, 229, 2, 3360, 3358,
	3, 2, 2, 2, 3361, 3364, 3, 2, 2, 2, 3362, 3360, 3, 2, 2, 2, 3362, 3363,
	3, 2, 2, 2, 3363, 3365, 3, 2, 2, 2, 3364, 3362, 3, 2, 2, 2, 3365, 3366,
	7, 22, 2, 2, 3366, 455, 3, 2, 2, 2, 3367, 3405, 5, 566, 284, 2, 3368, 3369,
	5, 566, 284, 2, 3369, 3370, 7, 23, 2, 2, 3370, 3371, 5, 482, 242, 2, 3371,
	3378, 7, 24, 2, 2, 3372, 3373, 7, 23, 2, 2, 3373, 3374, 5, 482, 242, 2,
	3374, 3375, 7, 24, 2, 2, 3375, 3377, 3, 2, 2, 2, 3376, 3372, 3, 2, 2, 2,
	3377, 3380, 3, 2, 2, 2, 3378, 3376, 3, 2, 2, 2, 3378, 3379, 3, 2, 2, 2,
	3379, 3405, 3, 2, 2, 2, 3380, 3378, 3, 2, 2, 2, 3381, 3382, 5, 566, 284,
	2, 3382, 3383, 7, 23, 2, 2, 3383, 3384, 5, 482, 242, 2, 3384, 3391, 7,
	24, 2, 2, 3385, 3386, 7, 23, 2, 2, 3386, 3387, 5, 482, 242, 2, 3387, 3388,
	7, 24, 2, 2, 3388, 3390, 3, 2, 2, 2, 3389, 3385, 3, 2, 2, 2, 3390, 3393,
	3, 2, 2, 2, 3391, 3389, 3, 2, 2, 2, 3391, 3392, 3, 2, 2, 2, 3392, 3394,
	3, 2, 2, 2, 3393, 3391, 3, 2, 2, 2, 3394, 3395, 7, 23, 2, 2, 3395, 3396,
	5, 498, 250, 2, 3396, 3397, 7, 24, 2, 2, 3397, 3405, 3, 2, 2, 2, 3398,
	3399, 5, 566, 284, 2, 3399, 3400, 7, 23, 2, 2, 3400, 3401, 5, 498, 250,
	2, 3401, 3402, 7, 24, 2, 2, 3402, 3405, 3, 2, 2, 2, 3403, 3405, 5, 454,
	228, 2, 3404, 3367, 3, 2, 2, 2, 3404, 3368, 3, 2, 2, 2, 3404, 3381, 3,
	2, 2, 2, 3404, 3398, 3, 2, 2, 2, 3404, 3403, 3, 2, 2, 2, 3405, 457, 3,
	2, 2, 2, 3406, 3407, 7, 21, 2, 2, 3407, 3412, 5, 460, 231, 2, 3408, 3409,
	7, 19, 2, 2, 3409, 3411, 5, 460, 231, 2, 3410, 3408, 3, 2, 2, 2, 3411,
	3414, 3, 2, 2, 2, 3412, 3410, 3, 2, 2, 2, 3412, 3413, 3, 2, 2, 2, 3413,
	3415, 3, 2, 2, 2, 3414, 3412, 3, 2, 2, 2, 3415, 3416, 7, 22, 2, 2, 3416,
	459, 3, 2, 2, 2, 3417, 3455, 5, 568, 285, 2, 3418, 3419, 5, 568, 285, 2,
	3419, 3420, 7, 23, 2, 2, 3420, 3421, 5, 482, 242, 2, 3421, 3428, 7, 24,
	2, 2, 3422, 3423, 7, 23, 2, 2, 3423, 3424, 5, 482, 242, 2, 3424, 3425,
	7, 24, 2, 2, 3425, 3427, 3, 2, 2, 2, 3426, 3422, 3, 2, 2, 2, 3427, 3430,
	3, 2, 2, 2, 3428, 3426, 3, 2, 2, 2, 3428, 3429, 3, 2, 2, 2, 3429, 3455,
	3, 2, 2, 2, 3430, 3428, 3, 2, 2, 2, 3431, 3432, 5, 568, 285, 2, 3432, 3433,
	7, 23, 2, 2, 3433, 3434, 5, 482, 242, 2, 3434, 3441, 7, 24, 2, 2, 3435,
	3436, 7, 23, 2, 2, 3436, 3437, 5, 482, 242, 2, 3437, 3438, 7, 24, 2, 2,
	3438, 3440, 3, 2, 2, 2, 3439, 3435, 3, 2, 2, 2, 3440, 3443, 3, 2, 2, 2,
	3441, 3439, 3, 2, 2, 2, 3441, 3442, 3, 2, 2, 2, 3442, 3444, 3, 2, 2, 2,
	3443, 3441, 3, 2, 2, 2, 3444, 3445, 7, 23, 2, 2, 3445, 3446, 5, 498, 250,
	2, 3446, 3447, 7, 24, 2, 2, 3447, 3455, 3, 2, 2, 2, 3448, 3449, 5, 568,
	285, 2, 3449, 3450, 7, 23, 2, 2, 3450, 3451, 5, 498, 250, 2, 3451, 3452,
	7, 24, 2, 2, 3452, 3455, 3, 2, 2, 2, 3453, 3455, 5, 458, 230, 2, 3454,
	3417, 3, 2, 2, 2, 3454, 3418, 3, 2, 2, 2, 3454, 3431, 3, 2, 2, 2, 3454,
	3448, 3, 2, 2, 2, 3454, 3453, 3, 2, 2, 2, 3455, 461, 3, 2, 2, 2, 3456,
	3460, 5, 548, 275, 2, 3457, 3459, 5, 526, 264, 2, 3458, 3457, 3, 2, 2,
	2, 3459, 3462, 3, 2, 2, 2, 3460, 3458, 3, 2, 2, 2, 3460, 3461, 3, 2, 2,
	2, 3461, 3463, 3, 2, 2, 2, 3462, 3460, 3, 2, 2, 2, 3463, 3472, 7, 18, 2,
	2, 3464, 3469, 5, 474, 238, 2, 3465, 3466, 7, 19, 2, 2, 3466, 3468, 5,
	474, 238, 2, 3467, 3465, 3, 2, 2, 2, 3468, 3471, 3, 2, 2, 2, 3469, 3467,
	3, 2, 2, 2, 3469, 3470, 3, 2, 2, 2, 3470, 3473, 3, 2, 2, 2, 3471, 3469,
	3, 2, 2, 2, 3472, 3464, 3, 2, 2, 2, 3472, 3473, 3, 2, 2, 2, 3473, 3474,
	3, 2, 2, 2, 3474, 3475, 7, 20, 2, 2, 3475, 463, 3, 2, 2, 2, 3476, 3480,
	5, 562, 282, 2, 3477, 3479, 5, 526, 264, 2, 3478, 3477, 3, 2, 2, 2, 3479,
	3482, 3, 2, 2, 2, 3480, 3478, 3, 2, 2, 2, 3480, 3481, 3, 2, 2, 2, 3481,
	3483, 3, 2, 2, 2, 3482, 3480, 3, 2, 2, 2, 3483, 3492, 7, 18, 2, 2, 3484,
	3489, 5, 482, 242, 2, 3485, 3486, 7, 19, 2, 2, 3486, 3488, 5, 482, 242,
	2, 3487, 3485, 3, 2, 2, 2, 3488, 3491, 3, 2, 2, 2, 3489, 3487, 3, 2, 2,
	2, 3489, 3490, 3, 2, 2, 2, 3490, 3493, 3, 2, 2, 2, 3491, 3489, 3, 2, 2,
	2, 3492, 3484, 3, 2, 2, 2, 3492, 3493, 3, 2, 2, 2, 3493, 3494, 3, 2, 2,
	2, 3494, 3495, 7, 20, 2, 2, 3495, 465, 3, 2, 2, 2, 3496, 3505, 5, 604,
	303, 2, 3497, 3502, 5, 482, 242, 2, 3498, 3499, 7, 19, 2, 2, 3499, 3501,
	5, 482, 242, 2, 3500, 3498, 3, 2, 2, 2, 3501, 3504, 3, 2, 2, 2, 3502, 3500,
	3, 2, 2, 2, 3502, 3503, 3, 2, 2, 2, 3503, 3506, 3, 2, 2, 2, 3504, 3502,
	3, 2, 2, 2, 3505, 3497, 3, 2, 2, 2, 3505, 3506, 3, 2, 2, 2, 3506, 467,
	3, 2, 2, 2, 3507, 3511, 5, 554, 278, 2, 3508, 3510, 5, 526, 264, 2, 3509,
	3508, 3, 2, 2, 2, 3510, 3513, 3, 2, 2, 2, 3511, 3509, 3, 2, 2, 2, 3511,
	3512, 3, 2, 2, 2, 3512, 3514, 3, 2, 2, 2, 3513, 3511, 3, 2, 2, 2, 3514,
	3523, 7, 18, 2, 2, 3515, 3520, 5, 474, 238, 2, 3516, 3517, 7, 19, 2, 2,
	3517, 3519, 5, 474, 238, 2, 3518, 3516, 3, 2, 2, 2, 3519, 3522, 3, 2, 2,
	2, 3520, 3518, 3, 2, 2, 2, 3520, 3521, 3, 2, 2, 2, 3521, 3524, 3, 2, 2,
	2, 3522, 3520, 3, 2, 2, 2, 3523, 3515, 3, 2, 2, 2, 3523, 3524, 3, 2, 2,
	2, 3524, 3525, 3, 2, 2, 2, 3525, 3526, 7, 20, 2, 2, 3526, 469, 3, 2, 2,
	2, 3527, 3528, 5, 482, 242, 2, 3528, 471, 3, 2, 2, 2, 3529, 3530, 5, 474,
	238, 2, 3530, 473, 3, 2, 2, 2, 3531, 3532, 5, 482, 242, 2, 3532, 475, 3,
	2, 2, 2, 3533, 3541, 5, 474, 238, 2, 3534, 3535, 5, 474, 238, 2, 3535,
	3536, 7, 67, 2, 2, 3536, 3537, 5, 474, 238, 2, 3537, 3538, 7, 67, 2, 2,
	3538, 3539, 5, 474, 238, 2, 3539, 3541, 3, 2, 2, 2, 3540, 3533, 3, 2, 2,
	2, 3540, 3534, 3, 2, 2, 2, 3541, 477, 3, 2, 2, 2, 3542, 3556, 5, 474, 238,
	2, 3543, 3544, 5, 496, 249, 2, 3544, 3545, 7, 67, 2, 2, 3545, 3546, 5,
	486, 244, 2, 3546, 3556, 3, 2, 2, 2, 3547, 3548, 5, 472, 237, 2, 3548,
	3549, 7, 140, 2, 2, 3549, 3550, 5, 500, 251, 2, 3550, 3556, 3, 2, 2, 2,
	3551, 3552, 5, 472, 237, 2, 3552, 3553, 7, 141, 2, 2, 3553, 3554, 5, 500,
	251, 2, 3554, 3556, 3, 2, 2, 2, 3555, 3542, 3, 2, 2, 2, 3555, 3543, 3,
	2, 2, 2, 3555, 3547, 3, 2, 2, 2, 3555, 3551, 3, 2, 2, 2, 3556, 479, 3,
	2, 2, 2, 3557, 3558, 5, 474, 238, 2, 3558, 481, 3, 2, 2, 2, 3559, 3582,
	5, 484, 243, 2, 3560, 3564, 5, 514, 258, 2, 3561, 3563, 5, 526, 264, 2,
	3562, 3561, 3, 2, 2, 2, 3563, 3566, 3, 2, 2, 2, 3564, 3562, 3, 2, 2, 2,
	3564, 3565, 3, 2, 2, 2, 3565, 3567, 3, 2, 2, 2, 3566, 3564, 3, 2, 2, 2,
	3567, 3568, 5, 484, 243, 2, 3568, 3581, 3, 2, 2, 2, 3569, 3573, 7, 142,
	2, 2, 3570, 3572, 5, 526, 264, 2, 3571, 3570, 3, 2, 2, 2, 3572, 3575, 3,
	2, 2, 2, 3573, 3571, 3, 2, 2, 2, 3573, 3574, 3, 2, 2, 2, 3574, 3576, 3,
	2, 2, 2, 3575, 3573, 3, 2, 2, 2, 3576, 3577, 5, 482, 242, 2, 3577, 3578,
	7, 67, 2, 2, 3578, 3579, 5, 484, 243, 2, 3579, 3581, 3, 2, 2, 2, 3580,
	3560, 3, 2, 2, 2, 3580, 3569, 3, 2, 2, 2, 3581, 3584, 3, 2, 2, 2, 3582,
	3580, 3, 2, 2, 2, 3582, 3583, 3, 2, 2, 2, 3583, 483, 3, 2, 2, 2, 3584,
	3582, 3, 2, 2, 2, 3585, 3589, 5, 512, 257, 2, 3586, 3588, 5, 526, 264,
	2, 3587, 3586, 3, 2, 2, 2, 3588, 3591, 3, 2, 2, 2, 3589, 3587, 3, 2, 2,
	2, 3589, 3590, 3, 2, 2, 2, 3590, 3592, 3, 2, 2, 2, 3591, 3589, 3, 2, 2,
	2, 3592, 3593, 5, 506, 254, 2, 3593, 3594, 8, 243, 1, 2, 3594, 3600, 3,
	2, 2, 2, 3595, 3596, 5, 506, 254, 2, 3596, 3597, 8, 243, 1, 2, 3597, 3600,
	3, 2, 2, 2, 3598, 3600, 7, 175, 2, 2, 3599, 3585, 3, 2, 2, 2, 3599, 3595,
	3, 2, 2, 2, 3599, 3598, 3, 2, 2, 2, 3600, 485, 3, 2, 2, 2, 3601, 3602,
	5, 474, 238, 2, 3602, 487, 3, 2, 2, 2, 3603, 3609, 5, 482, 242, 2, 3604,
	3605, 7, 67, 2, 2, 3605, 3606, 5, 482, 242, 2, 3606, 3607, 7, 67, 2, 2,
	3607, 3608, 5, 482, 242, 2, 3608, 3610, 3, 2, 2, 2, 3609, 3604, 3, 2, 2,
	2, 3609, 3610, 3, 2, 2, 2, 3610, 489, 3, 2, 2, 2, 3611, 3612, 5, 492, 247,
	2, 3612, 3616, 7, 142, 2, 2, 3613, 3615, 5, 526, 264, 2, 3614, 3613, 3,
	2, 2, 2, 3615, 3618, 3, 2, 2, 2, 3616, 3614, 3, 2, 2, 2, 3616, 3617, 3,
	2, 2, 2, 3617, 3619, 3, 2, 2, 2, 3618, 3616, 3, 2, 2, 2, 3619, 3620, 5,
	492, 247, 2, 3620, 3621, 7, 67, 2, 2, 3621, 3622, 5, 492, 247, 2, 3622,
	491, 3, 2, 2, 2, 3623, 3634, 5, 504, 253, 2, 3624, 3628, 5, 516, 259, 2,
	3625, 3627, 5, 526, 264, 2, 3626, 3625, 3, 2, 2, 2, 3627, 3630, 3, 2, 2,
	2, 3628, 3626, 3, 2, 2, 2, 3628, 3629, 3, 2, 2, 2, 3629, 3631, 3, 2, 2,
	2, 3630, 3628, 3, 2, 2, 2, 3631, 3632, 5, 504, 253, 2, 3632, 3634, 3, 2,
	2, 2, 3633, 3623, 3, 2, 2, 2, 3633, 3624, 3, 2, 2, 2, 3634, 3657, 3, 2,
	2, 2, 3635, 3639, 5, 518, 260, 2, 3636, 3638, 5, 526, 264, 2, 3637, 3636,
	3, 2, 2, 2, 3638, 3641, 3, 2, 2, 2, 3639, 3637, 3, 2, 2, 2, 3639, 3640,
	3, 2, 2, 2, 3640, 3642, 3, 2, 2, 2, 3641, 3639, 3, 2, 2, 2, 3642, 3643,
	5, 492, 247, 2, 3643, 3656, 3, 2, 2, 2, 3644, 3648, 7, 142, 2, 2, 3645,
	3647, 5, 526, 264, 2, 3646, 3645, 3, 2, 2, 2, 3647, 3650, 3, 2, 2, 2, 3648,
	3646, 3, 2, 2, 2, 3648, 3649, 3, 2, 2, 2, 3649, 3651, 3, 2, 2, 2, 3650,
	3648, 3, 2, 2, 2, 3651, 3652, 5, 492, 247, 2, 3652, 3653, 7, 67, 2, 2,
	3653, 3654, 5, 492, 247, 2, 3654, 3656, 3, 2, 2, 2, 3655, 3635, 3, 2, 2,
	2, 3655, 3644, 3, 2, 2, 2, 3656, 3659, 3, 2, 2, 2, 3657, 3655, 3, 2, 2,
	2, 3657, 3658, 3, 2, 2, 2, 3658, 493, 3, 2, 2, 2, 3659, 3657, 3, 2, 2,
	2, 3660, 3666, 5, 492, 247, 2, 3661, 3662, 7, 67, 2, 2, 3662, 3663, 5,
	492, 247, 2, 3663, 3664, 7, 67, 2, 2, 3664, 3665, 5, 492, 247, 2, 3665,
	3667, 3, 2, 2, 2, 3666, 3661, 3, 2, 2, 2, 3666, 3667, 3, 2, 2, 2, 3667,
	495, 3, 2, 2, 2, 3668, 3669, 5, 474, 238, 2, 3669, 497, 3, 2, 2, 2, 3670,
	3684, 5, 482, 242, 2, 3671, 3672, 5, 496, 249, 2, 3672, 3673, 7, 67, 2,
	2, 3673, 3674, 5, 486, 244, 2, 3674, 3684, 3, 2, 2, 2, 3675, 3676, 5, 470,
	236, 2, 3676, 3677, 7, 140, 2, 2, 3677, 3678, 5, 500, 251, 2, 3678, 3684,
	3, 2, 2, 2, 3679, 3680, 5, 470, 236, 2, 3680, 3681, 7, 141, 2, 2, 3681,
	3682, 5, 500, 251, 2, 3682, 3684, 3, 2, 2, 2, 3683, 3670, 3, 2, 2, 2, 3683,
	3671, 3, 2, 2, 2, 3683, 3675, 3, 2, 2, 2, 3683, 3679, 3, 2, 2, 2, 3684,
	499, 3, 2, 2, 2, 3685, 3686, 5, 474, 238, 2, 3686, 501, 3, 2, 2, 2, 3687,
	3699, 5, 444, 223, 2, 3688, 3699, 5, 462, 232, 2, 3689, 3690, 7, 18, 2,
	2, 3690, 3691, 5, 476, 239, 2, 3691, 3692, 7, 20, 2, 2, 3692, 3699, 3,
	2, 2, 2, 3693, 3699, 5, 446, 224, 2, 3694, 3699, 5, 556, 279, 2, 3695,
	3699, 5, 520, 261, 2, 3696, 3699, 5, 592, 297, 2, 3697, 3699, 5, 602, 302,
	2, 3698, 3687, 3, 2, 2, 2, 3698, 3688, 3, 2, 2, 2, 3698, 3689, 3, 2, 2,
	2, 3698, 3693, 3, 2, 2, 2, 3698, 3694, 3, 2, 2, 2, 3698, 3695, 3, 2, 2,
	2, 3698, 3696, 3, 2, 2, 2, 3698, 3697, 3, 2, 2, 2, 3699, 503, 3, 2, 2,
	2, 3700, 3712, 5, 520, 261, 2, 3701, 3712, 5, 572, 287, 2, 3702, 3712,
	5, 448, 225, 2, 3703, 3712, 5, 450, 226, 2, 3704, 3712, 5, 464, 233, 2,
	3705, 3712, 5, 466, 234, 2, 3706, 3712, 5, 462, 232, 2, 3707, 3708, 7,
	18, 2, 2, 3708, 3709, 5, 494, 248, 2, 3709, 3710, 7, 20, 2, 2, 3710, 3712,
	3, 2, 2, 2, 3711, 3700, 3, 2, 2, 2, 3711, 3701, 3, 2, 2, 2, 3711, 3702,
	3, 2, 2, 2, 3711, 3703, 3, 2, 2, 2, 3711, 3704, 3, 2, 2, 2, 3711, 3705,
	3, 2, 2, 2, 3711, 3706, 3, 2, 2, 2, 3711, 3707, 3, 2, 2, 2, 3712, 505,
	3, 2, 2, 2, 3713, 3714, 5, 520, 261, 2, 3714, 3715, 8, 254, 1, 2, 3715,
	3771, 3, 2, 2, 2, 3716, 3717, 5, 564, 283, 2, 3717, 3718, 8, 254, 1, 2,
	3718, 3771, 3, 2, 2, 2, 3719, 3724, 5, 564, 283, 2, 3720, 3721, 7, 23,
	2, 2, 3721, 3722, 5, 482, 242, 2, 3722, 3723, 7, 24, 2, 2, 3723, 3725,
	3, 2, 2, 2, 3724, 3720, 3, 2, 2, 2, 3725, 3726, 3, 2, 2, 2, 3726, 3724,
	3, 2, 2, 2, 3726, 3727, 3, 2, 2, 2, 3727, 3728, 3, 2, 2, 2, 3728, 3729,
	8, 254, 1, 2, 3729, 3771, 3, 2, 2, 2, 3730, 3735, 5, 564, 283, 2, 3731,
	3732, 7, 23, 2, 2, 3732, 3733, 5, 482, 242, 2, 3733, 3734, 7, 24, 2, 2,
	3734, 3736, 3, 2, 2, 2, 3735, 3731, 3, 2, 2, 2, 3736, 3737, 3, 2, 2, 2,
	3737, 3735, 3, 2, 2, 2, 3737, 3738, 3, 2, 2, 2, 3738, 3739, 3, 2, 2, 2,
	3739, 3740, 7, 23, 2, 2, 3740, 3741, 5, 498, 250, 2, 3741, 3742, 7, 24,
	2, 2, 3742, 3743, 8, 254, 1, 2, 3743, 3771, 3, 2, 2, 2, 3744, 3745, 5,
	564, 283, 2, 3745, 3746, 7, 23, 2, 2, 3746, 3747, 5, 498, 250, 2, 3747,
	3748, 7, 24, 2, 2, 3748, 3749, 8, 254, 1, 2, 3749, 3771, 3, 2, 2, 2, 3750,
	3751, 5, 442, 222, 2, 3751, 3752, 8, 254, 1, 2, 3752, 3771, 3, 2, 2, 2,
	3753, 3754, 5, 452, 227, 2, 3754, 3755, 8, 254, 1, 2, 3755, 3771, 3, 2,
	2, 2, 3756, 3757, 5, 464, 233, 2, 3757, 3758, 8, 254, 1, 2, 3758, 3771,
	3, 2, 2, 2, 3759, 3760, 5, 466, 234, 2, 3760, 3761, 8, 254, 1, 2, 3761,
	3771, 3, 2, 2, 2, 3762, 3763, 5, 462, 232, 2, 3763, 3764, 8, 254, 1, 2,
	3764, 3771, 3, 2, 2, 2, 3765, 3766, 7, 18, 2, 2, 3766, 3767, 5, 488, 245,
	2, 3767, 3768, 7, 20, 2, 2, 3768, 3769, 8, 254, 1, 2, 3769, 3771, 3, 2,
	2, 2, 3770, 3713, 3, 2, 2, 2, 3770, 3716, 3, 2, 2, 2, 3770, 3719, 3, 2,
	2, 2, 3770, 3730, 3, 2, 2, 2, 3770, 3744, 3, 2, 2, 2, 3770, 3750, 3, 2,
	2, 2, 3770, 3753, 3, 2, 2, 2, 3770, 3756, 3, 2, 2, 2, 3770, 3759, 3, 2,
	2, 2, 3770, 3762, 3, 2, 2, 2, 3770, 3765, 3, 2, 2, 2, 3771, 507, 3, 2,
	2, 2, 3772, 3810, 5, 566, 284, 2, 3773, 3774, 5, 566, 284, 2, 3774, 3775,
	7, 23, 2, 2, 3775, 3776, 5, 474, 238, 2, 3776, 3783, 7, 24, 2, 2, 3777,
	3778, 7, 23, 2, 2, 3778, 3779, 5, 474, 238, 2, 3779, 3780, 7, 24, 2, 2,
	3780, 3782, 3, 2, 2, 2, 3781, 3777, 3, 2, 2, 2, 3782, 3785, 3, 2, 2, 2,
	3783, 3781, 3, 2, 2, 2, 3783, 3784, 3, 2, 2, 2, 3784, 3810, 3, 2, 2, 2,
	3785, 3783, 3, 2, 2, 2, 3786, 3787, 5, 566, 284, 2, 3787, 3788, 7, 23,
	2, 2, 3788, 3789, 5, 474, 238, 2, 3789, 3796, 7, 24, 2, 2, 3790, 3791,
	7, 23, 2, 2, 3791, 3792, 5, 474, 238, 2, 3792, 3793, 7, 24, 2, 2, 3793,
	3795, 3, 2, 2, 2, 3794, 3790, 3, 2, 2, 2, 3795, 3798, 3, 2, 2, 2, 3796,
	3794, 3, 2, 2, 2, 3796, 3797, 3, 2, 2, 2, 3797, 3799, 3, 2, 2, 2, 3798,
	3796, 3, 2, 2, 2, 3799, 3800, 7, 23, 2, 2, 3800, 3801, 5, 478, 240, 2,
	3801, 3802, 7, 24, 2, 2, 3802, 3810, 3, 2, 2, 2, 3803, 3804, 5, 566, 284,
	2, 3804, 3805, 7, 23, 2, 2, 3805, 3806, 5, 478, 240, 2, 3806, 3807, 7,
	24, 2, 2, 3807, 3810, 3, 2, 2, 2, 3808, 3810, 5, 454, 228, 2, 3809, 3772,
	3, 2, 2, 2, 3809, 3773, 3, 2, 2, 2, 3809, 3786, 3, 2, 2, 2, 3809, 3803,
	3, 2, 2, 2, 3809, 3808, 3, 2, 2, 2, 3810, 509, 3, 2, 2, 2, 3811, 3849,
	5, 568, 285, 2, 3812, 3813, 5, 568, 285, 2, 3813, 3814, 7, 23, 2, 2, 3814,
	3815, 5, 482, 242, 2, 3815, 3822, 7, 24, 2, 2, 3816, 3817, 7, 23, 2, 2,
	3817, 3818, 5, 482, 242, 2, 3818, 3819, 7, 24, 2, 2, 3819, 3821, 3, 2,
	2, 2, 3820, 3816, 3, 2, 2, 2, 3821, 3824, 3, 2, 2, 2, 3822, 3820, 3, 2,
	2, 2, 3822, 3823, 3, 2, 2, 2, 3823, 3849, 3, 2, 2, 2, 3824, 3822, 3, 2,
	2, 2, 3825, 3826, 5, 568, 285, 2, 3826, 3827, 7, 23, 2, 2, 3827, 3828,
	5, 482, 242, 2, 3828, 3835, 7, 24, 2, 2, 3829, 3830, 7, 23, 2, 2, 3830,
	3831, 5, 482, 242, 2, 3831, 3832, 7, 24, 2, 2, 3832, 3834, 3, 2, 2, 2,
	3833, 3829, 3, 2, 2, 2, 3834, 3837, 3, 2, 2, 2, 3835, 3833, 3, 2, 2, 2,
	3835, 3836, 3, 2, 2, 2, 3836, 3838, 3, 2, 2, 2, 3837, 3835, 3, 2, 2, 2,
	3838, 3839, 7, 23, 2, 2, 3839, 3840, 5, 498, 250, 2, 3840, 3841, 7, 24,
	2, 2, 3841, 3849, 3, 2, 2, 2, 3842, 3843, 5, 568, 285, 2, 3843, 3844, 7,
	23, 2, 2, 3844, 3845, 5, 498, 250, 2, 3845, 3846, 7, 24, 2, 2, 3846, 3849,
	3, 2, 2, 2, 3847, 3849, 5, 458, 230, 2, 3848, 3811, 3, 2, 2, 2, 3848, 3812,
	3, 2, 2, 2, 3848, 3825, 3, 2, 2, 2, 3848, 3842, 3, 2, 2, 2, 3848, 3847,
	3, 2, 2, 2, 3849, 511, 3, 2, 2, 2, 3850, 3851, 9, 19, 2, 2, 3851, 513,
	3, 2, 2, 2, 3852, 3853, 9, 20, 2, 2, 3853, 515, 3, 2, 2, 2, 3854, 3855,
	9, 21, 2, 2, 3855, 517, 3, 2, 2, 2, 3856, 3857, 9, 22, 2, 2, 3857, 519,
	3, 2, 2, 2, 3858, 3859, 9, 23, 2, 2, 3859, 521, 3, 2, 2, 2, 3860, 3861,
	7, 168, 2, 2, 3861, 3862, 7, 181, 2, 2, 3862, 3863, 7, 152, 2, 2, 3863,
	3864, 7, 181, 2, 2, 3864, 523, 3, 2, 2, 2, 3865, 3866, 7, 169, 2, 2, 3866,
	3867, 5, 540, 271, 2, 3867, 3868, 5, 474, 238, 2, 3868, 525, 3, 2, 2, 2,
	3869, 3870, 7, 18, 2, 2, 3870, 3871, 7, 120, 2, 2, 3871, 3876, 5, 528,
	265, 2, 3872, 3873, 7, 19, 2, 2, 3873, 3875, 5, 528, 265, 2, 3874, 3872,
	3, 2, 2, 2, 3875, 3878, 3, 2, 2, 2, 3876, 3874, 3, 2, 2, 2, 3876, 3877,
	3, 2, 2, 2, 3877, 3879, 3, 2, 2, 2, 3878, 3876, 3, 2, 2, 2, 3879, 3880,
	7, 120, 2, 2, 3880, 3881, 7, 20, 2, 2, 3881, 527, 3, 2, 2, 2, 3882, 3883,
	5, 530, 266, 2, 3883, 3884, 7, 53, 2, 2, 3884, 3885, 5, 474, 238, 2, 3885,
	3888, 3, 2, 2, 2, 3886, 3888, 5, 530, 266, 2, 3887, 3882, 3, 2, 2, 2, 3887,
	3886, 3, 2, 2, 2, 3888, 529, 3, 2, 2, 2, 3889, 3890, 5, 572, 287, 2, 3890,
	531, 3, 2, 2, 2, 3891, 3894, 5, 598, 300, 2, 3892, 3894, 5, 542, 272, 2,
	3893, 3891, 3, 2, 2, 2, 3893, 3892, 3, 2, 2, 2, 3894, 533, 3, 2, 2, 2,
	3895, 3896, 5, 572, 287, 2, 3896, 535, 3, 2, 2, 2, 3897, 3898, 5, 572,
	287, 2, 3898, 537, 3, 2, 2, 2, 3899, 3900, 5, 572, 287, 2, 3900, 539, 3,
	2, 2, 2, 3901, 3902, 5, 572, 287, 2, 3902, 541, 3, 2, 2, 2, 3903, 3905,
	7, 178, 2, 2, 3904, 3906, 5, 140, 71, 2, 3905, 3904, 3, 2, 2, 2, 3905,
	3906, 3, 2, 2, 2, 3906, 543, 3, 2, 2, 2, 3907, 3914, 5, 624, 313, 2, 3908,
	3909, 7, 7, 2, 2, 3909, 3913, 5, 622, 312, 2, 3910, 3911, 7, 7, 2, 2, 3911,
	3913, 5, 624, 313, 2, 3912, 3908, 3, 2, 2, 2, 3912, 3910, 3, 2, 2, 2, 3913,
	3916, 3, 2, 2, 2, 3914, 3912, 3, 2, 2, 2, 3914, 3915, 3, 2, 2, 2, 3915,
	545, 3, 2, 2, 2, 3916, 3914, 3, 2, 2, 2, 3917, 3918, 5, 572, 287, 2, 3918,
	547, 3, 2, 2, 2, 3919, 3920, 5, 572, 287, 2, 3920, 549, 3, 2, 2, 2, 3921,
	3922, 5, 532, 267, 2, 3922, 551, 3, 2, 2, 2, 3923, 3924, 5, 572, 287, 2,
	3924, 553, 3, 2, 2, 2, 3925, 3926, 5, 572, 287, 2, 3926, 555, 3, 2, 2,
	2, 3927, 3928, 5, 572, 287, 2, 3928, 557, 3, 2, 2, 2, 3929, 3930, 5, 564,
	283, 2, 3930, 559, 3, 2, 2, 2, 3931, 3932, 5, 564, 283, 2, 3932, 561, 3,
	2, 2, 2, 3933, 3934, 5, 564, 283, 2, 3934, 563, 3, 2, 2, 2, 3935, 3938,
	5, 600, 301, 2, 3936, 3938, 5, 544, 273, 2, 3937, 3935, 3, 2, 2, 2, 3937,
	3936, 3, 2, 2, 2, 3938, 565, 3, 2, 2, 2, 3939, 3940, 5, 564, 283, 2, 3940,
	567, 3, 2, 2, 2, 3941, 3942, 5, 564, 283, 2, 3942, 569, 3, 2, 2, 2, 3943,
	3944, 5, 564, 283, 2, 3944, 571, 3, 2, 2, 2, 3945, 3946, 9, 24, 2, 2, 3946,
	573, 3, 2, 2, 2, 3947, 3948, 5, 572, 287, 2, 3948, 575, 3, 2, 2, 2, 3949,
	3950, 5, 572, 287, 2, 3950, 577, 3, 2, 2, 2, 3951, 3952, 5, 572, 287, 2,
	3952, 579, 3, 2, 2, 2, 3953, 3954, 5, 572, 287, 2, 3954, 581, 3, 2, 2,
	2, 3955, 3956, 5, 572, 287, 2, 3956, 583, 3, 2, 2, 2, 3957, 3958, 5, 572,
	287, 2, 3958, 585, 3, 2, 2, 2, 3959, 3960, 5, 532, 267, 2, 3960, 587, 3,
	2, 2, 2, 3961, 3962, 5, 572, 287, 2, 3962, 589, 3, 2, 2, 2, 3963, 3964,
	5, 572, 287, 2, 3964, 591, 3, 2, 2, 2, 3965, 3966, 5, 572, 287, 2, 3966,
	593, 3, 2, 2, 2, 3967, 3968, 5, 572, 287, 2, 3968, 595, 3, 2, 2, 2, 3969,
	3970, 5, 572, 287, 2, 3970, 597, 3, 2, 2, 2, 3971, 3973, 7, 179, 2, 2,
	3972, 3974, 5, 140, 71, 2, 3973, 3972, 3, 2, 2, 2, 3973, 3974, 3, 2, 2,
	2, 3974, 599, 3, 2, 2, 2, 3975, 3978, 5, 622, 312, 2, 3976, 3977, 7, 7,
	2, 2, 3977, 3979, 7, 178, 2, 2, 3978, 3976, 3, 2, 2, 2, 3978, 3979, 3,
	2, 2, 2, 3979, 601, 3, 2, 2, 2, 3980, 3981, 5, 572, 287, 2, 3981, 603,
	3, 2, 2, 2, 3982, 3983, 7, 180, 2, 2, 3983, 605, 3, 2, 2, 2, 3984, 3985,
	7, 180, 2, 2, 3985, 607, 3, 2, 2, 2, 3986, 3987, 5, 572, 287, 2, 3987,
	609, 3, 2, 2, 2, 3988, 3989, 5, 572, 287, 2, 3989, 611, 3, 2, 2, 2, 3990,
	3991, 7, 179, 2, 2, 3991, 613, 3, 2, 2, 2, 3992, 3993, 5, 572, 287, 2,
	3993, 615, 3, 2, 2, 2, 3994, 3995, 5, 572, 287, 2, 3995, 617, 3, 2, 2,
	2, 3996, 3997, 5, 532, 267, 2, 3997, 619, 3, 2, 2, 2, 3998, 3999, 5, 572,
	287, 2, 3999, 621, 3, 2, 2, 2, 4000, 4004, 7, 179, 2, 2, 4001, 4002, 7,
	23, 2, 2, 4002, 4003, 7, 171, 2, 2, 4003, 4005, 7, 24, 2, 2, 4004, 4001,
	3, 2, 2, 2, 4004, 4005, 3, 2, 2, 2, 4005, 4015, 3, 2, 2, 2, 4006, 4007,
	7, 7, 2, 2, 4007, 4011, 7, 179, 2, 2, 4008, 4009, 7, 23, 2, 2, 4009, 4010,
	7, 171, 2, 2, 4010, 4012, 7, 24, 2, 2, 4011, 4008, 3, 2, 2, 2, 4011, 4012,
	3, 2, 2, 2, 4012, 4014, 3, 2, 2, 2, 4013, 4006, 3, 2, 2, 2, 4014, 4017,
	3, 2, 2, 2, 4015, 4013, 3, 2, 2, 2, 4015, 4016, 3, 2, 2, 2, 4016, 623,
	3, 2, 2, 2, 4017, 4015, 3, 2, 2, 2, 4018, 4022, 7, 178, 2, 2, 4019, 4020,
	7, 23, 2, 2, 4020, 4021, 7, 171, 2, 2, 4021, 4023, 7, 24, 2, 2, 4022, 4019,
	3, 2, 2, 2, 4022, 4023, 3, 2, 2, 2, 4023, 4033, 3, 2, 2, 2, 4024, 4025,
	7, 7, 2, 2, 4025, 4029, 7, 178, 2, 2, 4026, 4027, 7, 23, 2, 2, 4027, 4028,
	7, 171, 2, 2, 4028, 4030, 7, 24, 2, 2, 4029, 4026, 3, 2, 2, 2, 4029, 4030,
	3, 2, 2, 2, 4030, 4032, 3, 2, 2, 2, 4031, 4024, 3, 2, 2, 2, 4032, 4035,
	3, 2, 2, 2, 4033, 4031, 3, 2, 2, 2, 4033, 4034, 3, 2, 2, 2, 4034, 625,
	3, 2, 2, 2, 4035, 4033, 3, 2, 2, 2, 422, 633, 642, 647, 667, 679, 686,
	693, 701, 705, 708, 713, 719, 729, 735, 738, 744, 752, 758, 761, 767, 772,
	783, 794, 805, 812, 815, 821, 825, 834, 839, 852, 857, 864, 871, 875, 884,
	891, 898, 905, 912, 916, 921, 928, 935, 942, 949, 956, 963, 967, 972, 979,
	986, 993, 1000, 1007, 1011, 1023, 1031, 1034, 1059, 1066, 1069, 1084, 1088,
	1095, 1098, 1101, 1107, 1110, 1113, 1119, 1122, 1125, 1130, 1133, 1136,
	1142, 1145, 1150, 1157, 1185, 1188, 1195, 1198, 1205, 1208, 1211, 1218,
	1221, 1224, 1231, 1234, 1237, 1244, 1247, 1250, 1254, 1261, 1264, 1267,
	1271, 1278, 1281, 1284, 1288, 1295, 1298, 1302, 1307, 1316, 1323, 1326,
	1331, 1338, 1341, 1379, 1394, 1405, 1407, 1411, 1420, 1424, 1430, 1437,
	1440, 1448, 1451, 1455, 1463, 1466, 1474, 1477, 1481, 1489, 1497, 1505,
	1513, 1521, 1529, 1537, 1543, 1549, 1553, 1569, 1577, 1591, 1596, 1618,
	1621, 1624, 1631, 1635, 1641, 1644, 1647, 1657, 1661, 1665, 1671, 1678,
	1684, 1694, 1698, 1705, 1713, 1718, 1725, 1731, 1737, 1743, 1750, 1756,
	1763, 1766, 1769, 1772, 1776, 1779, 1781, 1791, 1798, 1805, 1812, 1819,
	1826, 1833, 1840, 1844, 1848, 1851, 1861, 1870, 1873, 1877, 1884, 1891,
	1898, 1909, 1916, 1923, 1930, 1937, 1944, 1947, 1954, 1961, 1964, 1971,
	1978, 1981, 1988, 1995, 2002, 2007, 2010, 2023, 2034, 2045, 2055, 2061,
	2069, 2077, 2086, 2097, 2105, 2123, 2141, 2171, 2178, 2193, 2201, 2204,
	2212, 2223, 2230, 2238, 2241, 2246, 2250, 2255, 2262, 2270, 2277, 2284,
	2293, 2303, 2313, 2321, 2324, 2343, 2348, 2355, 2358, 2368, 2384, 2391,
	2407, 2417, 2421, 2429, 2432, 2437, 2452, 2455, 2460, 2471, 2474, 2479,
	2487, 2496, 2503, 2510, 2517, 2524, 2531, 2540, 2547, 2556, 2563, 2570,
	2577, 2584, 2588, 2594, 2598, 2603, 2612, 2619, 2626, 2633, 2640, 2647,
	2651, 2661, 2670, 2680, 2695, 2706, 2708, 2716, 2735, 2738, 2754, 2760,
	2772, 2775, 2791, 2796, 2806, 2819, 2832, 2837, 2844, 2852, 2855, 2865,
	2878, 2891, 2896, 2903, 2911, 2914, 2940, 2966, 2975, 2978, 2981, 2992,
	2995, 2998, 3006, 3015, 3025, 3035, 3046, 3056, 3060, 3068, 3079, 3087,
	3101, 3114, 3118, 3122, 3129, 3178, 3222, 3226, 3232, 3240, 3246, 3270,
	3282, 3290, 3314, 3325, 3341, 3362, 3378, 3391, 3404, 3412, 3428, 3441,
	3454, 3460, 3469, 3472, 3480, 3489, 3492, 3502, 3505, 3511, 3520, 3523,
	3540, 3555, 3564, 3573, 3580, 3582, 3589, 3599, 3609, 3616, 3628, 3633,
	3639, 3648, 3655, 3657, 3666, 3683, 3698, 3711, 3726, 3737, 3770, 3783,
	3796, 3809, 3822, 3835, 3848, 3876, 3887, 3893, 3905, 3912, 3914, 3937,
	3973, 3978, 4004, 4011, 4015, 4022, 4029, 4033,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'config'", "';'", "'endconfig'", "'design'", "'.'", "'default'", "'instance'",
	"'liblist'", "'cell'", "'use'", "':config'", "'endmodule'", "'module'",
	"'macromodule'", "'#'", "'('", "','", "')'", "'{'", "'}'", "'['", "']'",
	"'defparam'", "'localparam'", "'signed'", "'integer'", "'real'", "'realtime'",
	"'time'", "'parameter'", "'specparam'", "'inout'", "'input'", "'output'",
	"'reg'", "'event'", "'genvar'", "'trireg'", "'vectored'", "'scalared'",
	"'supply0'", "'supply1'", "'tri'", "'triand'", "'trior'", "'tri0'", "'tri1'",
	"'wire'", "'wand'", "'wor'", "'='", "'highz1'", "'highz0'", "'strong0'",
	"'pull0'", "'weak0'", "'strong1'", "'pull1'", "'weak1'", "'small'", "'medium'",
	"'large'", "'PATHPULSE$'", "'$'", "':'", "'function'", "'automatic'", "'endfunction'",
	"'task'", "'endtask'", "'pulldown'", "'pullup'", "'cmos'", "'rcmos'", "'bufif0'",
	"'bufif1'", "'notif0'", "'notif1'", "'nmos'", "'pmos'", "'rnmos'", "'rpmos'",
	"'and'", "'nand'", "'or'", "'nor'", "'xor'", "'xnor'", "'buf'", "'not'",
	"'tranif0'", "'tranif1'", "'rtranif1'", "'rtranif0'", "'tran'", "'rtran'",
	"'generate'", "'endgenerate'", "'if'", "'else'", "'case'", "'endcase'",
	"'for'", "'begin'", "'end'", "'assign'", "'initial'", "'always'", "'<='",
	"'deassign'", "'force'", "'release'", "'fork'", "'join'", "'repeat'", "'disable'",
	"'@'", "'*'", "'->'", "'posedge'", "'negedge'", "'wait'", "'casez'", "'casex'",
	"'forever'", "'while'", "'specify'", "'endspecify'", "'pulsestyle_onevent'",
	"'pulsestyle_ondetect'", "'showcancelled'", "'noshowcancelled'", "'=>'",
	"'*>'", "'ifnone'", "'+'", "'-'", "'+:'", "'-:'", "'?'", "'!'", "'~'",
	"'&'", "'~&'", "'|'", "'~|'", "'^'", "'~^'", "'^~'", "'/'", "'%'", "'=='",
	"'!='", "'==='", "'!=='", "'&&'", "'||'", "'**'", "'<'", "'>'", "'>='",
	"'>>'", "'<<'", "'>>>'", "'<<<'", "'`timescale'", "'`define'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "Real_number", "Decimal_number", "Binary_number",
	"Octal_number", "Hex_number", "Strings", "One_line_comment", "Block_comment",
	"Escaped_identifier", "Simple_identifier", "Dollar_Identifier", "Time_Identifier",
	"White_space",
}

var ruleNames = []string{
	"config_declaration", "design_statement", "config_rule_statement", "default_clause",
	"inst_clause", "inst_name", "liblist_clause", "cell_clause", "use_clause",
	"source_text", "description", "module_declaration", "module_keyword", "module_parameter_port_list",
	"list_of_ports", "list_of_port_declarations", "port", "port_expression",
	"port_reference", "port_declaration", "module_item", "module_or_generate_item",
	"non_port_module_item", "module_or_generate_item_declaration", "parameter_override",
	"local_parameter_declaration", "parameter_declaration", "parameter_declaration_",
	"specparam_declaration", "inout_declaration", "input_declaration", "output_declaration",
	"event_declaration", "genvar_declaration", "integer_declaration", "time_declaration",
	"real_declaration", "realtime_declaration", "reg_declaration", "net_declaration",
	"net_type", "output_variable_type", "real_type", "variable_type", "drive_strength",
	"strength0", "strength1", "charge_strength", "delay3", "delay2", "delay_value",
	"list_of_event_identifiers", "list_of_net_identifiers", "list_of_genvar_identifiers",
	"list_of_port_identifiers", "list_of_net_decl_assignments", "list_of_param_assignments",
	"list_of_specparam_assignments", "list_of_real_identifiers", "list_of_variable_identifiers",
	"list_of_variable_port_identifiers", "net_decl_assignment", "param_assignment",
	"specparam_assignment", "pulse_control_specparam", "error_limit_value",
	"reject_limit_value", "limit_value", "dimension", "range_", "function_declaration",
	"function_item_declaration", "function_port_list", "function_port", "range_or_type",
	"task_declaration", "task_item_declaration", "task_port_list", "task_port_item",
	"tf_decl_header", "tf_declaration", "task_port_type", "block_item_declaration",
	"block_reg_declaration", "list_of_block_variable_identifiers", "block_variable_type",
	"gate_instantiation", "cmos_switch_instance", "enable_gate_instance", "mos_switch_instance",
	"n_input_gate_instance", "n_output_gate_instance", "pass_switch_instance",
	"pass_enable_switch_instance", "pull_gate_instance", "name_of_gate_instance",
	"pulldown_strength", "pullup_strength", "enable_terminal", "ncontrol_terminal",
	"pcontrol_terminal", "input_terminal", "inout_terminal", "output_terminal",
	"cmos_switchtype", "enable_gatetype", "mos_switchtype", "n_input_gatetype",
	"n_output_gatetype", "pass_en_switchtype", "pass_switchtype", "module_instantiation",
	"parameter_value_assignment", "list_of_parameter_assignments", "ordered_parameter_assignment",
	"named_parameter_assignment", "module_instance", "name_of_instance", "list_of_port_connections",
	"ordered_port_connection", "named_port_connection", "generated_instantiation",
	"generate_item_or_null", "generate_item", "generate_conditional_statement",
	"generate_case_statement", "genvar_case_item", "generate_loop_statement",
	"genvar_assignment", "generate_block", "continuous_assign", "list_of_net_assignments",
	"net_assignment", "initial_construct", "always_construct", "blocking_assignment",
	"nonblocking_assignment", "procedural_continuous_assignments", "function_blocking_assignment",
	"function_statement_or_null", "function_seq_block", "variable_assignment",
	"par_block", "seq_block", "statement", "statement_or_null", "function_statement",
	"delay_or_event_control", "delay_control", "disable_statement", "event_control",
	"event_trigger", "event_expression", "event_primary", "procedural_timing_control_statement",
	"wait_statement", "conditional_statement", "if_else_if_statement", "else_statement",
	"function_conditional_statement", "function_if_else_if_statement", "case_statement",
	"case_item", "function_case_statement", "function_case_item", "function_loop_statement",
	"loop_statement", "system_task_enable", "task_enable", "specify_block",
	"specify_item", "pulsestyle_declaration", "showcancelled_declaration",
	"path_declaration", "simple_path_declaration", "parallel_path_description",
	"full_path_description", "list_of_path_inputs", "list_of_path_outputs",
	"specify_input_terminal_descriptor", "specify_output_terminal_descriptor",
	"input_identifier", "output_identifier", "path_delay_value", "list_of_path_delay_expressions",
	"t_path_delay_expression", "trise_path_delay_expression", "tfall_path_delay_expression",
	"tz_path_delay_expression", "t01_path_delay_expression", "t10_path_delay_expression",
	"t0z_path_delay_expression", "tz1_path_delay_expression", "t1z_path_delay_expression",
	"tz0_path_delay_expression", "t0x_path_delay_expression", "tx1_path_delay_expression",
	"t1x_path_delay_expression", "tx0_path_delay_expression", "txz_path_delay_expression",
	"tzx_path_delay_expression", "path_delay_expression", "edge_sensitive_path_declaration",
	"parallel_edge_sensitive_path_description", "full_edge_sensitive_path_description",
	"data_source_expression", "edge_identifier", "state_dependent_path_declaration",
	"polarity_operator", "checktime_condition", "delayed_data", "delayed_reference",
	"end_edge_offset", "event_based_flag", "notify_reg", "remain_active_flag",
	"stamptime_condition", "start_edge_offset", "threshold", "timing_check_limit",
	"concatenation", "constant_concatenation", "constant_multiple_concatenation",
	"module_path_concatenation", "module_path_multiple_concatenation", "multiple_concatenation",
	"net_concatenation", "net_concatenation_value", "variable_concatenation",
	"variable_concatenation_value", "constant_function_call", "function_call",
	"system_function_call", "genvar_function_call", "base_expression", "constant_base_expression",
	"constant_expression", "constant_mintypmax_expression", "constant_range_expression",
	"dimension_constant_expression", "expression", "term", "lsb_constant_expression",
	"mintypmax_expression", "module_path_conditional_expression", "module_path_expression",
	"module_path_mintypmax_expression", "msb_constant_expression", "range_expression",
	"width_constant_expression", "constant_primary", "module_path_primary",
	"primary", "net_lvalue", "variable_lvalue", "unary_operator", "binary_operator",
	"unary_module_path_operator", "binary_module_path_operator", "number",
	"timing_spec", "define", "attribute_instance", "attr_spec", "attr_name",
	"arrayed_identifier", "block_identifier", "cell_identifier", "config_identifier",
	"define_identifier", "escaped_arrayed_identifier", "escaped_hierarchical_identifier",
	"event_identifier", "function_identifier", "gate_instance_identifier",
	"generate_block_identifier", "genvar_function_identifier", "genvar_identifier",
	"hierarchical_block_identifier", "hierarchical_event_identifier", "hierarchical_function_identifier",
	"hierarchical_identifier", "hierarchical_net_identifier", "hierarchical_variable_identifier",
	"hierarchical_task_identifier", "identifier", "inout_port_identifier",
	"input_port_identifier", "instance_identifier", "library_identifier", "memory_identifier",
	"module_identifier", "module_instance_identifier", "net_identifier", "output_port_identifier",
	"parameter_identifier", "port_identifier", "real_identifier", "simple_arrayed_identifier",
	"simple_hierarchical_identifier", "specparam_identifier", "system_function_identifier",
	"system_task_identifier", "task_identifier", "terminal_identifier", "text_macro_identifier",
	"topmodule_identifier", "udp_identifier", "udp_instance_identifier", "variable_identifier",
	"simple_hierarchical_branch", "escaped_hierarchical_branch",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type VerilogParser struct {
	*antlr.BaseParser
}

func NewVerilogParser(input antlr.TokenStream) *VerilogParser {
	this := new(VerilogParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Verilog.g4"

	return this
}

// VerilogParser tokens.
const (
	VerilogParserEOF                = antlr.TokenEOF
	VerilogParserT__0               = 1
	VerilogParserT__1               = 2
	VerilogParserT__2               = 3
	VerilogParserT__3               = 4
	VerilogParserT__4               = 5
	VerilogParserT__5               = 6
	VerilogParserT__6               = 7
	VerilogParserT__7               = 8
	VerilogParserT__8               = 9
	VerilogParserT__9               = 10
	VerilogParserT__10              = 11
	VerilogParserT__11              = 12
	VerilogParserT__12              = 13
	VerilogParserT__13              = 14
	VerilogParserT__14              = 15
	VerilogParserT__15              = 16
	VerilogParserT__16              = 17
	VerilogParserT__17              = 18
	VerilogParserT__18              = 19
	VerilogParserT__19              = 20
	VerilogParserT__20              = 21
	VerilogParserT__21              = 22
	VerilogParserT__22              = 23
	VerilogParserT__23              = 24
	VerilogParserT__24              = 25
	VerilogParserT__25              = 26
	VerilogParserT__26              = 27
	VerilogParserT__27              = 28
	VerilogParserT__28              = 29
	VerilogParserT__29              = 30
	VerilogParserT__30              = 31
	VerilogParserT__31              = 32
	VerilogParserT__32              = 33
	VerilogParserT__33              = 34
	VerilogParserT__34              = 35
	VerilogParserT__35              = 36
	VerilogParserT__36              = 37
	VerilogParserT__37              = 38
	VerilogParserT__38              = 39
	VerilogParserT__39              = 40
	VerilogParserT__40              = 41
	VerilogParserT__41              = 42
	VerilogParserT__42              = 43
	VerilogParserT__43              = 44
	VerilogParserT__44              = 45
	VerilogParserT__45              = 46
	VerilogParserT__46              = 47
	VerilogParserT__47              = 48
	VerilogParserT__48              = 49
	VerilogParserT__49              = 50
	VerilogParserT__50              = 51
	VerilogParserT__51              = 52
	VerilogParserT__52              = 53
	VerilogParserT__53              = 54
	VerilogParserT__54              = 55
	VerilogParserT__55              = 56
	VerilogParserT__56              = 57
	VerilogParserT__57              = 58
	VerilogParserT__58              = 59
	VerilogParserT__59              = 60
	VerilogParserT__60              = 61
	VerilogParserT__61              = 62
	VerilogParserT__62              = 63
	VerilogParserT__63              = 64
	VerilogParserT__64              = 65
	VerilogParserT__65              = 66
	VerilogParserT__66              = 67
	VerilogParserT__67              = 68
	VerilogParserT__68              = 69
	VerilogParserT__69              = 70
	VerilogParserT__70              = 71
	VerilogParserT__71              = 72
	VerilogParserT__72              = 73
	VerilogParserT__73              = 74
	VerilogParserT__74              = 75
	VerilogParserT__75              = 76
	VerilogParserT__76              = 77
	VerilogParserT__77              = 78
	VerilogParserT__78              = 79
	VerilogParserT__79              = 80
	VerilogParserT__80              = 81
	VerilogParserT__81              = 82
	VerilogParserT__82              = 83
	VerilogParserT__83              = 84
	VerilogParserT__84              = 85
	VerilogParserT__85              = 86
	VerilogParserT__86              = 87
	VerilogParserT__87              = 88
	VerilogParserT__88              = 89
	VerilogParserT__89              = 90
	VerilogParserT__90              = 91
	VerilogParserT__91              = 92
	VerilogParserT__92              = 93
	VerilogParserT__93              = 94
	VerilogParserT__94              = 95
	VerilogParserT__95              = 96
	VerilogParserT__96              = 97
	VerilogParserT__97              = 98
	VerilogParserT__98              = 99
	VerilogParserT__99              = 100
	VerilogParserT__100             = 101
	VerilogParserT__101             = 102
	VerilogParserT__102             = 103
	VerilogParserT__103             = 104
	VerilogParserT__104             = 105
	VerilogParserT__105             = 106
	VerilogParserT__106             = 107
	VerilogParserT__107             = 108
	VerilogParserT__108             = 109
	VerilogParserT__109             = 110
	VerilogParserT__110             = 111
	VerilogParserT__111             = 112
	VerilogParserT__112             = 113
	VerilogParserT__113             = 114
	VerilogParserT__114             = 115
	VerilogParserT__115             = 116
	VerilogParserT__116             = 117
	VerilogParserT__117             = 118
	VerilogParserT__118             = 119
	VerilogParserT__119             = 120
	VerilogParserT__120             = 121
	VerilogParserT__121             = 122
	VerilogParserT__122             = 123
	VerilogParserT__123             = 124
	VerilogParserT__124             = 125
	VerilogParserT__125             = 126
	VerilogParserT__126             = 127
	VerilogParserT__127             = 128
	VerilogParserT__128             = 129
	VerilogParserT__129             = 130
	VerilogParserT__130             = 131
	VerilogParserT__131             = 132
	VerilogParserT__132             = 133
	VerilogParserT__133             = 134
	VerilogParserT__134             = 135
	VerilogParserT__135             = 136
	VerilogParserT__136             = 137
	VerilogParserT__137             = 138
	VerilogParserT__138             = 139
	VerilogParserT__139             = 140
	VerilogParserT__140             = 141
	VerilogParserT__141             = 142
	VerilogParserT__142             = 143
	VerilogParserT__143             = 144
	VerilogParserT__144             = 145
	VerilogParserT__145             = 146
	VerilogParserT__146             = 147
	VerilogParserT__147             = 148
	VerilogParserT__148             = 149
	VerilogParserT__149             = 150
	VerilogParserT__150             = 151
	VerilogParserT__151             = 152
	VerilogParserT__152             = 153
	VerilogParserT__153             = 154
	VerilogParserT__154             = 155
	VerilogParserT__155             = 156
	VerilogParserT__156             = 157
	VerilogParserT__157             = 158
	VerilogParserT__158             = 159
	VerilogParserT__159             = 160
	VerilogParserT__160             = 161
	VerilogParserT__161             = 162
	VerilogParserT__162             = 163
	VerilogParserT__163             = 164
	VerilogParserT__164             = 165
	VerilogParserT__165             = 166
	VerilogParserT__166             = 167
	VerilogParserReal_number        = 168
	VerilogParserDecimal_number     = 169
	VerilogParserBinary_number      = 170
	VerilogParserOctal_number       = 171
	VerilogParserHex_number         = 172
	VerilogParserStrings            = 173
	VerilogParserOne_line_comment   = 174
	VerilogParserBlock_comment      = 175
	VerilogParserEscaped_identifier = 176
	VerilogParserSimple_identifier  = 177
	VerilogParserDollar_Identifier  = 178
	VerilogParserTime_Identifier    = 179
	VerilogParserWhite_space        = 180
)

// VerilogParser rules.
const (
	VerilogParserRULE_config_declaration                       = 0
	VerilogParserRULE_design_statement                         = 1
	VerilogParserRULE_config_rule_statement                    = 2
	VerilogParserRULE_default_clause                           = 3
	VerilogParserRULE_inst_clause                              = 4
	VerilogParserRULE_inst_name                                = 5
	VerilogParserRULE_liblist_clause                           = 6
	VerilogParserRULE_cell_clause                              = 7
	VerilogParserRULE_use_clause                               = 8
	VerilogParserRULE_source_text                              = 9
	VerilogParserRULE_description                              = 10
	VerilogParserRULE_module_declaration                       = 11
	VerilogParserRULE_module_keyword                           = 12
	VerilogParserRULE_module_parameter_port_list               = 13
	VerilogParserRULE_list_of_ports                            = 14
	VerilogParserRULE_list_of_port_declarations                = 15
	VerilogParserRULE_port                                     = 16
	VerilogParserRULE_port_expression                          = 17
	VerilogParserRULE_port_reference                           = 18
	VerilogParserRULE_port_declaration                         = 19
	VerilogParserRULE_module_item                              = 20
	VerilogParserRULE_module_or_generate_item                  = 21
	VerilogParserRULE_non_port_module_item                     = 22
	VerilogParserRULE_module_or_generate_item_declaration      = 23
	VerilogParserRULE_parameter_override                       = 24
	VerilogParserRULE_local_parameter_declaration              = 25
	VerilogParserRULE_parameter_declaration                    = 26
	VerilogParserRULE_parameter_declaration_                   = 27
	VerilogParserRULE_specparam_declaration                    = 28
	VerilogParserRULE_inout_declaration                        = 29
	VerilogParserRULE_input_declaration                        = 30
	VerilogParserRULE_output_declaration                       = 31
	VerilogParserRULE_event_declaration                        = 32
	VerilogParserRULE_genvar_declaration                       = 33
	VerilogParserRULE_integer_declaration                      = 34
	VerilogParserRULE_time_declaration                         = 35
	VerilogParserRULE_real_declaration                         = 36
	VerilogParserRULE_realtime_declaration                     = 37
	VerilogParserRULE_reg_declaration                          = 38
	VerilogParserRULE_net_declaration                          = 39
	VerilogParserRULE_net_type                                 = 40
	VerilogParserRULE_output_variable_type                     = 41
	VerilogParserRULE_real_type                                = 42
	VerilogParserRULE_variable_type                            = 43
	VerilogParserRULE_drive_strength                           = 44
	VerilogParserRULE_strength0                                = 45
	VerilogParserRULE_strength1                                = 46
	VerilogParserRULE_charge_strength                          = 47
	VerilogParserRULE_delay3                                   = 48
	VerilogParserRULE_delay2                                   = 49
	VerilogParserRULE_delay_value                              = 50
	VerilogParserRULE_list_of_event_identifiers                = 51
	VerilogParserRULE_list_of_net_identifiers                  = 52
	VerilogParserRULE_list_of_genvar_identifiers               = 53
	VerilogParserRULE_list_of_port_identifiers                 = 54
	VerilogParserRULE_list_of_net_decl_assignments             = 55
	VerilogParserRULE_list_of_param_assignments                = 56
	VerilogParserRULE_list_of_specparam_assignments            = 57
	VerilogParserRULE_list_of_real_identifiers                 = 58
	VerilogParserRULE_list_of_variable_identifiers             = 59
	VerilogParserRULE_list_of_variable_port_identifiers        = 60
	VerilogParserRULE_net_decl_assignment                      = 61
	VerilogParserRULE_param_assignment                         = 62
	VerilogParserRULE_specparam_assignment                     = 63
	VerilogParserRULE_pulse_control_specparam                  = 64
	VerilogParserRULE_error_limit_value                        = 65
	VerilogParserRULE_reject_limit_value                       = 66
	VerilogParserRULE_limit_value                              = 67
	VerilogParserRULE_dimension                                = 68
	VerilogParserRULE_range_                                   = 69
	VerilogParserRULE_function_declaration                     = 70
	VerilogParserRULE_function_item_declaration                = 71
	VerilogParserRULE_function_port_list                       = 72
	VerilogParserRULE_function_port                            = 73
	VerilogParserRULE_range_or_type                            = 74
	VerilogParserRULE_task_declaration                         = 75
	VerilogParserRULE_task_item_declaration                    = 76
	VerilogParserRULE_task_port_list                           = 77
	VerilogParserRULE_task_port_item                           = 78
	VerilogParserRULE_tf_decl_header                           = 79
	VerilogParserRULE_tf_declaration                           = 80
	VerilogParserRULE_task_port_type                           = 81
	VerilogParserRULE_block_item_declaration                   = 82
	VerilogParserRULE_block_reg_declaration                    = 83
	VerilogParserRULE_list_of_block_variable_identifiers       = 84
	VerilogParserRULE_block_variable_type                      = 85
	VerilogParserRULE_gate_instantiation                       = 86
	VerilogParserRULE_cmos_switch_instance                     = 87
	VerilogParserRULE_enable_gate_instance                     = 88
	VerilogParserRULE_mos_switch_instance                      = 89
	VerilogParserRULE_n_input_gate_instance                    = 90
	VerilogParserRULE_n_output_gate_instance                   = 91
	VerilogParserRULE_pass_switch_instance                     = 92
	VerilogParserRULE_pass_enable_switch_instance              = 93
	VerilogParserRULE_pull_gate_instance                       = 94
	VerilogParserRULE_name_of_gate_instance                    = 95
	VerilogParserRULE_pulldown_strength                        = 96
	VerilogParserRULE_pullup_strength                          = 97
	VerilogParserRULE_enable_terminal                          = 98
	VerilogParserRULE_ncontrol_terminal                        = 99
	VerilogParserRULE_pcontrol_terminal                        = 100
	VerilogParserRULE_input_terminal                           = 101
	VerilogParserRULE_inout_terminal                           = 102
	VerilogParserRULE_output_terminal                          = 103
	VerilogParserRULE_cmos_switchtype                          = 104
	VerilogParserRULE_enable_gatetype                          = 105
	VerilogParserRULE_mos_switchtype                           = 106
	VerilogParserRULE_n_input_gatetype                         = 107
	VerilogParserRULE_n_output_gatetype                        = 108
	VerilogParserRULE_pass_en_switchtype                       = 109
	VerilogParserRULE_pass_switchtype                          = 110
	VerilogParserRULE_module_instantiation                     = 111
	VerilogParserRULE_parameter_value_assignment               = 112
	VerilogParserRULE_list_of_parameter_assignments            = 113
	VerilogParserRULE_ordered_parameter_assignment             = 114
	VerilogParserRULE_named_parameter_assignment               = 115
	VerilogParserRULE_module_instance                          = 116
	VerilogParserRULE_name_of_instance                         = 117
	VerilogParserRULE_list_of_port_connections                 = 118
	VerilogParserRULE_ordered_port_connection                  = 119
	VerilogParserRULE_named_port_connection                    = 120
	VerilogParserRULE_generated_instantiation                  = 121
	VerilogParserRULE_generate_item_or_null                    = 122
	VerilogParserRULE_generate_item                            = 123
	VerilogParserRULE_generate_conditional_statement           = 124
	VerilogParserRULE_generate_case_statement                  = 125
	VerilogParserRULE_genvar_case_item                         = 126
	VerilogParserRULE_generate_loop_statement                  = 127
	VerilogParserRULE_genvar_assignment                        = 128
	VerilogParserRULE_generate_block                           = 129
	VerilogParserRULE_continuous_assign                        = 130
	VerilogParserRULE_list_of_net_assignments                  = 131
	VerilogParserRULE_net_assignment                           = 132
	VerilogParserRULE_initial_construct                        = 133
	VerilogParserRULE_always_construct                         = 134
	VerilogParserRULE_blocking_assignment                      = 135
	VerilogParserRULE_nonblocking_assignment                   = 136
	VerilogParserRULE_procedural_continuous_assignments        = 137
	VerilogParserRULE_function_blocking_assignment             = 138
	VerilogParserRULE_function_statement_or_null               = 139
	VerilogParserRULE_function_seq_block                       = 140
	VerilogParserRULE_variable_assignment                      = 141
	VerilogParserRULE_par_block                                = 142
	VerilogParserRULE_seq_block                                = 143
	VerilogParserRULE_statement                                = 144
	VerilogParserRULE_statement_or_null                        = 145
	VerilogParserRULE_function_statement                       = 146
	VerilogParserRULE_delay_or_event_control                   = 147
	VerilogParserRULE_delay_control                            = 148
	VerilogParserRULE_disable_statement                        = 149
	VerilogParserRULE_event_control                            = 150
	VerilogParserRULE_event_trigger                            = 151
	VerilogParserRULE_event_expression                         = 152
	VerilogParserRULE_event_primary                            = 153
	VerilogParserRULE_procedural_timing_control_statement      = 154
	VerilogParserRULE_wait_statement                           = 155
	VerilogParserRULE_conditional_statement                    = 156
	VerilogParserRULE_if_else_if_statement                     = 157
	VerilogParserRULE_else_statement                           = 158
	VerilogParserRULE_function_conditional_statement           = 159
	VerilogParserRULE_function_if_else_if_statement            = 160
	VerilogParserRULE_case_statement                           = 161
	VerilogParserRULE_case_item                                = 162
	VerilogParserRULE_function_case_statement                  = 163
	VerilogParserRULE_function_case_item                       = 164
	VerilogParserRULE_function_loop_statement                  = 165
	VerilogParserRULE_loop_statement                           = 166
	VerilogParserRULE_system_task_enable                       = 167
	VerilogParserRULE_task_enable                              = 168
	VerilogParserRULE_specify_block                            = 169
	VerilogParserRULE_specify_item                             = 170
	VerilogParserRULE_pulsestyle_declaration                   = 171
	VerilogParserRULE_showcancelled_declaration                = 172
	VerilogParserRULE_path_declaration                         = 173
	VerilogParserRULE_simple_path_declaration                  = 174
	VerilogParserRULE_parallel_path_description                = 175
	VerilogParserRULE_full_path_description                    = 176
	VerilogParserRULE_list_of_path_inputs                      = 177
	VerilogParserRULE_list_of_path_outputs                     = 178
	VerilogParserRULE_specify_input_terminal_descriptor        = 179
	VerilogParserRULE_specify_output_terminal_descriptor       = 180
	VerilogParserRULE_input_identifier                         = 181
	VerilogParserRULE_output_identifier                        = 182
	VerilogParserRULE_path_delay_value                         = 183
	VerilogParserRULE_list_of_path_delay_expressions           = 184
	VerilogParserRULE_t_path_delay_expression                  = 185
	VerilogParserRULE_trise_path_delay_expression              = 186
	VerilogParserRULE_tfall_path_delay_expression              = 187
	VerilogParserRULE_tz_path_delay_expression                 = 188
	VerilogParserRULE_t01_path_delay_expression                = 189
	VerilogParserRULE_t10_path_delay_expression                = 190
	VerilogParserRULE_t0z_path_delay_expression                = 191
	VerilogParserRULE_tz1_path_delay_expression                = 192
	VerilogParserRULE_t1z_path_delay_expression                = 193
	VerilogParserRULE_tz0_path_delay_expression                = 194
	VerilogParserRULE_t0x_path_delay_expression                = 195
	VerilogParserRULE_tx1_path_delay_expression                = 196
	VerilogParserRULE_t1x_path_delay_expression                = 197
	VerilogParserRULE_tx0_path_delay_expression                = 198
	VerilogParserRULE_txz_path_delay_expression                = 199
	VerilogParserRULE_tzx_path_delay_expression                = 200
	VerilogParserRULE_path_delay_expression                    = 201
	VerilogParserRULE_edge_sensitive_path_declaration          = 202
	VerilogParserRULE_parallel_edge_sensitive_path_description = 203
	VerilogParserRULE_full_edge_sensitive_path_description     = 204
	VerilogParserRULE_data_source_expression                   = 205
	VerilogParserRULE_edge_identifier                          = 206
	VerilogParserRULE_state_dependent_path_declaration         = 207
	VerilogParserRULE_polarity_operator                        = 208
	VerilogParserRULE_checktime_condition                      = 209
	VerilogParserRULE_delayed_data                             = 210
	VerilogParserRULE_delayed_reference                        = 211
	VerilogParserRULE_end_edge_offset                          = 212
	VerilogParserRULE_event_based_flag                         = 213
	VerilogParserRULE_notify_reg                               = 214
	VerilogParserRULE_remain_active_flag                       = 215
	VerilogParserRULE_stamptime_condition                      = 216
	VerilogParserRULE_start_edge_offset                        = 217
	VerilogParserRULE_threshold                                = 218
	VerilogParserRULE_timing_check_limit                       = 219
	VerilogParserRULE_concatenation                            = 220
	VerilogParserRULE_constant_concatenation                   = 221
	VerilogParserRULE_constant_multiple_concatenation          = 222
	VerilogParserRULE_module_path_concatenation                = 223
	VerilogParserRULE_module_path_multiple_concatenation       = 224
	VerilogParserRULE_multiple_concatenation                   = 225
	VerilogParserRULE_net_concatenation                        = 226
	VerilogParserRULE_net_concatenation_value                  = 227
	VerilogParserRULE_variable_concatenation                   = 228
	VerilogParserRULE_variable_concatenation_value             = 229
	VerilogParserRULE_constant_function_call                   = 230
	VerilogParserRULE_function_call                            = 231
	VerilogParserRULE_system_function_call                     = 232
	VerilogParserRULE_genvar_function_call                     = 233
	VerilogParserRULE_base_expression                          = 234
	VerilogParserRULE_constant_base_expression                 = 235
	VerilogParserRULE_constant_expression                      = 236
	VerilogParserRULE_constant_mintypmax_expression            = 237
	VerilogParserRULE_constant_range_expression                = 238
	VerilogParserRULE_dimension_constant_expression            = 239
	VerilogParserRULE_expression                               = 240
	VerilogParserRULE_term                                     = 241
	VerilogParserRULE_lsb_constant_expression                  = 242
	VerilogParserRULE_mintypmax_expression                     = 243
	VerilogParserRULE_module_path_conditional_expression       = 244
	VerilogParserRULE_module_path_expression                   = 245
	VerilogParserRULE_module_path_mintypmax_expression         = 246
	VerilogParserRULE_msb_constant_expression                  = 247
	VerilogParserRULE_range_expression                         = 248
	VerilogParserRULE_width_constant_expression                = 249
	VerilogParserRULE_constant_primary                         = 250
	VerilogParserRULE_module_path_primary                      = 251
	VerilogParserRULE_primary                                  = 252
	VerilogParserRULE_net_lvalue                               = 253
	VerilogParserRULE_variable_lvalue                          = 254
	VerilogParserRULE_unary_operator                           = 255
	VerilogParserRULE_binary_operator                          = 256
	VerilogParserRULE_unary_module_path_operator               = 257
	VerilogParserRULE_binary_module_path_operator              = 258
	VerilogParserRULE_number                                   = 259
	VerilogParserRULE_timing_spec                              = 260
	VerilogParserRULE_define                                   = 261
	VerilogParserRULE_attribute_instance                       = 262
	VerilogParserRULE_attr_spec                                = 263
	VerilogParserRULE_attr_name                                = 264
	VerilogParserRULE_arrayed_identifier                       = 265
	VerilogParserRULE_block_identifier                         = 266
	VerilogParserRULE_cell_identifier                          = 267
	VerilogParserRULE_config_identifier                        = 268
	VerilogParserRULE_define_identifier                        = 269
	VerilogParserRULE_escaped_arrayed_identifier               = 270
	VerilogParserRULE_escaped_hierarchical_identifier          = 271
	VerilogParserRULE_event_identifier                         = 272
	VerilogParserRULE_function_identifier                      = 273
	VerilogParserRULE_gate_instance_identifier                 = 274
	VerilogParserRULE_generate_block_identifier                = 275
	VerilogParserRULE_genvar_function_identifier               = 276
	VerilogParserRULE_genvar_identifier                        = 277
	VerilogParserRULE_hierarchical_block_identifier            = 278
	VerilogParserRULE_hierarchical_event_identifier            = 279
	VerilogParserRULE_hierarchical_function_identifier         = 280
	VerilogParserRULE_hierarchical_identifier                  = 281
	VerilogParserRULE_hierarchical_net_identifier              = 282
	VerilogParserRULE_hierarchical_variable_identifier         = 283
	VerilogParserRULE_hierarchical_task_identifier             = 284
	VerilogParserRULE_identifier                               = 285
	VerilogParserRULE_inout_port_identifier                    = 286
	VerilogParserRULE_input_port_identifier                    = 287
	VerilogParserRULE_instance_identifier                      = 288
	VerilogParserRULE_library_identifier                       = 289
	VerilogParserRULE_memory_identifier                        = 290
	VerilogParserRULE_module_identifier                        = 291
	VerilogParserRULE_module_instance_identifier               = 292
	VerilogParserRULE_net_identifier                           = 293
	VerilogParserRULE_output_port_identifier                   = 294
	VerilogParserRULE_parameter_identifier                     = 295
	VerilogParserRULE_port_identifier                          = 296
	VerilogParserRULE_real_identifier                          = 297
	VerilogParserRULE_simple_arrayed_identifier                = 298
	VerilogParserRULE_simple_hierarchical_identifier           = 299
	VerilogParserRULE_specparam_identifier                     = 300
	VerilogParserRULE_system_function_identifier               = 301
	VerilogParserRULE_system_task_identifier                   = 302
	VerilogParserRULE_task_identifier                          = 303
	VerilogParserRULE_terminal_identifier                      = 304
	VerilogParserRULE_text_macro_identifier                    = 305
	VerilogParserRULE_topmodule_identifier                     = 306
	VerilogParserRULE_udp_identifier                           = 307
	VerilogParserRULE_udp_instance_identifier                  = 308
	VerilogParserRULE_variable_identifier                      = 309
	VerilogParserRULE_simple_hierarchical_branch               = 310
	VerilogParserRULE_escaped_hierarchical_branch              = 311
)

// IConfig_declarationContext is an interface to support dynamic dispatch.
type IConfig_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfig_declarationContext differentiates from other interfaces.
	IsConfig_declarationContext()
}

type Config_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfig_declarationContext() *Config_declarationContext {
	var p = new(Config_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_config_declaration
	return p
}

func (*Config_declarationContext) IsConfig_declarationContext() {}

func NewConfig_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Config_declarationContext {
	var p = new(Config_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_config_declaration

	return p
}

func (s *Config_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Config_declarationContext) Config_identifier() IConfig_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfig_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfig_identifierContext)
}

func (s *Config_declarationContext) Design_statement() IDesign_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesign_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesign_statementContext)
}

func (s *Config_declarationContext) AllConfig_rule_statement() []IConfig_rule_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConfig_rule_statementContext)(nil)).Elem())
	var tst = make([]IConfig_rule_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConfig_rule_statementContext)
		}
	}

	return tst
}

func (s *Config_declarationContext) Config_rule_statement(i int) IConfig_rule_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfig_rule_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConfig_rule_statementContext)
}

func (s *Config_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Config_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Config_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterConfig_declaration(s)
	}
}

func (s *Config_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitConfig_declaration(s)
	}
}

func (p *VerilogParser) Config_declaration() (localctx IConfig_declarationContext) {
	localctx = NewConfig_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, VerilogParserRULE_config_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(624)
		p.Match(VerilogParserT__0)
	}
	{
		p.SetState(625)
		p.Config_identifier()
	}
	{
		p.SetState(626)
		p.Match(VerilogParserT__1)
	}
	{
		p.SetState(627)
		p.Design_statement()
	}
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__5)|(1<<VerilogParserT__6)|(1<<VerilogParserT__8))) != 0 {
		{
			p.SetState(628)
			p.Config_rule_statement()
		}

		p.SetState(633)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(634)
		p.Match(VerilogParserT__2)
	}

	return localctx
}

// IDesign_statementContext is an interface to support dynamic dispatch.
type IDesign_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesign_statementContext differentiates from other interfaces.
	IsDesign_statementContext()
}

type Design_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesign_statementContext() *Design_statementContext {
	var p = new(Design_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_design_statement
	return p
}

func (*Design_statementContext) IsDesign_statementContext() {}

func NewDesign_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Design_statementContext {
	var p = new(Design_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_design_statement

	return p
}

func (s *Design_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Design_statementContext) AllCell_identifier() []ICell_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem())
	var tst = make([]ICell_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICell_identifierContext)
		}
	}

	return tst
}

func (s *Design_statementContext) Cell_identifier(i int) ICell_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICell_identifierContext)
}

func (s *Design_statementContext) AllLibrary_identifier() []ILibrary_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem())
	var tst = make([]ILibrary_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibrary_identifierContext)
		}
	}

	return tst
}

func (s *Design_statementContext) Library_identifier(i int) ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Design_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Design_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Design_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDesign_statement(s)
	}
}

func (s *Design_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDesign_statement(s)
	}
}

func (p *VerilogParser) Design_statement() (localctx IDesign_statementContext) {
	localctx = NewDesign_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, VerilogParserRULE_design_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(636)
		p.Match(VerilogParserT__3)
	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		p.SetState(640)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(637)
				p.Library_identifier()
			}
			{
				p.SetState(638)
				p.Match(VerilogParserT__4)
			}

		}
		{
			p.SetState(642)
			p.Cell_identifier()
		}

		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(648)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// IConfig_rule_statementContext is an interface to support dynamic dispatch.
type IConfig_rule_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfig_rule_statementContext differentiates from other interfaces.
	IsConfig_rule_statementContext()
}

type Config_rule_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfig_rule_statementContext() *Config_rule_statementContext {
	var p = new(Config_rule_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_config_rule_statement
	return p
}

func (*Config_rule_statementContext) IsConfig_rule_statementContext() {}

func NewConfig_rule_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Config_rule_statementContext {
	var p = new(Config_rule_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_config_rule_statement

	return p
}

func (s *Config_rule_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Config_rule_statementContext) Default_clause() IDefault_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_clauseContext)
}

func (s *Config_rule_statementContext) Liblist_clause() ILiblist_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiblist_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiblist_clauseContext)
}

func (s *Config_rule_statementContext) Inst_clause() IInst_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInst_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInst_clauseContext)
}

func (s *Config_rule_statementContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Config_rule_statementContext) Cell_clause() ICell_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICell_clauseContext)
}

func (s *Config_rule_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Config_rule_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Config_rule_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterConfig_rule_statement(s)
	}
}

func (s *Config_rule_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitConfig_rule_statement(s)
	}
}

func (p *VerilogParser) Config_rule_statement() (localctx IConfig_rule_statementContext) {
	localctx = NewConfig_rule_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, VerilogParserRULE_config_rule_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(650)
			p.Default_clause()
		}
		{
			p.SetState(651)
			p.Liblist_clause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(653)
			p.Inst_clause()
		}
		{
			p.SetState(654)
			p.Liblist_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(656)
			p.Inst_clause()
		}
		{
			p.SetState(657)
			p.Use_clause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(659)
			p.Cell_clause()
		}
		{
			p.SetState(660)
			p.Liblist_clause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(662)
			p.Cell_clause()
		}
		{
			p.SetState(663)
			p.Use_clause()
		}

	}

	return localctx
}

// IDefault_clauseContext is an interface to support dynamic dispatch.
type IDefault_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefault_clauseContext differentiates from other interfaces.
	IsDefault_clauseContext()
}

type Default_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefault_clauseContext() *Default_clauseContext {
	var p = new(Default_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_default_clause
	return p
}

func (*Default_clauseContext) IsDefault_clauseContext() {}

func NewDefault_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Default_clauseContext {
	var p = new(Default_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_default_clause

	return p
}

func (s *Default_clauseContext) GetParser() antlr.Parser { return s.parser }
func (s *Default_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Default_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Default_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDefault_clause(s)
	}
}

func (s *Default_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDefault_clause(s)
	}
}

func (p *VerilogParser) Default_clause() (localctx IDefault_clauseContext) {
	localctx = NewDefault_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, VerilogParserRULE_default_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.Match(VerilogParserT__5)
	}

	return localctx
}

// IInst_clauseContext is an interface to support dynamic dispatch.
type IInst_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInst_clauseContext differentiates from other interfaces.
	IsInst_clauseContext()
}

type Inst_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInst_clauseContext() *Inst_clauseContext {
	var p = new(Inst_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inst_clause
	return p
}

func (*Inst_clauseContext) IsInst_clauseContext() {}

func NewInst_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inst_clauseContext {
	var p = new(Inst_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inst_clause

	return p
}

func (s *Inst_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Inst_clauseContext) Inst_name() IInst_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInst_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInst_nameContext)
}

func (s *Inst_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inst_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inst_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterInst_clause(s)
	}
}

func (s *Inst_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitInst_clause(s)
	}
}

func (p *VerilogParser) Inst_clause() (localctx IInst_clauseContext) {
	localctx = NewInst_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, VerilogParserRULE_inst_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(669)
		p.Match(VerilogParserT__6)
	}
	{
		p.SetState(670)
		p.Inst_name()
	}

	return localctx
}

// IInst_nameContext is an interface to support dynamic dispatch.
type IInst_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInst_nameContext differentiates from other interfaces.
	IsInst_nameContext()
}

type Inst_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInst_nameContext() *Inst_nameContext {
	var p = new(Inst_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inst_name
	return p
}

func (*Inst_nameContext) IsInst_nameContext() {}

func NewInst_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inst_nameContext {
	var p = new(Inst_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inst_name

	return p
}

func (s *Inst_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Inst_nameContext) Topmodule_identifier() ITopmodule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopmodule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopmodule_identifierContext)
}

func (s *Inst_nameContext) AllInstance_identifier() []IInstance_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstance_identifierContext)(nil)).Elem())
	var tst = make([]IInstance_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstance_identifierContext)
		}
	}

	return tst
}

func (s *Inst_nameContext) Instance_identifier(i int) IInstance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstance_identifierContext)
}

func (s *Inst_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inst_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inst_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterInst_name(s)
	}
}

func (s *Inst_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitInst_name(s)
	}
}

func (p *VerilogParser) Inst_name() (localctx IInst_nameContext) {
	localctx = NewInst_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, VerilogParserRULE_inst_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(672)
		p.Topmodule_identifier()
	}
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__4 {
		{
			p.SetState(673)
			p.Match(VerilogParserT__4)
		}
		{
			p.SetState(674)
			p.Instance_identifier()
		}

		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILiblist_clauseContext is an interface to support dynamic dispatch.
type ILiblist_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiblist_clauseContext differentiates from other interfaces.
	IsLiblist_clauseContext()
}

type Liblist_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiblist_clauseContext() *Liblist_clauseContext {
	var p = new(Liblist_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_liblist_clause
	return p
}

func (*Liblist_clauseContext) IsLiblist_clauseContext() {}

func NewLiblist_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Liblist_clauseContext {
	var p = new(Liblist_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_liblist_clause

	return p
}

func (s *Liblist_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Liblist_clauseContext) AllLibrary_identifier() []ILibrary_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem())
	var tst = make([]ILibrary_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibrary_identifierContext)
		}
	}

	return tst
}

func (s *Liblist_clauseContext) Library_identifier(i int) ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Liblist_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Liblist_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Liblist_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterLiblist_clause(s)
	}
}

func (s *Liblist_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitLiblist_clause(s)
	}
}

func (p *VerilogParser) Liblist_clause() (localctx ILiblist_clauseContext) {
	localctx = NewLiblist_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, VerilogParserRULE_liblist_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Match(VerilogParserT__7)
	}
	p.SetState(684)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(681)
			p.Library_identifier()
		}

		p.SetState(686)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICell_clauseContext is an interface to support dynamic dispatch.
type ICell_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCell_clauseContext differentiates from other interfaces.
	IsCell_clauseContext()
}

type Cell_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCell_clauseContext() *Cell_clauseContext {
	var p = new(Cell_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_cell_clause
	return p
}

func (*Cell_clauseContext) IsCell_clauseContext() {}

func NewCell_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cell_clauseContext {
	var p = new(Cell_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_cell_clause

	return p
}

func (s *Cell_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Cell_clauseContext) Cell_identifier() ICell_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICell_identifierContext)
}

func (s *Cell_clauseContext) Library_identifier() ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Cell_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cell_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cell_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterCell_clause(s)
	}
}

func (s *Cell_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitCell_clause(s)
	}
}

func (p *VerilogParser) Cell_clause() (localctx ICell_clauseContext) {
	localctx = NewCell_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, VerilogParserRULE_cell_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(687)
		p.Match(VerilogParserT__8)
	}
	p.SetState(691)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(688)
			p.Library_identifier()
		}
		{
			p.SetState(689)
			p.Match(VerilogParserT__4)
		}

	}
	{
		p.SetState(693)
		p.Cell_identifier()
	}

	return localctx
}

// IUse_clauseContext is an interface to support dynamic dispatch.
type IUse_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUse_clauseContext differentiates from other interfaces.
	IsUse_clauseContext()
}

type Use_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_clauseContext() *Use_clauseContext {
	var p = new(Use_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_use_clause
	return p
}

func (*Use_clauseContext) IsUse_clauseContext() {}

func NewUse_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_clauseContext {
	var p = new(Use_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_use_clause

	return p
}

func (s *Use_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_clauseContext) Cell_identifier() ICell_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICell_identifierContext)
}

func (s *Use_clauseContext) Library_identifier() ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Use_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterUse_clause(s)
	}
}

func (s *Use_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitUse_clause(s)
	}
}

func (p *VerilogParser) Use_clause() (localctx IUse_clauseContext) {
	localctx = NewUse_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, VerilogParserRULE_use_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(695)
		p.Match(VerilogParserT__9)
	}
	p.SetState(699)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(696)
			p.Library_identifier()
		}
		{
			p.SetState(697)
			p.Match(VerilogParserT__4)
		}

	}
	{
		p.SetState(701)
		p.Cell_identifier()
	}
	p.SetState(703)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__10 {
		{
			p.SetState(702)
			p.Match(VerilogParserT__10)
		}

	}

	return localctx
}

// ISource_textContext is an interface to support dynamic dispatch.
type ISource_textContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSource_textContext differentiates from other interfaces.
	IsSource_textContext()
}

type Source_textContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySource_textContext() *Source_textContext {
	var p = new(Source_textContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_source_text
	return p
}

func (*Source_textContext) IsSource_textContext() {}

func NewSource_textContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Source_textContext {
	var p = new(Source_textContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_source_text

	return p
}

func (s *Source_textContext) GetParser() antlr.Parser { return s.parser }

func (s *Source_textContext) EOF() antlr.TerminalNode {
	return s.GetToken(VerilogParserEOF, 0)
}

func (s *Source_textContext) Timing_spec() ITiming_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_specContext)
}

func (s *Source_textContext) AllDefine() []IDefineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDefineContext)(nil)).Elem())
	var tst = make([]IDefineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDefineContext)
		}
	}

	return tst
}

func (s *Source_textContext) Define(i int) IDefineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDefineContext)
}

func (s *Source_textContext) AllDescription() []IDescriptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDescriptionContext)(nil)).Elem())
	var tst = make([]IDescriptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDescriptionContext)
		}
	}

	return tst
}

func (s *Source_textContext) Description(i int) IDescriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDescriptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *Source_textContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Source_textContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Source_textContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSource_text(s)
	}
}

func (s *Source_textContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSource_text(s)
	}
}

func (p *VerilogParser) Source_text() (localctx ISource_textContext) {
	localctx = NewSource_textContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, VerilogParserRULE_source_text)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(706)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__165 {
		{
			p.SetState(705)
			p.Timing_spec()
		}

	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__166 {
		{
			p.SetState(708)
			p.Define()
		}

		p.SetState(713)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(717)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__12)|(1<<VerilogParserT__13)|(1<<VerilogParserT__15))) != 0 {
		{
			p.SetState(714)
			p.Description()
		}

		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(720)
		p.Match(VerilogParserEOF)
	}

	return localctx
}

// IDescriptionContext is an interface to support dynamic dispatch.
type IDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDescriptionContext differentiates from other interfaces.
	IsDescriptionContext()
}

type DescriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescriptionContext() *DescriptionContext {
	var p = new(DescriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_description
	return p
}

func (*DescriptionContext) IsDescriptionContext() {}

func NewDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescriptionContext {
	var p = new(DescriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_description

	return p
}

func (s *DescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DescriptionContext) Module_declaration() IModule_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_declarationContext)
}

func (s *DescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDescription(s)
	}
}

func (s *DescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDescription(s)
	}
}

func (p *VerilogParser) Description() (localctx IDescriptionContext) {
	localctx = NewDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, VerilogParserRULE_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(722)
		p.Module_declaration()
	}

	return localctx
}

// IModule_declarationContext is an interface to support dynamic dispatch.
type IModule_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_declarationContext differentiates from other interfaces.
	IsModule_declarationContext()
}

type Module_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_declarationContext() *Module_declarationContext {
	var p = new(Module_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_declaration
	return p
}

func (*Module_declarationContext) IsModule_declarationContext() {}

func NewModule_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_declarationContext {
	var p = new(Module_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_declaration

	return p
}

func (s *Module_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_declarationContext) Module_keyword() IModule_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_keywordContext)
}

func (s *Module_declarationContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Module_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_declarationContext) Module_parameter_port_list() IModule_parameter_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_parameter_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_parameter_port_listContext)
}

func (s *Module_declarationContext) List_of_ports() IList_of_portsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_portsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_portsContext)
}

func (s *Module_declarationContext) AllModule_item() []IModule_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_itemContext)(nil)).Elem())
	var tst = make([]IModule_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_itemContext)
		}
	}

	return tst
}

func (s *Module_declarationContext) Module_item(i int) IModule_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_itemContext)
}

func (s *Module_declarationContext) List_of_port_declarations() IList_of_port_declarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_declarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_declarationsContext)
}

func (s *Module_declarationContext) AllNon_port_module_item() []INon_port_module_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INon_port_module_itemContext)(nil)).Elem())
	var tst = make([]INon_port_module_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INon_port_module_itemContext)
		}
	}

	return tst
}

func (s *Module_declarationContext) Non_port_module_item(i int) INon_port_module_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_port_module_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INon_port_module_itemContext)
}

func (s *Module_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_declaration(s)
	}
}

func (s *Module_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_declaration(s)
	}
}

func (p *VerilogParser) Module_declaration() (localctx IModule_declarationContext) {
	localctx = NewModule_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, VerilogParserRULE_module_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(770)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(727)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(724)
				p.Attribute_instance()
			}

			p.SetState(729)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(730)
			p.Module_keyword()
		}
		{
			p.SetState(731)
			p.Module_identifier()
		}
		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(732)
				p.Module_parameter_port_list()
			}

		}
		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__15 {
			{
				p.SetState(735)
				p.List_of_ports()
			}

		}
		{
			p.SetState(738)
			p.Match(VerilogParserT__1)
		}
		p.SetState(742)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__15)|(1<<VerilogParserT__22)|(1<<VerilogParserT__23)|(1<<VerilogParserT__25)|(1<<VerilogParserT__26)|(1<<VerilogParserT__27)|(1<<VerilogParserT__28)|(1<<VerilogParserT__29)|(1<<VerilogParserT__30))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(VerilogParserT__31-32))|(1<<(VerilogParserT__32-32))|(1<<(VerilogParserT__33-32))|(1<<(VerilogParserT__34-32))|(1<<(VerilogParserT__35-32))|(1<<(VerilogParserT__36-32))|(1<<(VerilogParserT__37-32))|(1<<(VerilogParserT__40-32))|(1<<(VerilogParserT__41-32))|(1<<(VerilogParserT__42-32))|(1<<(VerilogParserT__43-32))|(1<<(VerilogParserT__44-32))|(1<<(VerilogParserT__45-32))|(1<<(VerilogParserT__46-32))|(1<<(VerilogParserT__47-32))|(1<<(VerilogParserT__48-32))|(1<<(VerilogParserT__49-32)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(VerilogParserT__65-66))|(1<<(VerilogParserT__68-66))|(1<<(VerilogParserT__70-66))|(1<<(VerilogParserT__71-66))|(1<<(VerilogParserT__72-66))|(1<<(VerilogParserT__73-66))|(1<<(VerilogParserT__74-66))|(1<<(VerilogParserT__75-66))|(1<<(VerilogParserT__76-66))|(1<<(VerilogParserT__77-66))|(1<<(VerilogParserT__78-66))|(1<<(VerilogParserT__79-66))|(1<<(VerilogParserT__80-66))|(1<<(VerilogParserT__81-66))|(1<<(VerilogParserT__82-66))|(1<<(VerilogParserT__83-66))|(1<<(VerilogParserT__84-66))|(1<<(VerilogParserT__85-66))|(1<<(VerilogParserT__86-66))|(1<<(VerilogParserT__87-66))|(1<<(VerilogParserT__88-66))|(1<<(VerilogParserT__89-66))|(1<<(VerilogParserT__90-66))|(1<<(VerilogParserT__91-66))|(1<<(VerilogParserT__92-66))|(1<<(VerilogParserT__93-66))|(1<<(VerilogParserT__94-66))|(1<<(VerilogParserT__95-66))|(1<<(VerilogParserT__96-66)))) != 0) || (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(VerilogParserT__105-106))|(1<<(VerilogParserT__106-106))|(1<<(VerilogParserT__107-106))|(1<<(VerilogParserT__126-106)))) != 0) || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(739)
				p.Module_item()
			}

			p.SetState(744)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(745)
			p.Match(VerilogParserT__11)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(747)
				p.Attribute_instance()
			}

			p.SetState(752)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(753)
			p.Module_keyword()
		}
		{
			p.SetState(754)
			p.Module_identifier()
		}
		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(755)
				p.Module_parameter_port_list()
			}

		}
		p.SetState(759)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__15 {
			{
				p.SetState(758)
				p.List_of_port_declarations()
			}

		}
		{
			p.SetState(761)
			p.Match(VerilogParserT__1)
		}
		p.SetState(765)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__15)|(1<<VerilogParserT__22)|(1<<VerilogParserT__23)|(1<<VerilogParserT__25)|(1<<VerilogParserT__26)|(1<<VerilogParserT__27)|(1<<VerilogParserT__28)|(1<<VerilogParserT__29)|(1<<VerilogParserT__30))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(VerilogParserT__34-35))|(1<<(VerilogParserT__35-35))|(1<<(VerilogParserT__36-35))|(1<<(VerilogParserT__37-35))|(1<<(VerilogParserT__40-35))|(1<<(VerilogParserT__41-35))|(1<<(VerilogParserT__42-35))|(1<<(VerilogParserT__43-35))|(1<<(VerilogParserT__44-35))|(1<<(VerilogParserT__45-35))|(1<<(VerilogParserT__46-35))|(1<<(VerilogParserT__47-35))|(1<<(VerilogParserT__48-35))|(1<<(VerilogParserT__49-35))|(1<<(VerilogParserT__65-35)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(VerilogParserT__68-69))|(1<<(VerilogParserT__70-69))|(1<<(VerilogParserT__71-69))|(1<<(VerilogParserT__72-69))|(1<<(VerilogParserT__73-69))|(1<<(VerilogParserT__74-69))|(1<<(VerilogParserT__75-69))|(1<<(VerilogParserT__76-69))|(1<<(VerilogParserT__77-69))|(1<<(VerilogParserT__78-69))|(1<<(VerilogParserT__79-69))|(1<<(VerilogParserT__80-69))|(1<<(VerilogParserT__81-69))|(1<<(VerilogParserT__82-69))|(1<<(VerilogParserT__83-69))|(1<<(VerilogParserT__84-69))|(1<<(VerilogParserT__85-69))|(1<<(VerilogParserT__86-69))|(1<<(VerilogParserT__87-69))|(1<<(VerilogParserT__88-69))|(1<<(VerilogParserT__89-69))|(1<<(VerilogParserT__90-69))|(1<<(VerilogParserT__91-69))|(1<<(VerilogParserT__92-69))|(1<<(VerilogParserT__93-69))|(1<<(VerilogParserT__94-69))|(1<<(VerilogParserT__95-69))|(1<<(VerilogParserT__96-69)))) != 0) || (((_la-106)&-(0x1f+1)) == 0 && ((1<<uint((_la-106)))&((1<<(VerilogParserT__105-106))|(1<<(VerilogParserT__106-106))|(1<<(VerilogParserT__107-106))|(1<<(VerilogParserT__126-106)))) != 0) || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(762)
				p.Non_port_module_item()
			}

			p.SetState(767)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(768)
			p.Match(VerilogParserT__11)
		}

	}

	return localctx
}

// IModule_keywordContext is an interface to support dynamic dispatch.
type IModule_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_keywordContext differentiates from other interfaces.
	IsModule_keywordContext()
}

type Module_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_keywordContext() *Module_keywordContext {
	var p = new(Module_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_keyword
	return p
}

func (*Module_keywordContext) IsModule_keywordContext() {}

func NewModule_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_keywordContext {
	var p = new(Module_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_keyword

	return p
}

func (s *Module_keywordContext) GetParser() antlr.Parser { return s.parser }
func (s *Module_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_keyword(s)
	}
}

func (s *Module_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_keyword(s)
	}
}

func (p *VerilogParser) Module_keyword() (localctx IModule_keywordContext) {
	localctx = NewModule_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, VerilogParserRULE_module_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(772)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserT__12 || _la == VerilogParserT__13) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IModule_parameter_port_listContext is an interface to support dynamic dispatch.
type IModule_parameter_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_parameter_port_listContext differentiates from other interfaces.
	IsModule_parameter_port_listContext()
}

type Module_parameter_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_parameter_port_listContext() *Module_parameter_port_listContext {
	var p = new(Module_parameter_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_parameter_port_list
	return p
}

func (*Module_parameter_port_listContext) IsModule_parameter_port_listContext() {}

func NewModule_parameter_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_parameter_port_listContext {
	var p = new(Module_parameter_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_parameter_port_list

	return p
}

func (s *Module_parameter_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_parameter_port_listContext) AllParameter_declaration_() []IParameter_declaration_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameter_declaration_Context)(nil)).Elem())
	var tst = make([]IParameter_declaration_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameter_declaration_Context)
		}
	}

	return tst
}

func (s *Module_parameter_port_listContext) Parameter_declaration_(i int) IParameter_declaration_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_Context)
}

func (s *Module_parameter_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_parameter_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_parameter_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_parameter_port_list(s)
	}
}

func (s *Module_parameter_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_parameter_port_list(s)
	}
}

func (p *VerilogParser) Module_parameter_port_list() (localctx IModule_parameter_port_listContext) {
	localctx = NewModule_parameter_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, VerilogParserRULE_module_parameter_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(774)
		p.Match(VerilogParserT__14)
	}
	{
		p.SetState(775)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(776)
		p.Parameter_declaration_()
	}
	p.SetState(781)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(777)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(778)
			p.Parameter_declaration_()
		}

		p.SetState(783)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(784)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IList_of_portsContext is an interface to support dynamic dispatch.
type IList_of_portsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_portsContext differentiates from other interfaces.
	IsList_of_portsContext()
}

type List_of_portsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_portsContext() *List_of_portsContext {
	var p = new(List_of_portsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_ports
	return p
}

func (*List_of_portsContext) IsList_of_portsContext() {}

func NewList_of_portsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_portsContext {
	var p = new(List_of_portsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_ports

	return p
}

func (s *List_of_portsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_portsContext) AllPort() []IPortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPortContext)(nil)).Elem())
	var tst = make([]IPortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPortContext)
		}
	}

	return tst
}

func (s *List_of_portsContext) Port(i int) IPortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPortContext)
}

func (s *List_of_portsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_portsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_portsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_ports(s)
	}
}

func (s *List_of_portsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_ports(s)
	}
}

func (p *VerilogParser) List_of_ports() (localctx IList_of_portsContext) {
	localctx = NewList_of_portsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, VerilogParserRULE_list_of_ports)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(786)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(787)
		p.Port()
	}
	p.SetState(792)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(788)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(789)
			p.Port()
		}

		p.SetState(794)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(795)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IList_of_port_declarationsContext is an interface to support dynamic dispatch.
type IList_of_port_declarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_declarationsContext differentiates from other interfaces.
	IsList_of_port_declarationsContext()
}

type List_of_port_declarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_declarationsContext() *List_of_port_declarationsContext {
	var p = new(List_of_port_declarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_port_declarations
	return p
}

func (*List_of_port_declarationsContext) IsList_of_port_declarationsContext() {}

func NewList_of_port_declarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_declarationsContext {
	var p = new(List_of_port_declarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_port_declarations

	return p
}

func (s *List_of_port_declarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_declarationsContext) AllPort_declaration() []IPort_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem())
	var tst = make([]IPort_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_declarationContext)
		}
	}

	return tst
}

func (s *List_of_port_declarationsContext) Port_declaration(i int) IPort_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_declarationContext)
}

func (s *List_of_port_declarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_declarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_declarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_port_declarations(s)
	}
}

func (s *List_of_port_declarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_port_declarations(s)
	}
}

func (p *VerilogParser) List_of_port_declarations() (localctx IList_of_port_declarationsContext) {
	localctx = NewList_of_port_declarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, VerilogParserRULE_list_of_port_declarations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(797)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(798)
			p.Port_declaration()
		}
		p.SetState(803)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(799)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(800)
				p.Port_declaration()
			}

			p.SetState(805)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(806)
			p.Match(VerilogParserT__17)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(808)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(809)
			p.Match(VerilogParserT__17)
		}

	}

	return localctx
}

// IPortContext is an interface to support dynamic dispatch.
type IPortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPortContext differentiates from other interfaces.
	IsPortContext()
}

type PortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPortContext() *PortContext {
	var p = new(PortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port
	return p
}

func (*PortContext) IsPortContext() {}

func NewPortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PortContext {
	var p = new(PortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port

	return p
}

func (s *PortContext) GetParser() antlr.Parser { return s.parser }

func (s *PortContext) Port_expression() IPort_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_expressionContext)
}

func (s *PortContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *PortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPort(s)
	}
}

func (s *PortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPort(s)
	}
}

func (p *VerilogParser) Port() (localctx IPortContext) {
	localctx = NewPortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, VerilogParserRULE_port)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(823)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__16, VerilogParserT__17, VerilogParserT__18, VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(813)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__18 || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(812)
				p.Port_expression()
			}

		}

	case VerilogParserT__4:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(815)
			p.Match(VerilogParserT__4)
		}
		{
			p.SetState(816)
			p.Port_identifier()
		}
		{
			p.SetState(817)
			p.Match(VerilogParserT__15)
		}
		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__18 || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(818)
				p.Port_expression()
			}

		}
		{
			p.SetState(821)
			p.Match(VerilogParserT__17)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPort_expressionContext is an interface to support dynamic dispatch.
type IPort_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_expressionContext differentiates from other interfaces.
	IsPort_expressionContext()
}

type Port_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_expressionContext() *Port_expressionContext {
	var p = new(Port_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port_expression
	return p
}

func (*Port_expressionContext) IsPort_expressionContext() {}

func NewPort_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_expressionContext {
	var p = new(Port_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port_expression

	return p
}

func (s *Port_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_expressionContext) AllPort_reference() []IPort_referenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_referenceContext)(nil)).Elem())
	var tst = make([]IPort_referenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_referenceContext)
		}
	}

	return tst
}

func (s *Port_expressionContext) Port_reference(i int) IPort_referenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_referenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_referenceContext)
}

func (s *Port_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPort_expression(s)
	}
}

func (s *Port_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPort_expression(s)
	}
}

func (p *VerilogParser) Port_expression() (localctx IPort_expressionContext) {
	localctx = NewPort_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, VerilogParserRULE_port_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(837)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(825)
			p.Port_reference()
		}

	case VerilogParserT__18:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(826)
			p.Match(VerilogParserT__18)
		}
		{
			p.SetState(827)
			p.Port_reference()
		}
		p.SetState(832)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(828)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(829)
				p.Port_reference()
			}

			p.SetState(834)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(835)
			p.Match(VerilogParserT__19)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPort_referenceContext is an interface to support dynamic dispatch.
type IPort_referenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_referenceContext differentiates from other interfaces.
	IsPort_referenceContext()
}

type Port_referenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_referenceContext() *Port_referenceContext {
	var p = new(Port_referenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port_reference
	return p
}

func (*Port_referenceContext) IsPort_referenceContext() {}

func NewPort_referenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_referenceContext {
	var p = new(Port_referenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port_reference

	return p
}

func (s *Port_referenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_referenceContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Port_referenceContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Port_referenceContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Port_referenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_referenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_referenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPort_reference(s)
	}
}

func (s *Port_referenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPort_reference(s)
	}
}

func (p *VerilogParser) Port_reference() (localctx IPort_referenceContext) {
	localctx = NewPort_referenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, VerilogParserRULE_port_reference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(839)
			p.Port_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(840)
			p.Port_identifier()
		}
		{
			p.SetState(841)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(842)
			p.Constant_expression()
		}
		{
			p.SetState(843)
			p.Match(VerilogParserT__21)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(845)
			p.Port_identifier()
		}
		{
			p.SetState(846)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(847)
			p.Range_expression()
		}
		{
			p.SetState(848)
			p.Match(VerilogParserT__21)
		}

	}

	return localctx
}

// IPort_declarationContext is an interface to support dynamic dispatch.
type IPort_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_declarationContext differentiates from other interfaces.
	IsPort_declarationContext()
}

type Port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_declarationContext() *Port_declarationContext {
	var p = new(Port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port_declaration
	return p
}

func (*Port_declarationContext) IsPort_declarationContext() {}

func NewPort_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_declarationContext {
	var p = new(Port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port_declaration

	return p
}

func (s *Port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_declarationContext) Inout_declaration() IInout_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_declarationContext)
}

func (s *Port_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Port_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Port_declarationContext) Input_declaration() IInput_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_declarationContext)
}

func (s *Port_declarationContext) Output_declaration() IOutput_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_declarationContext)
}

func (s *Port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPort_declaration(s)
	}
}

func (s *Port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPort_declaration(s)
	}
}

func (p *VerilogParser) Port_declaration() (localctx IPort_declarationContext) {
	localctx = NewPort_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, VerilogParserRULE_port_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(873)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(855)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(852)
				p.Attribute_instance()
			}

			p.SetState(857)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(858)
			p.Inout_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(862)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(859)
				p.Attribute_instance()
			}

			p.SetState(864)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(865)
			p.Input_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(869)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(866)
				p.Attribute_instance()
			}

			p.SetState(871)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(872)
			p.Output_declaration()
		}

	}

	return localctx
}

// IModule_itemContext is an interface to support dynamic dispatch.
type IModule_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_itemContext differentiates from other interfaces.
	IsModule_itemContext()
}

type Module_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_itemContext() *Module_itemContext {
	var p = new(Module_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_item
	return p
}

func (*Module_itemContext) IsModule_itemContext() {}

func NewModule_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_itemContext {
	var p = new(Module_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_item

	return p
}

func (s *Module_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_itemContext) Module_or_generate_item() IModule_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_itemContext)
}

func (s *Module_itemContext) Port_declaration() IPort_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_declarationContext)
}

func (s *Module_itemContext) Generated_instantiation() IGenerated_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerated_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerated_instantiationContext)
}

func (s *Module_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_itemContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Module_itemContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Module_itemContext) Specify_block() ISpecify_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_blockContext)
}

func (s *Module_itemContext) Specparam_declaration() ISpecparam_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_declarationContext)
}

func (s *Module_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_item(s)
	}
}

func (s *Module_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_item(s)
	}
}

func (p *VerilogParser) Module_item() (localctx IModule_itemContext) {
	localctx = NewModule_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, VerilogParserRULE_module_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(875)
			p.Module_or_generate_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(876)
			p.Port_declaration()
		}
		{
			p.SetState(877)
			p.Match(VerilogParserT__1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(882)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(879)
				p.Attribute_instance()
			}

			p.SetState(884)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(885)
			p.Generated_instantiation()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(889)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(886)
				p.Attribute_instance()
			}

			p.SetState(891)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(892)
			p.Local_parameter_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(896)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(893)
				p.Attribute_instance()
			}

			p.SetState(898)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(899)
			p.Parameter_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(903)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(900)
				p.Attribute_instance()
			}

			p.SetState(905)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(906)
			p.Specify_block()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(910)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(907)
				p.Attribute_instance()
			}

			p.SetState(912)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(913)
			p.Specparam_declaration()
		}

	}

	return localctx
}

// IModule_or_generate_itemContext is an interface to support dynamic dispatch.
type IModule_or_generate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_or_generate_itemContext differentiates from other interfaces.
	IsModule_or_generate_itemContext()
}

type Module_or_generate_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_or_generate_itemContext() *Module_or_generate_itemContext {
	var p = new(Module_or_generate_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_or_generate_item
	return p
}

func (*Module_or_generate_itemContext) IsModule_or_generate_itemContext() {}

func NewModule_or_generate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_or_generate_itemContext {
	var p = new(Module_or_generate_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_or_generate_item

	return p
}

func (s *Module_or_generate_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_or_generate_itemContext) Module_or_generate_item_declaration() IModule_or_generate_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_item_declarationContext)
}

func (s *Module_or_generate_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_or_generate_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_or_generate_itemContext) Parameter_override() IParameter_overrideContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_overrideContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_overrideContext)
}

func (s *Module_or_generate_itemContext) Continuous_assign() IContinuous_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinuous_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinuous_assignContext)
}

func (s *Module_or_generate_itemContext) Gate_instantiation() IGate_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instantiationContext)
}

func (s *Module_or_generate_itemContext) Module_instantiation() IModule_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_instantiationContext)
}

func (s *Module_or_generate_itemContext) Initial_construct() IInitial_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitial_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitial_constructContext)
}

func (s *Module_or_generate_itemContext) Always_construct() IAlways_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlways_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlways_constructContext)
}

func (s *Module_or_generate_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_or_generate_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_or_generate_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_or_generate_item(s)
	}
}

func (s *Module_or_generate_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_or_generate_item(s)
	}
}

func (p *VerilogParser) Module_or_generate_item() (localctx IModule_or_generate_itemContext) {
	localctx = NewModule_or_generate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, VerilogParserRULE_module_or_generate_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(965)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(916)
				p.Attribute_instance()
			}

			p.SetState(921)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(922)
			p.Module_or_generate_item_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(926)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(923)
				p.Attribute_instance()
			}

			p.SetState(928)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(929)
			p.Parameter_override()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(933)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(930)
				p.Attribute_instance()
			}

			p.SetState(935)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(936)
			p.Continuous_assign()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(937)
				p.Attribute_instance()
			}

			p.SetState(942)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(943)
			p.Gate_instantiation()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(944)
				p.Attribute_instance()
			}

			p.SetState(949)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(950)
			p.Module_instantiation()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(954)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(951)
				p.Attribute_instance()
			}

			p.SetState(956)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(957)
			p.Initial_construct()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(961)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(958)
				p.Attribute_instance()
			}

			p.SetState(963)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(964)
			p.Always_construct()
		}

	}

	return localctx
}

// INon_port_module_itemContext is an interface to support dynamic dispatch.
type INon_port_module_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_port_module_itemContext differentiates from other interfaces.
	IsNon_port_module_itemContext()
}

type Non_port_module_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_port_module_itemContext() *Non_port_module_itemContext {
	var p = new(Non_port_module_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_non_port_module_item
	return p
}

func (*Non_port_module_itemContext) IsNon_port_module_itemContext() {}

func NewNon_port_module_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_port_module_itemContext {
	var p = new(Non_port_module_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_non_port_module_item

	return p
}

func (s *Non_port_module_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_port_module_itemContext) Generated_instantiation() IGenerated_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerated_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerated_instantiationContext)
}

func (s *Non_port_module_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Non_port_module_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Non_port_module_itemContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Non_port_module_itemContext) Module_or_generate_item() IModule_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_itemContext)
}

func (s *Non_port_module_itemContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Non_port_module_itemContext) Specify_block() ISpecify_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_blockContext)
}

func (s *Non_port_module_itemContext) Specparam_declaration() ISpecparam_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_declarationContext)
}

func (s *Non_port_module_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_port_module_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_port_module_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNon_port_module_item(s)
	}
}

func (s *Non_port_module_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNon_port_module_item(s)
	}
}

func (p *VerilogParser) Non_port_module_item() (localctx INon_port_module_itemContext) {
	localctx = NewNon_port_module_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, VerilogParserRULE_non_port_module_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(970)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(967)
				p.Attribute_instance()
			}

			p.SetState(972)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(973)
			p.Generated_instantiation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(977)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(974)
				p.Attribute_instance()
			}

			p.SetState(979)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(980)
			p.Local_parameter_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(984)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(981)
					p.Attribute_instance()
				}

			}
			p.SetState(986)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())
		}
		{
			p.SetState(987)
			p.Module_or_generate_item()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(991)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(988)
				p.Attribute_instance()
			}

			p.SetState(993)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(994)
			p.Parameter_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(998)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(995)
				p.Attribute_instance()
			}

			p.SetState(1000)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1001)
			p.Specify_block()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1005)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(1002)
				p.Attribute_instance()
			}

			p.SetState(1007)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1008)
			p.Specparam_declaration()
		}

	}

	return localctx
}

// IModule_or_generate_item_declarationContext is an interface to support dynamic dispatch.
type IModule_or_generate_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_or_generate_item_declarationContext differentiates from other interfaces.
	IsModule_or_generate_item_declarationContext()
}

type Module_or_generate_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_or_generate_item_declarationContext() *Module_or_generate_item_declarationContext {
	var p = new(Module_or_generate_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_or_generate_item_declaration
	return p
}

func (*Module_or_generate_item_declarationContext) IsModule_or_generate_item_declarationContext() {}

func NewModule_or_generate_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_or_generate_item_declarationContext {
	var p = new(Module_or_generate_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_or_generate_item_declaration

	return p
}

func (s *Module_or_generate_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_or_generate_item_declarationContext) Net_declaration() INet_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Reg_declaration() IReg_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReg_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReg_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Real_declaration() IReal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Time_declaration() ITime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Realtime_declaration() IRealtime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRealtime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRealtime_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Event_declaration() IEvent_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Genvar_declaration() IGenvar_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Task_declaration() ITask_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Function_declaration() IFunction_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_or_generate_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_or_generate_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_or_generate_item_declaration(s)
	}
}

func (s *Module_or_generate_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_or_generate_item_declaration(s)
	}
}

func (p *VerilogParser) Module_or_generate_item_declaration() (localctx IModule_or_generate_item_declarationContext) {
	localctx = NewModule_or_generate_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, VerilogParserRULE_module_or_generate_item_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1021)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__37, VerilogParserT__40, VerilogParserT__41, VerilogParserT__42, VerilogParserT__43, VerilogParserT__44, VerilogParserT__45, VerilogParserT__46, VerilogParserT__47, VerilogParserT__48, VerilogParserT__49:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1011)
			p.Net_declaration()
		}

	case VerilogParserT__34:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1012)
			p.Reg_declaration()
		}

	case VerilogParserT__25:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1013)
			p.Integer_declaration()
		}

	case VerilogParserT__26:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1014)
			p.Real_declaration()
		}

	case VerilogParserT__28:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1015)
			p.Time_declaration()
		}

	case VerilogParserT__27:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1016)
			p.Realtime_declaration()
		}

	case VerilogParserT__35:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1017)
			p.Event_declaration()
		}

	case VerilogParserT__36:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1018)
			p.Genvar_declaration()
		}

	case VerilogParserT__68:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1019)
			p.Task_declaration()
		}

	case VerilogParserT__65:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1020)
			p.Function_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParameter_overrideContext is an interface to support dynamic dispatch.
type IParameter_overrideContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_overrideContext differentiates from other interfaces.
	IsParameter_overrideContext()
}

type Parameter_overrideContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_overrideContext() *Parameter_overrideContext {
	var p = new(Parameter_overrideContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_override
	return p
}

func (*Parameter_overrideContext) IsParameter_overrideContext() {}

func NewParameter_overrideContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_overrideContext {
	var p = new(Parameter_overrideContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_override

	return p
}

func (s *Parameter_overrideContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_overrideContext) List_of_param_assignments() IList_of_param_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_param_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_param_assignmentsContext)
}

func (s *Parameter_overrideContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_overrideContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_overrideContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterParameter_override(s)
	}
}

func (s *Parameter_overrideContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitParameter_override(s)
	}
}

func (p *VerilogParser) Parameter_override() (localctx IParameter_overrideContext) {
	localctx = NewParameter_overrideContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, VerilogParserRULE_parameter_override)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1023)
		p.Match(VerilogParserT__22)
	}
	{
		p.SetState(1024)
		p.List_of_param_assignments()
	}
	{
		p.SetState(1025)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// ILocal_parameter_declarationContext is an interface to support dynamic dispatch.
type ILocal_parameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocal_parameter_declarationContext differentiates from other interfaces.
	IsLocal_parameter_declarationContext()
}

type Local_parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocal_parameter_declarationContext() *Local_parameter_declarationContext {
	var p = new(Local_parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_local_parameter_declaration
	return p
}

func (*Local_parameter_declarationContext) IsLocal_parameter_declarationContext() {}

func NewLocal_parameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Local_parameter_declarationContext {
	var p = new(Local_parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_local_parameter_declaration

	return p
}

func (s *Local_parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Local_parameter_declarationContext) List_of_param_assignments() IList_of_param_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_param_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_param_assignmentsContext)
}

func (s *Local_parameter_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Local_parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Local_parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Local_parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterLocal_parameter_declaration(s)
	}
}

func (s *Local_parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitLocal_parameter_declaration(s)
	}
}

func (p *VerilogParser) Local_parameter_declaration() (localctx ILocal_parameter_declarationContext) {
	localctx = NewLocal_parameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, VerilogParserRULE_local_parameter_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1057)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1027)
			p.Match(VerilogParserT__23)
		}
		p.SetState(1029)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1028)
				p.Match(VerilogParserT__24)
			}

		}
		p.SetState(1032)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__20 {
			{
				p.SetState(1031)
				p.Range_()
			}

		}
		{
			p.SetState(1034)
			p.List_of_param_assignments()
		}
		{
			p.SetState(1035)
			p.Match(VerilogParserT__1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1037)
			p.Match(VerilogParserT__23)
		}
		{
			p.SetState(1038)
			p.Match(VerilogParserT__25)
		}
		{
			p.SetState(1039)
			p.List_of_param_assignments()
		}
		{
			p.SetState(1040)
			p.Match(VerilogParserT__1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1042)
			p.Match(VerilogParserT__23)
		}
		{
			p.SetState(1043)
			p.Match(VerilogParserT__26)
		}
		{
			p.SetState(1044)
			p.List_of_param_assignments()
		}
		{
			p.SetState(1045)
			p.Match(VerilogParserT__1)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1047)
			p.Match(VerilogParserT__23)
		}
		{
			p.SetState(1048)
			p.Match(VerilogParserT__27)
		}
		{
			p.SetState(1049)
			p.List_of_param_assignments()
		}
		{
			p.SetState(1050)
			p.Match(VerilogParserT__1)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1052)
			p.Match(VerilogParserT__23)
		}
		{
			p.SetState(1053)
			p.Match(VerilogParserT__28)
		}
		{
			p.SetState(1054)
			p.List_of_param_assignments()
		}
		{
			p.SetState(1055)
			p.Match(VerilogParserT__1)
		}

	}

	return localctx
}

// IParameter_declarationContext is an interface to support dynamic dispatch.
type IParameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declarationContext differentiates from other interfaces.
	IsParameter_declarationContext()
}

type Parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declarationContext() *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_declaration
	return p
}

func (*Parameter_declarationContext) IsParameter_declarationContext() {}

func NewParameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_declaration

	return p
}

func (s *Parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declarationContext) Parameter_declaration_() IParameter_declaration_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_Context)
}

func (s *Parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterParameter_declaration(s)
	}
}

func (s *Parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitParameter_declaration(s)
	}
}

func (p *VerilogParser) Parameter_declaration() (localctx IParameter_declarationContext) {
	localctx = NewParameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, VerilogParserRULE_parameter_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1059)
		p.Parameter_declaration_()
	}
	{
		p.SetState(1060)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// IParameter_declaration_Context is an interface to support dynamic dispatch.
type IParameter_declaration_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declaration_Context differentiates from other interfaces.
	IsParameter_declaration_Context()
}

type Parameter_declaration_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declaration_Context() *Parameter_declaration_Context {
	var p = new(Parameter_declaration_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_declaration_
	return p
}

func (*Parameter_declaration_Context) IsParameter_declaration_Context() {}

func NewParameter_declaration_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declaration_Context {
	var p = new(Parameter_declaration_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_declaration_

	return p
}

func (s *Parameter_declaration_Context) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declaration_Context) List_of_param_assignments() IList_of_param_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_param_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_param_assignmentsContext)
}

func (s *Parameter_declaration_Context) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Parameter_declaration_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declaration_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declaration_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterParameter_declaration_(s)
	}
}

func (s *Parameter_declaration_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitParameter_declaration_(s)
	}
}

func (p *VerilogParser) Parameter_declaration_() (localctx IParameter_declaration_Context) {
	localctx = NewParameter_declaration_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, VerilogParserRULE_parameter_declaration_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1082)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1062)
			p.Match(VerilogParserT__29)
		}
		p.SetState(1064)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1063)
				p.Match(VerilogParserT__24)
			}

		}
		p.SetState(1067)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__20 {
			{
				p.SetState(1066)
				p.Range_()
			}

		}
		{
			p.SetState(1069)
			p.List_of_param_assignments()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1070)
			p.Match(VerilogParserT__29)
		}
		{
			p.SetState(1071)
			p.Match(VerilogParserT__25)
		}
		{
			p.SetState(1072)
			p.List_of_param_assignments()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1073)
			p.Match(VerilogParserT__29)
		}
		{
			p.SetState(1074)
			p.Match(VerilogParserT__26)
		}
		{
			p.SetState(1075)
			p.List_of_param_assignments()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1076)
			p.Match(VerilogParserT__29)
		}
		{
			p.SetState(1077)
			p.Match(VerilogParserT__27)
		}
		{
			p.SetState(1078)
			p.List_of_param_assignments()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1079)
			p.Match(VerilogParserT__29)
		}
		{
			p.SetState(1080)
			p.Match(VerilogParserT__28)
		}
		{
			p.SetState(1081)
			p.List_of_param_assignments()
		}

	}

	return localctx
}

// ISpecparam_declarationContext is an interface to support dynamic dispatch.
type ISpecparam_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecparam_declarationContext differentiates from other interfaces.
	IsSpecparam_declarationContext()
}

type Specparam_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecparam_declarationContext() *Specparam_declarationContext {
	var p = new(Specparam_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specparam_declaration
	return p
}

func (*Specparam_declarationContext) IsSpecparam_declarationContext() {}

func NewSpecparam_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specparam_declarationContext {
	var p = new(Specparam_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specparam_declaration

	return p
}

func (s *Specparam_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Specparam_declarationContext) List_of_specparam_assignments() IList_of_specparam_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_specparam_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_specparam_assignmentsContext)
}

func (s *Specparam_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Specparam_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specparam_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specparam_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSpecparam_declaration(s)
	}
}

func (s *Specparam_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSpecparam_declaration(s)
	}
}

func (p *VerilogParser) Specparam_declaration() (localctx ISpecparam_declarationContext) {
	localctx = NewSpecparam_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, VerilogParserRULE_specparam_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1084)
		p.Match(VerilogParserT__30)
	}
	p.SetState(1086)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__20 {
		{
			p.SetState(1085)
			p.Range_()
		}

	}
	{
		p.SetState(1088)
		p.List_of_specparam_assignments()
	}
	{
		p.SetState(1089)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// IInout_declarationContext is an interface to support dynamic dispatch.
type IInout_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_declarationContext differentiates from other interfaces.
	IsInout_declarationContext()
}

type Inout_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_declarationContext() *Inout_declarationContext {
	var p = new(Inout_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inout_declaration
	return p
}

func (*Inout_declarationContext) IsInout_declarationContext() {}

func NewInout_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_declarationContext {
	var p = new(Inout_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inout_declaration

	return p
}

func (s *Inout_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Inout_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Inout_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Inout_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterInout_declaration(s)
	}
}

func (s *Inout_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitInout_declaration(s)
	}
}

func (p *VerilogParser) Inout_declaration() (localctx IInout_declarationContext) {
	localctx = NewInout_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, VerilogParserRULE_inout_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1091)
		p.Match(VerilogParserT__31)
	}
	p.SetState(1093)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(VerilogParserT__40-41))|(1<<(VerilogParserT__41-41))|(1<<(VerilogParserT__42-41))|(1<<(VerilogParserT__43-41))|(1<<(VerilogParserT__44-41))|(1<<(VerilogParserT__45-41))|(1<<(VerilogParserT__46-41))|(1<<(VerilogParserT__47-41))|(1<<(VerilogParserT__48-41))|(1<<(VerilogParserT__49-41)))) != 0 {
		{
			p.SetState(1092)
			p.Net_type()
		}

	}
	p.SetState(1096)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__24 {
		{
			p.SetState(1095)
			p.Match(VerilogParserT__24)
		}

	}
	p.SetState(1099)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__20 {
		{
			p.SetState(1098)
			p.Range_()
		}

	}
	{
		p.SetState(1101)
		p.List_of_port_identifiers()
	}

	return localctx
}

// IInput_declarationContext is an interface to support dynamic dispatch.
type IInput_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_declarationContext differentiates from other interfaces.
	IsInput_declarationContext()
}

type Input_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_declarationContext() *Input_declarationContext {
	var p = new(Input_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_input_declaration
	return p
}

func (*Input_declarationContext) IsInput_declarationContext() {}

func NewInput_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_declarationContext {
	var p = new(Input_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_input_declaration

	return p
}

func (s *Input_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Input_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Input_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Input_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterInput_declaration(s)
	}
}

func (s *Input_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitInput_declaration(s)
	}
}

func (p *VerilogParser) Input_declaration() (localctx IInput_declarationContext) {
	localctx = NewInput_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, VerilogParserRULE_input_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1103)
		p.Match(VerilogParserT__32)
	}
	p.SetState(1105)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(VerilogParserT__40-41))|(1<<(VerilogParserT__41-41))|(1<<(VerilogParserT__42-41))|(1<<(VerilogParserT__43-41))|(1<<(VerilogParserT__44-41))|(1<<(VerilogParserT__45-41))|(1<<(VerilogParserT__46-41))|(1<<(VerilogParserT__47-41))|(1<<(VerilogParserT__48-41))|(1<<(VerilogParserT__49-41)))) != 0 {
		{
			p.SetState(1104)
			p.Net_type()
		}

	}
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__24 {
		{
			p.SetState(1107)
			p.Match(VerilogParserT__24)
		}

	}
	p.SetState(1111)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__20 {
		{
			p.SetState(1110)
			p.Range_()
		}

	}
	{
		p.SetState(1113)
		p.List_of_port_identifiers()
	}

	return localctx
}

// IOutput_declarationContext is an interface to support dynamic dispatch.
type IOutput_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_declarationContext differentiates from other interfaces.
	IsOutput_declarationContext()
}

type Output_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_declarationContext() *Output_declarationContext {
	var p = new(Output_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_declaration
	return p
}

func (*Output_declarationContext) IsOutput_declarationContext() {}

func NewOutput_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_declarationContext {
	var p = new(Output_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_declaration

	return p
}

func (s *Output_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Output_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Output_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Output_declarationContext) List_of_variable_port_identifiers() IList_of_variable_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_port_identifiersContext)
}

func (s *Output_declarationContext) Output_variable_type() IOutput_variable_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_variable_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_variable_typeContext)
}

func (s *Output_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterOutput_declaration(s)
	}
}

func (s *Output_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitOutput_declaration(s)
	}
}

func (p *VerilogParser) Output_declaration() (localctx IOutput_declarationContext) {
	localctx = NewOutput_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, VerilogParserRULE_output_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1155)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1115)
			p.Match(VerilogParserT__33)
		}
		p.SetState(1117)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(VerilogParserT__40-41))|(1<<(VerilogParserT__41-41))|(1<<(VerilogParserT__42-41))|(1<<(VerilogParserT__43-41))|(1<<(VerilogParserT__44-41))|(1<<(VerilogParserT__45-41))|(1<<(VerilogParserT__46-41))|(1<<(VerilogParserT__47-41))|(1<<(VerilogParserT__48-41))|(1<<(VerilogParserT__49-41)))) != 0 {
			{
				p.SetState(1116)
				p.Net_type()
			}

		}
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1119)
				p.Match(VerilogParserT__24)
			}

		}
		p.SetState(1123)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__20 {
			{
				p.SetState(1122)
				p.Range_()
			}

		}
		{
			p.SetState(1125)
			p.List_of_port_identifiers()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1126)
			p.Match(VerilogParserT__33)
		}
		p.SetState(1128)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__34 {
			{
				p.SetState(1127)
				p.Match(VerilogParserT__34)
			}

		}
		p.SetState(1131)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1130)
				p.Match(VerilogParserT__24)
			}

		}
		p.SetState(1134)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__20 {
			{
				p.SetState(1133)
				p.Range_()
			}

		}
		{
			p.SetState(1136)
			p.List_of_port_identifiers()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1137)
			p.Match(VerilogParserT__33)
		}
		{
			p.SetState(1138)
			p.Match(VerilogParserT__34)
		}
		p.SetState(1140)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1139)
				p.Match(VerilogParserT__24)
			}

		}
		p.SetState(1143)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__20 {
			{
				p.SetState(1142)
				p.Range_()
			}

		}
		{
			p.SetState(1145)
			p.List_of_variable_port_identifiers()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1146)
			p.Match(VerilogParserT__33)
		}
		p.SetState(1148)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__25 || _la == VerilogParserT__28 {
			{
				p.SetState(1147)
				p.Output_variable_type()
			}

		}
		{
			p.SetState(1150)
			p.List_of_port_identifiers()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1151)
			p.Match(VerilogParserT__33)
		}
		{
			p.SetState(1152)
			p.Output_variable_type()
		}
		{
			p.SetState(1153)
			p.List_of_variable_port_identifiers()
		}

	}

	return localctx
}

// IEvent_declarationContext is an interface to support dynamic dispatch.
type IEvent_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_declarationContext differentiates from other interfaces.
	IsEvent_declarationContext()
}

type Event_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_declarationContext() *Event_declarationContext {
	var p = new(Event_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_declaration
	return p
}

func (*Event_declarationContext) IsEvent_declarationContext() {}

func NewEvent_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_declarationContext {
	var p = new(Event_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_declaration

	return p
}

func (s *Event_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_declarationContext) List_of_event_identifiers() IList_of_event_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_event_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_event_identifiersContext)
}

func (s *Event_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEvent_declaration(s)
	}
}

func (s *Event_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEvent_declaration(s)
	}
}

func (p *VerilogParser) Event_declaration() (localctx IEvent_declarationContext) {
	localctx = NewEvent_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, VerilogParserRULE_event_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1157)
		p.Match(VerilogParserT__35)
	}
	{
		p.SetState(1158)
		p.List_of_event_identifiers()
	}
	{
		p.SetState(1159)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// IGenvar_declarationContext is an interface to support dynamic dispatch.
type IGenvar_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_declarationContext differentiates from other interfaces.
	IsGenvar_declarationContext()
}

type Genvar_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_declarationContext() *Genvar_declarationContext {
	var p = new(Genvar_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_declaration
	return p
}

func (*Genvar_declarationContext) IsGenvar_declarationContext() {}

func NewGenvar_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_declarationContext {
	var p = new(Genvar_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_declaration

	return p
}

func (s *Genvar_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_declarationContext) List_of_genvar_identifiers() IList_of_genvar_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_genvar_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_genvar_identifiersContext)
}

func (s *Genvar_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenvar_declaration(s)
	}
}

func (s *Genvar_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenvar_declaration(s)
	}
}

func (p *VerilogParser) Genvar_declaration() (localctx IGenvar_declarationContext) {
	localctx = NewGenvar_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, VerilogParserRULE_genvar_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1161)
		p.Match(VerilogParserT__36)
	}
	{
		p.SetState(1162)
		p.List_of_genvar_identifiers()
	}
	{
		p.SetState(1163)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// IInteger_declarationContext is an interface to support dynamic dispatch.
type IInteger_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInteger_declarationContext differentiates from other interfaces.
	IsInteger_declarationContext()
}

type Integer_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_declarationContext() *Integer_declarationContext {
	var p = new(Integer_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_integer_declaration
	return p
}

func (*Integer_declarationContext) IsInteger_declarationContext() {}

func NewInteger_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_declarationContext {
	var p = new(Integer_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_integer_declaration

	return p
}

func (s *Integer_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_declarationContext) List_of_variable_identifiers() IList_of_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_identifiersContext)
}

func (s *Integer_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterInteger_declaration(s)
	}
}

func (s *Integer_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitInteger_declaration(s)
	}
}

func (p *VerilogParser) Integer_declaration() (localctx IInteger_declarationContext) {
	localctx = NewInteger_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, VerilogParserRULE_integer_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1165)
		p.Match(VerilogParserT__25)
	}
	{
		p.SetState(1166)
		p.List_of_variable_identifiers()
	}
	{
		p.SetState(1167)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// ITime_declarationContext is an interface to support dynamic dispatch.
type ITime_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTime_declarationContext differentiates from other interfaces.
	IsTime_declarationContext()
}

type Time_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTime_declarationContext() *Time_declarationContext {
	var p = new(Time_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_time_declaration
	return p
}

func (*Time_declarationContext) IsTime_declarationContext() {}

func NewTime_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Time_declarationContext {
	var p = new(Time_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_time_declaration

	return p
}

func (s *Time_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Time_declarationContext) List_of_variable_identifiers() IList_of_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_identifiersContext)
}

func (s *Time_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Time_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Time_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTime_declaration(s)
	}
}

func (s *Time_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTime_declaration(s)
	}
}

func (p *VerilogParser) Time_declaration() (localctx ITime_declarationContext) {
	localctx = NewTime_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, VerilogParserRULE_time_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1169)
		p.Match(VerilogParserT__28)
	}
	{
		p.SetState(1170)
		p.List_of_variable_identifiers()
	}
	{
		p.SetState(1171)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// IReal_declarationContext is an interface to support dynamic dispatch.
type IReal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_declarationContext differentiates from other interfaces.
	IsReal_declarationContext()
}

type Real_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_declarationContext() *Real_declarationContext {
	var p = new(Real_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_real_declaration
	return p
}

func (*Real_declarationContext) IsReal_declarationContext() {}

func NewReal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_declarationContext {
	var p = new(Real_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_real_declaration

	return p
}

func (s *Real_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_declarationContext) List_of_real_identifiers() IList_of_real_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_real_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_real_identifiersContext)
}

func (s *Real_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterReal_declaration(s)
	}
}

func (s *Real_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitReal_declaration(s)
	}
}

func (p *VerilogParser) Real_declaration() (localctx IReal_declarationContext) {
	localctx = NewReal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, VerilogParserRULE_real_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1173)
		p.Match(VerilogParserT__26)
	}
	{
		p.SetState(1174)
		p.List_of_real_identifiers()
	}
	{
		p.SetState(1175)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// IRealtime_declarationContext is an interface to support dynamic dispatch.
type IRealtime_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRealtime_declarationContext differentiates from other interfaces.
	IsRealtime_declarationContext()
}

type Realtime_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRealtime_declarationContext() *Realtime_declarationContext {
	var p = new(Realtime_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_realtime_declaration
	return p
}

func (*Realtime_declarationContext) IsRealtime_declarationContext() {}

func NewRealtime_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Realtime_declarationContext {
	var p = new(Realtime_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_realtime_declaration

	return p
}

func (s *Realtime_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Realtime_declarationContext) List_of_real_identifiers() IList_of_real_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_real_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_real_identifiersContext)
}

func (s *Realtime_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Realtime_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Realtime_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterRealtime_declaration(s)
	}
}

func (s *Realtime_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitRealtime_declaration(s)
	}
}

func (p *VerilogParser) Realtime_declaration() (localctx IRealtime_declarationContext) {
	localctx = NewRealtime_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, VerilogParserRULE_realtime_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1177)
		p.Match(VerilogParserT__27)
	}
	{
		p.SetState(1178)
		p.List_of_real_identifiers()
	}
	{
		p.SetState(1179)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// IReg_declarationContext is an interface to support dynamic dispatch.
type IReg_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReg_declarationContext differentiates from other interfaces.
	IsReg_declarationContext()
}

type Reg_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReg_declarationContext() *Reg_declarationContext {
	var p = new(Reg_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_reg_declaration
	return p
}

func (*Reg_declarationContext) IsReg_declarationContext() {}

func NewReg_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reg_declarationContext {
	var p = new(Reg_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_reg_declaration

	return p
}

func (s *Reg_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Reg_declarationContext) List_of_variable_identifiers() IList_of_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_identifiersContext)
}

func (s *Reg_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Reg_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reg_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reg_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterReg_declaration(s)
	}
}

func (s *Reg_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitReg_declaration(s)
	}
}

func (p *VerilogParser) Reg_declaration() (localctx IReg_declarationContext) {
	localctx = NewReg_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, VerilogParserRULE_reg_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1181)
		p.Match(VerilogParserT__34)
	}
	p.SetState(1183)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__24 {
		{
			p.SetState(1182)
			p.Match(VerilogParserT__24)
		}

	}
	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__20 {
		{
			p.SetState(1185)
			p.Range_()
		}

	}
	{
		p.SetState(1188)
		p.List_of_variable_identifiers()
	}
	{
		p.SetState(1189)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// INet_declarationContext is an interface to support dynamic dispatch.
type INet_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_declarationContext differentiates from other interfaces.
	IsNet_declarationContext()
}

type Net_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_declarationContext() *Net_declarationContext {
	var p = new(Net_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_declaration
	return p
}

func (*Net_declarationContext) IsNet_declarationContext() {}

func NewNet_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_declarationContext {
	var p = new(Net_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_declaration

	return p
}

func (s *Net_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Net_declarationContext) List_of_net_identifiers() IList_of_net_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_net_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_net_identifiersContext)
}

func (s *Net_declarationContext) Delay3() IDelay3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay3Context)
}

func (s *Net_declarationContext) List_of_net_decl_assignments() IList_of_net_decl_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_net_decl_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_net_decl_assignmentsContext)
}

func (s *Net_declarationContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Net_declarationContext) Charge_strength() ICharge_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharge_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharge_strengthContext)
}

func (s *Net_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Net_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNet_declaration(s)
	}
}

func (s *Net_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNet_declaration(s)
	}
}

func (p *VerilogParser) Net_declaration() (localctx INet_declarationContext) {
	localctx = NewNet_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, VerilogParserRULE_net_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1305)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1191)
			p.Net_type()
		}
		p.SetState(1193)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1192)
				p.Match(VerilogParserT__24)
			}

		}
		p.SetState(1196)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1195)
				p.Delay3()
			}

		}
		{
			p.SetState(1198)
			p.List_of_net_identifiers()
		}
		{
			p.SetState(1199)
			p.Match(VerilogParserT__1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1201)
			p.Net_type()
		}
		p.SetState(1203)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__15 {
			{
				p.SetState(1202)
				p.Drive_strength()
			}

		}
		p.SetState(1206)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1205)
				p.Match(VerilogParserT__24)
			}

		}
		p.SetState(1209)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1208)
				p.Delay3()
			}

		}
		{
			p.SetState(1211)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(1212)
			p.Match(VerilogParserT__1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1214)
			p.Match(VerilogParserT__37)
		}
		p.SetState(1216)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__15 {
			{
				p.SetState(1215)
				p.Drive_strength()
			}

		}
		p.SetState(1219)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1218)
				p.Match(VerilogParserT__24)
			}

		}
		p.SetState(1222)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1221)
				p.Delay3()
			}

		}
		{
			p.SetState(1224)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(1225)
			p.Match(VerilogParserT__1)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1227)
			p.Match(VerilogParserT__37)
		}
		p.SetState(1229)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__15 {
			{
				p.SetState(1228)
				p.Charge_strength()
			}

		}
		p.SetState(1232)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1231)
				p.Match(VerilogParserT__24)
			}

		}
		p.SetState(1235)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1234)
				p.Delay3()
			}

		}
		{
			p.SetState(1237)
			p.List_of_net_identifiers()
		}
		{
			p.SetState(1238)
			p.Match(VerilogParserT__1)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1240)
			p.Match(VerilogParserT__37)
		}
		p.SetState(1242)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__15 {
			{
				p.SetState(1241)
				p.Charge_strength()
			}

		}
		p.SetState(1245)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__38 || _la == VerilogParserT__39 {
			{
				p.SetState(1244)
				_la = p.GetTokenStream().LA(1)

				if !(_la == VerilogParserT__38 || _la == VerilogParserT__39) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1247)
				p.Match(VerilogParserT__24)
			}

		}
		{
			p.SetState(1250)
			p.Range_()
		}
		p.SetState(1252)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1251)
				p.Delay3()
			}

		}
		{
			p.SetState(1254)
			p.List_of_net_identifiers()
		}
		{
			p.SetState(1255)
			p.Match(VerilogParserT__1)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1257)
			p.Match(VerilogParserT__37)
		}
		p.SetState(1259)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__15 {
			{
				p.SetState(1258)
				p.Drive_strength()
			}

		}
		p.SetState(1262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__38 || _la == VerilogParserT__39 {
			{
				p.SetState(1261)
				_la = p.GetTokenStream().LA(1)

				if !(_la == VerilogParserT__38 || _la == VerilogParserT__39) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1265)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1264)
				p.Match(VerilogParserT__24)
			}

		}
		{
			p.SetState(1267)
			p.Range_()
		}
		p.SetState(1269)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1268)
				p.Delay3()
			}

		}
		{
			p.SetState(1271)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(1272)
			p.Match(VerilogParserT__1)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1274)
			p.Net_type()
		}
		p.SetState(1276)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__15 {
			{
				p.SetState(1275)
				p.Drive_strength()
			}

		}
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__38 || _la == VerilogParserT__39 {
			{
				p.SetState(1278)
				_la = p.GetTokenStream().LA(1)

				if !(_la == VerilogParserT__38 || _la == VerilogParserT__39) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1282)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1281)
				p.Match(VerilogParserT__24)
			}

		}
		{
			p.SetState(1284)
			p.Range_()
		}
		p.SetState(1286)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1285)
				p.Delay3()
			}

		}
		{
			p.SetState(1288)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(1289)
			p.Match(VerilogParserT__1)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1291)
			p.Net_type()
		}
		p.SetState(1293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__38 || _la == VerilogParserT__39 {
			{
				p.SetState(1292)
				_la = p.GetTokenStream().LA(1)

				if !(_la == VerilogParserT__38 || _la == VerilogParserT__39) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1295)
				p.Match(VerilogParserT__24)
			}

		}
		{
			p.SetState(1298)
			p.Range_()
		}
		p.SetState(1300)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1299)
				p.Delay3()
			}

		}
		{
			p.SetState(1302)
			p.List_of_net_identifiers()
		}
		{
			p.SetState(1303)
			p.Match(VerilogParserT__1)
		}

	}

	return localctx
}

// INet_typeContext is an interface to support dynamic dispatch.
type INet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_typeContext differentiates from other interfaces.
	IsNet_typeContext()
}

type Net_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_typeContext() *Net_typeContext {
	var p = new(Net_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_type
	return p
}

func (*Net_typeContext) IsNet_typeContext() {}

func NewNet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_typeContext {
	var p = new(Net_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_type

	return p
}

func (s *Net_typeContext) GetParser() antlr.Parser { return s.parser }
func (s *Net_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNet_type(s)
	}
}

func (s *Net_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNet_type(s)
	}
}

func (p *VerilogParser) Net_type() (localctx INet_typeContext) {
	localctx = NewNet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, VerilogParserRULE_net_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1307)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(VerilogParserT__40-41))|(1<<(VerilogParserT__41-41))|(1<<(VerilogParserT__42-41))|(1<<(VerilogParserT__43-41))|(1<<(VerilogParserT__44-41))|(1<<(VerilogParserT__45-41))|(1<<(VerilogParserT__46-41))|(1<<(VerilogParserT__47-41))|(1<<(VerilogParserT__48-41))|(1<<(VerilogParserT__49-41)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOutput_variable_typeContext is an interface to support dynamic dispatch.
type IOutput_variable_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_variable_typeContext differentiates from other interfaces.
	IsOutput_variable_typeContext()
}

type Output_variable_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_variable_typeContext() *Output_variable_typeContext {
	var p = new(Output_variable_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_variable_type
	return p
}

func (*Output_variable_typeContext) IsOutput_variable_typeContext() {}

func NewOutput_variable_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_variable_typeContext {
	var p = new(Output_variable_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_variable_type

	return p
}

func (s *Output_variable_typeContext) GetParser() antlr.Parser { return s.parser }
func (s *Output_variable_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_variable_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_variable_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterOutput_variable_type(s)
	}
}

func (s *Output_variable_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitOutput_variable_type(s)
	}
}

func (p *VerilogParser) Output_variable_type() (localctx IOutput_variable_typeContext) {
	localctx = NewOutput_variable_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, VerilogParserRULE_output_variable_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1309)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserT__25 || _la == VerilogParserT__28) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReal_typeContext is an interface to support dynamic dispatch.
type IReal_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_typeContext differentiates from other interfaces.
	IsReal_typeContext()
}

type Real_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_typeContext() *Real_typeContext {
	var p = new(Real_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_real_type
	return p
}

func (*Real_typeContext) IsReal_typeContext() {}

func NewReal_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_typeContext {
	var p = new(Real_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_real_type

	return p
}

func (s *Real_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_typeContext) Real_identifier() IReal_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_identifierContext)
}

func (s *Real_typeContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Real_typeContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *Real_typeContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Real_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterReal_type(s)
	}
}

func (s *Real_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitReal_type(s)
	}
}

func (p *VerilogParser) Real_type() (localctx IReal_typeContext) {
	localctx = NewReal_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, VerilogParserRULE_real_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1324)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1311)
			p.Real_identifier()
		}
		p.SetState(1314)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__50 {
			{
				p.SetState(1312)
				p.Match(VerilogParserT__50)
			}
			{
				p.SetState(1313)
				p.Constant_expression()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1316)
			p.Real_identifier()
		}
		{
			p.SetState(1317)
			p.Dimension()
		}
		p.SetState(1321)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__20 {
			{
				p.SetState(1318)
				p.Dimension()
			}

			p.SetState(1323)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IVariable_typeContext is an interface to support dynamic dispatch.
type IVariable_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_typeContext differentiates from other interfaces.
	IsVariable_typeContext()
}

type Variable_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_typeContext() *Variable_typeContext {
	var p = new(Variable_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_type
	return p
}

func (*Variable_typeContext) IsVariable_typeContext() {}

func NewVariable_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_typeContext {
	var p = new(Variable_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_type

	return p
}

func (s *Variable_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_typeContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Variable_typeContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Variable_typeContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *Variable_typeContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Variable_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterVariable_type(s)
	}
}

func (s *Variable_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitVariable_type(s)
	}
}

func (p *VerilogParser) Variable_type() (localctx IVariable_typeContext) {
	localctx = NewVariable_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, VerilogParserRULE_variable_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1339)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1326)
			p.Variable_identifier()
		}
		p.SetState(1329)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__50 {
			{
				p.SetState(1327)
				p.Match(VerilogParserT__50)
			}
			{
				p.SetState(1328)
				p.Constant_expression()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1331)
			p.Variable_identifier()
		}
		{
			p.SetState(1332)
			p.Dimension()
		}
		p.SetState(1336)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__20 {
			{
				p.SetState(1333)
				p.Dimension()
			}

			p.SetState(1338)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IDrive_strengthContext is an interface to support dynamic dispatch.
type IDrive_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrive_strengthContext differentiates from other interfaces.
	IsDrive_strengthContext()
}

type Drive_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrive_strengthContext() *Drive_strengthContext {
	var p = new(Drive_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_drive_strength
	return p
}

func (*Drive_strengthContext) IsDrive_strengthContext() {}

func NewDrive_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drive_strengthContext {
	var p = new(Drive_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_drive_strength

	return p
}

func (s *Drive_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Drive_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Drive_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Drive_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drive_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drive_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDrive_strength(s)
	}
}

func (s *Drive_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDrive_strength(s)
	}
}

func (p *VerilogParser) Drive_strength() (localctx IDrive_strengthContext) {
	localctx = NewDrive_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, VerilogParserRULE_drive_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1377)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1341)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1342)
			p.Strength0()
		}
		{
			p.SetState(1343)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1344)
			p.Strength1()
		}
		{
			p.SetState(1345)
			p.Match(VerilogParserT__17)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1347)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1348)
			p.Strength1()
		}
		{
			p.SetState(1349)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1350)
			p.Strength0()
		}
		{
			p.SetState(1351)
			p.Match(VerilogParserT__17)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1353)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1354)
			p.Strength0()
		}
		{
			p.SetState(1355)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1356)
			p.Match(VerilogParserT__51)
		}
		{
			p.SetState(1357)
			p.Match(VerilogParserT__17)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1359)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1360)
			p.Strength1()
		}
		{
			p.SetState(1361)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1362)
			p.Match(VerilogParserT__52)
		}
		{
			p.SetState(1363)
			p.Match(VerilogParserT__17)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1365)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1366)
			p.Match(VerilogParserT__52)
		}
		{
			p.SetState(1367)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1368)
			p.Strength1()
		}
		{
			p.SetState(1369)
			p.Match(VerilogParserT__17)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1371)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1372)
			p.Match(VerilogParserT__51)
		}
		{
			p.SetState(1373)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1374)
			p.Strength0()
		}
		{
			p.SetState(1375)
			p.Match(VerilogParserT__17)
		}

	}

	return localctx
}

// IStrength0Context is an interface to support dynamic dispatch.
type IStrength0Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrength0Context differentiates from other interfaces.
	IsStrength0Context()
}

type Strength0Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrength0Context() *Strength0Context {
	var p = new(Strength0Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_strength0
	return p
}

func (*Strength0Context) IsStrength0Context() {}

func NewStrength0Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Strength0Context {
	var p = new(Strength0Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_strength0

	return p
}

func (s *Strength0Context) GetParser() antlr.Parser { return s.parser }
func (s *Strength0Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Strength0Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Strength0Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterStrength0(s)
	}
}

func (s *Strength0Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitStrength0(s)
	}
}

func (p *VerilogParser) Strength0() (localctx IStrength0Context) {
	localctx = NewStrength0Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, VerilogParserRULE_strength0)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1379)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(VerilogParserT__40-41))|(1<<(VerilogParserT__53-41))|(1<<(VerilogParserT__54-41))|(1<<(VerilogParserT__55-41)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStrength1Context is an interface to support dynamic dispatch.
type IStrength1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrength1Context differentiates from other interfaces.
	IsStrength1Context()
}

type Strength1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrength1Context() *Strength1Context {
	var p = new(Strength1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_strength1
	return p
}

func (*Strength1Context) IsStrength1Context() {}

func NewStrength1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Strength1Context {
	var p = new(Strength1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_strength1

	return p
}

func (s *Strength1Context) GetParser() antlr.Parser { return s.parser }
func (s *Strength1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Strength1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Strength1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterStrength1(s)
	}
}

func (s *Strength1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitStrength1(s)
	}
}

func (p *VerilogParser) Strength1() (localctx IStrength1Context) {
	localctx = NewStrength1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, VerilogParserRULE_strength1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1381)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(VerilogParserT__41-42))|(1<<(VerilogParserT__56-42))|(1<<(VerilogParserT__57-42))|(1<<(VerilogParserT__58-42)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICharge_strengthContext is an interface to support dynamic dispatch.
type ICharge_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharge_strengthContext differentiates from other interfaces.
	IsCharge_strengthContext()
}

type Charge_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharge_strengthContext() *Charge_strengthContext {
	var p = new(Charge_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_charge_strength
	return p
}

func (*Charge_strengthContext) IsCharge_strengthContext() {}

func NewCharge_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Charge_strengthContext {
	var p = new(Charge_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_charge_strength

	return p
}

func (s *Charge_strengthContext) GetParser() antlr.Parser { return s.parser }
func (s *Charge_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Charge_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Charge_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterCharge_strength(s)
	}
}

func (s *Charge_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitCharge_strength(s)
	}
}

func (p *VerilogParser) Charge_strength() (localctx ICharge_strengthContext) {
	localctx = NewCharge_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, VerilogParserRULE_charge_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1392)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1383)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1384)
			p.Match(VerilogParserT__59)
		}
		{
			p.SetState(1385)
			p.Match(VerilogParserT__17)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1386)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1387)
			p.Match(VerilogParserT__60)
		}
		{
			p.SetState(1388)
			p.Match(VerilogParserT__17)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1389)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1390)
			p.Match(VerilogParserT__61)
		}
		{
			p.SetState(1391)
			p.Match(VerilogParserT__17)
		}

	}

	return localctx
}

// IDelay3Context is an interface to support dynamic dispatch.
type IDelay3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay3Context differentiates from other interfaces.
	IsDelay3Context()
}

type Delay3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay3Context() *Delay3Context {
	var p = new(Delay3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay3
	return p
}

func (*Delay3Context) IsDelay3Context() {}

func NewDelay3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay3Context {
	var p = new(Delay3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay3

	return p
}

func (s *Delay3Context) GetParser() antlr.Parser { return s.parser }

func (s *Delay3Context) AllDelay_value() []IDelay_valueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem())
	var tst = make([]IDelay_valueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDelay_valueContext)
		}
	}

	return tst
}

func (s *Delay3Context) Delay_value(i int) IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Delay3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDelay3(s)
	}
}

func (s *Delay3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDelay3(s)
	}
}

func (p *VerilogParser) Delay3() (localctx IDelay3Context) {
	localctx = NewDelay3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, VerilogParserRULE_delay3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1409)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1394)
			p.Match(VerilogParserT__14)
		}
		{
			p.SetState(1395)
			p.Delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1396)
			p.Match(VerilogParserT__14)
		}
		{
			p.SetState(1397)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1398)
			p.Delay_value()
		}
		p.SetState(1405)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__16 {
			{
				p.SetState(1399)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1400)
				p.Delay_value()
			}
			p.SetState(1403)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == VerilogParserT__16 {
				{
					p.SetState(1401)
					p.Match(VerilogParserT__16)
				}
				{
					p.SetState(1402)
					p.Delay_value()
				}

			}

		}
		{
			p.SetState(1407)
			p.Match(VerilogParserT__17)
		}

	}

	return localctx
}

// IDelay2Context is an interface to support dynamic dispatch.
type IDelay2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay2Context differentiates from other interfaces.
	IsDelay2Context()
}

type Delay2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay2Context() *Delay2Context {
	var p = new(Delay2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay2
	return p
}

func (*Delay2Context) IsDelay2Context() {}

func NewDelay2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay2Context {
	var p = new(Delay2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay2

	return p
}

func (s *Delay2Context) GetParser() antlr.Parser { return s.parser }

func (s *Delay2Context) AllDelay_value() []IDelay_valueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem())
	var tst = make([]IDelay_valueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDelay_valueContext)
		}
	}

	return tst
}

func (s *Delay2Context) Delay_value(i int) IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Delay2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDelay2(s)
	}
}

func (s *Delay2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDelay2(s)
	}
}

func (p *VerilogParser) Delay2() (localctx IDelay2Context) {
	localctx = NewDelay2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, VerilogParserRULE_delay2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1422)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1411)
			p.Match(VerilogParserT__14)
		}
		{
			p.SetState(1412)
			p.Delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1413)
			p.Match(VerilogParserT__14)
		}
		{
			p.SetState(1414)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1415)
			p.Delay_value()
		}
		p.SetState(1418)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__16 {
			{
				p.SetState(1416)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1417)
				p.Delay_value()
			}

		}
		{
			p.SetState(1420)
			p.Match(VerilogParserT__17)
		}

	}

	return localctx
}

// IDelay_valueContext is an interface to support dynamic dispatch.
type IDelay_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_valueContext differentiates from other interfaces.
	IsDelay_valueContext()
}

type Delay_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_valueContext() *Delay_valueContext {
	var p = new(Delay_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay_value
	return p
}

func (*Delay_valueContext) IsDelay_valueContext() {}

func NewDelay_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_valueContext {
	var p = new(Delay_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay_value

	return p
}

func (s *Delay_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_valueContext) Decimal_number() antlr.TerminalNode {
	return s.GetToken(VerilogParserDecimal_number, 0)
}

func (s *Delay_valueContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Delay_valueContext) Specparam_identifier() ISpecparam_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_identifierContext)
}

func (s *Delay_valueContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Delay_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDelay_value(s)
	}
}

func (s *Delay_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDelay_value(s)
	}
}

func (p *VerilogParser) Delay_value() (localctx IDelay_valueContext) {
	localctx = NewDelay_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, VerilogParserRULE_delay_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1428)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1424)
			p.Match(VerilogParserDecimal_number)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1425)
			p.Parameter_identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1426)
			p.Specparam_identifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1427)
			p.Mintypmax_expression()
		}

	}

	return localctx
}

// IList_of_event_identifiersContext is an interface to support dynamic dispatch.
type IList_of_event_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_event_identifiersContext differentiates from other interfaces.
	IsList_of_event_identifiersContext()
}

type List_of_event_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_event_identifiersContext() *List_of_event_identifiersContext {
	var p = new(List_of_event_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_event_identifiers
	return p
}

func (*List_of_event_identifiersContext) IsList_of_event_identifiersContext() {}

func NewList_of_event_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_event_identifiersContext {
	var p = new(List_of_event_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_event_identifiers

	return p
}

func (s *List_of_event_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_event_identifiersContext) AllEvent_identifier() []IEvent_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvent_identifierContext)(nil)).Elem())
	var tst = make([]IEvent_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvent_identifierContext)
		}
	}

	return tst
}

func (s *List_of_event_identifiersContext) Event_identifier(i int) IEvent_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvent_identifierContext)
}

func (s *List_of_event_identifiersContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *List_of_event_identifiersContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *List_of_event_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_event_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_event_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_event_identifiers(s)
	}
}

func (s *List_of_event_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_event_identifiers(s)
	}
}

func (p *VerilogParser) List_of_event_identifiers() (localctx IList_of_event_identifiersContext) {
	localctx = NewList_of_event_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, VerilogParserRULE_list_of_event_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1430)
		p.Event_identifier()
	}
	p.SetState(1438)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__20 {
		{
			p.SetState(1431)
			p.Dimension()
		}
		p.SetState(1435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__20 {
			{
				p.SetState(1432)
				p.Dimension()
			}

			p.SetState(1437)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1453)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(1440)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1441)
			p.Event_identifier()
		}
		p.SetState(1449)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__20 {
			{
				p.SetState(1442)
				p.Dimension()
			}
			p.SetState(1446)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == VerilogParserT__20 {
				{
					p.SetState(1443)
					p.Dimension()
				}

				p.SetState(1448)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

		p.SetState(1455)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_net_identifiersContext is an interface to support dynamic dispatch.
type IList_of_net_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_net_identifiersContext differentiates from other interfaces.
	IsList_of_net_identifiersContext()
}

type List_of_net_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_net_identifiersContext() *List_of_net_identifiersContext {
	var p = new(List_of_net_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_net_identifiers
	return p
}

func (*List_of_net_identifiersContext) IsList_of_net_identifiersContext() {}

func NewList_of_net_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_net_identifiersContext {
	var p = new(List_of_net_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_net_identifiers

	return p
}

func (s *List_of_net_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_net_identifiersContext) AllNet_identifier() []INet_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_identifierContext)(nil)).Elem())
	var tst = make([]INet_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_identifierContext)
		}
	}

	return tst
}

func (s *List_of_net_identifiersContext) Net_identifier(i int) INet_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_identifierContext)
}

func (s *List_of_net_identifiersContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *List_of_net_identifiersContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *List_of_net_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_net_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_net_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_net_identifiers(s)
	}
}

func (s *List_of_net_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_net_identifiers(s)
	}
}

func (p *VerilogParser) List_of_net_identifiers() (localctx IList_of_net_identifiersContext) {
	localctx = NewList_of_net_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, VerilogParserRULE_list_of_net_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1456)
		p.Net_identifier()
	}
	p.SetState(1464)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__20 {
		{
			p.SetState(1457)
			p.Dimension()
		}
		p.SetState(1461)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__20 {
			{
				p.SetState(1458)
				p.Dimension()
			}

			p.SetState(1463)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1479)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(1466)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1467)
			p.Net_identifier()
		}
		p.SetState(1475)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__20 {
			{
				p.SetState(1468)
				p.Dimension()
			}
			p.SetState(1472)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == VerilogParserT__20 {
				{
					p.SetState(1469)
					p.Dimension()
				}

				p.SetState(1474)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

		p.SetState(1481)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_genvar_identifiersContext is an interface to support dynamic dispatch.
type IList_of_genvar_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_genvar_identifiersContext differentiates from other interfaces.
	IsList_of_genvar_identifiersContext()
}

type List_of_genvar_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_genvar_identifiersContext() *List_of_genvar_identifiersContext {
	var p = new(List_of_genvar_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_genvar_identifiers
	return p
}

func (*List_of_genvar_identifiersContext) IsList_of_genvar_identifiersContext() {}

func NewList_of_genvar_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_genvar_identifiersContext {
	var p = new(List_of_genvar_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_genvar_identifiers

	return p
}

func (s *List_of_genvar_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_genvar_identifiersContext) AllGenvar_identifier() []IGenvar_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem())
	var tst = make([]IGenvar_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenvar_identifierContext)
		}
	}

	return tst
}

func (s *List_of_genvar_identifiersContext) Genvar_identifier(i int) IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *List_of_genvar_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_genvar_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_genvar_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_genvar_identifiers(s)
	}
}

func (s *List_of_genvar_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_genvar_identifiers(s)
	}
}

func (p *VerilogParser) List_of_genvar_identifiers() (localctx IList_of_genvar_identifiersContext) {
	localctx = NewList_of_genvar_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, VerilogParserRULE_list_of_genvar_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1482)
		p.Genvar_identifier()
	}
	p.SetState(1487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(1483)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1484)
			p.Genvar_identifier()
		}

		p.SetState(1489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_port_identifiersContext is an interface to support dynamic dispatch.
type IList_of_port_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_identifiersContext differentiates from other interfaces.
	IsList_of_port_identifiersContext()
}

type List_of_port_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_identifiersContext() *List_of_port_identifiersContext {
	var p = new(List_of_port_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_port_identifiers
	return p
}

func (*List_of_port_identifiersContext) IsList_of_port_identifiersContext() {}

func NewList_of_port_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_identifiersContext {
	var p = new(List_of_port_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_port_identifiers

	return p
}

func (s *List_of_port_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_identifiersContext) AllPort_identifier() []IPort_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem())
	var tst = make([]IPort_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_identifierContext)
		}
	}

	return tst
}

func (s *List_of_port_identifiersContext) Port_identifier(i int) IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *List_of_port_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_port_identifiers(s)
	}
}

func (s *List_of_port_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_port_identifiers(s)
	}
}

func (p *VerilogParser) List_of_port_identifiers() (localctx IList_of_port_identifiersContext) {
	localctx = NewList_of_port_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, VerilogParserRULE_list_of_port_identifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1490)
		p.Port_identifier()
	}
	p.SetState(1495)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1491)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1492)
				p.Port_identifier()
			}

		}
		p.SetState(1497)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext())
	}

	return localctx
}

// IList_of_net_decl_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_net_decl_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_net_decl_assignmentsContext differentiates from other interfaces.
	IsList_of_net_decl_assignmentsContext()
}

type List_of_net_decl_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_net_decl_assignmentsContext() *List_of_net_decl_assignmentsContext {
	var p = new(List_of_net_decl_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_net_decl_assignments
	return p
}

func (*List_of_net_decl_assignmentsContext) IsList_of_net_decl_assignmentsContext() {}

func NewList_of_net_decl_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_net_decl_assignmentsContext {
	var p = new(List_of_net_decl_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_net_decl_assignments

	return p
}

func (s *List_of_net_decl_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_net_decl_assignmentsContext) AllNet_decl_assignment() []INet_decl_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_decl_assignmentContext)(nil)).Elem())
	var tst = make([]INet_decl_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_decl_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_net_decl_assignmentsContext) Net_decl_assignment(i int) INet_decl_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_decl_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_decl_assignmentContext)
}

func (s *List_of_net_decl_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_net_decl_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_net_decl_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_net_decl_assignments(s)
	}
}

func (s *List_of_net_decl_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_net_decl_assignments(s)
	}
}

func (p *VerilogParser) List_of_net_decl_assignments() (localctx IList_of_net_decl_assignmentsContext) {
	localctx = NewList_of_net_decl_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, VerilogParserRULE_list_of_net_decl_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1498)
		p.Net_decl_assignment()
	}
	p.SetState(1503)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(1499)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1500)
			p.Net_decl_assignment()
		}

		p.SetState(1505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_param_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_param_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_param_assignmentsContext differentiates from other interfaces.
	IsList_of_param_assignmentsContext()
}

type List_of_param_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_param_assignmentsContext() *List_of_param_assignmentsContext {
	var p = new(List_of_param_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_param_assignments
	return p
}

func (*List_of_param_assignmentsContext) IsList_of_param_assignmentsContext() {}

func NewList_of_param_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_param_assignmentsContext {
	var p = new(List_of_param_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_param_assignments

	return p
}

func (s *List_of_param_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_param_assignmentsContext) AllParam_assignment() []IParam_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParam_assignmentContext)(nil)).Elem())
	var tst = make([]IParam_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParam_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_param_assignmentsContext) Param_assignment(i int) IParam_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParam_assignmentContext)
}

func (s *List_of_param_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_param_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_param_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_param_assignments(s)
	}
}

func (s *List_of_param_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_param_assignments(s)
	}
}

func (p *VerilogParser) List_of_param_assignments() (localctx IList_of_param_assignmentsContext) {
	localctx = NewList_of_param_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, VerilogParserRULE_list_of_param_assignments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1506)
		p.Param_assignment()
	}
	p.SetState(1511)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1507)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1508)
				p.Param_assignment()
			}

		}
		p.SetState(1513)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())
	}

	return localctx
}

// IList_of_specparam_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_specparam_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_specparam_assignmentsContext differentiates from other interfaces.
	IsList_of_specparam_assignmentsContext()
}

type List_of_specparam_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_specparam_assignmentsContext() *List_of_specparam_assignmentsContext {
	var p = new(List_of_specparam_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_specparam_assignments
	return p
}

func (*List_of_specparam_assignmentsContext) IsList_of_specparam_assignmentsContext() {}

func NewList_of_specparam_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_specparam_assignmentsContext {
	var p = new(List_of_specparam_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_specparam_assignments

	return p
}

func (s *List_of_specparam_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_specparam_assignmentsContext) AllSpecparam_assignment() []ISpecparam_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecparam_assignmentContext)(nil)).Elem())
	var tst = make([]ISpecparam_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecparam_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_specparam_assignmentsContext) Specparam_assignment(i int) ISpecparam_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_assignmentContext)
}

func (s *List_of_specparam_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_specparam_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_specparam_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_specparam_assignments(s)
	}
}

func (s *List_of_specparam_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_specparam_assignments(s)
	}
}

func (p *VerilogParser) List_of_specparam_assignments() (localctx IList_of_specparam_assignmentsContext) {
	localctx = NewList_of_specparam_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, VerilogParserRULE_list_of_specparam_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1514)
		p.Specparam_assignment()
	}
	p.SetState(1519)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(1515)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1516)
			p.Specparam_assignment()
		}

		p.SetState(1521)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_real_identifiersContext is an interface to support dynamic dispatch.
type IList_of_real_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_real_identifiersContext differentiates from other interfaces.
	IsList_of_real_identifiersContext()
}

type List_of_real_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_real_identifiersContext() *List_of_real_identifiersContext {
	var p = new(List_of_real_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_real_identifiers
	return p
}

func (*List_of_real_identifiersContext) IsList_of_real_identifiersContext() {}

func NewList_of_real_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_real_identifiersContext {
	var p = new(List_of_real_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_real_identifiers

	return p
}

func (s *List_of_real_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_real_identifiersContext) AllReal_type() []IReal_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReal_typeContext)(nil)).Elem())
	var tst = make([]IReal_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReal_typeContext)
		}
	}

	return tst
}

func (s *List_of_real_identifiersContext) Real_type(i int) IReal_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReal_typeContext)
}

func (s *List_of_real_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_real_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_real_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_real_identifiers(s)
	}
}

func (s *List_of_real_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_real_identifiers(s)
	}
}

func (p *VerilogParser) List_of_real_identifiers() (localctx IList_of_real_identifiersContext) {
	localctx = NewList_of_real_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, VerilogParserRULE_list_of_real_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1522)
		p.Real_type()
	}
	p.SetState(1527)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(1523)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1524)
			p.Real_type()
		}

		p.SetState(1529)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_variable_identifiersContext is an interface to support dynamic dispatch.
type IList_of_variable_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_variable_identifiersContext differentiates from other interfaces.
	IsList_of_variable_identifiersContext()
}

type List_of_variable_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_variable_identifiersContext() *List_of_variable_identifiersContext {
	var p = new(List_of_variable_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_variable_identifiers
	return p
}

func (*List_of_variable_identifiersContext) IsList_of_variable_identifiersContext() {}

func NewList_of_variable_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_variable_identifiersContext {
	var p = new(List_of_variable_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_variable_identifiers

	return p
}

func (s *List_of_variable_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_variable_identifiersContext) AllVariable_type() []IVariable_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_typeContext)(nil)).Elem())
	var tst = make([]IVariable_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_typeContext)
		}
	}

	return tst
}

func (s *List_of_variable_identifiersContext) Variable_type(i int) IVariable_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_typeContext)
}

func (s *List_of_variable_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_variable_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_variable_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_variable_identifiers(s)
	}
}

func (s *List_of_variable_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_variable_identifiers(s)
	}
}

func (p *VerilogParser) List_of_variable_identifiers() (localctx IList_of_variable_identifiersContext) {
	localctx = NewList_of_variable_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, VerilogParserRULE_list_of_variable_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1530)
		p.Variable_type()
	}
	p.SetState(1535)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(1531)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1532)
			p.Variable_type()
		}

		p.SetState(1537)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_variable_port_identifiersContext is an interface to support dynamic dispatch.
type IList_of_variable_port_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_variable_port_identifiersContext differentiates from other interfaces.
	IsList_of_variable_port_identifiersContext()
}

type List_of_variable_port_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_variable_port_identifiersContext() *List_of_variable_port_identifiersContext {
	var p = new(List_of_variable_port_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_variable_port_identifiers
	return p
}

func (*List_of_variable_port_identifiersContext) IsList_of_variable_port_identifiersContext() {}

func NewList_of_variable_port_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_variable_port_identifiersContext {
	var p = new(List_of_variable_port_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_variable_port_identifiers

	return p
}

func (s *List_of_variable_port_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_variable_port_identifiersContext) AllPort_identifier() []IPort_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem())
	var tst = make([]IPort_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_identifierContext)
		}
	}

	return tst
}

func (s *List_of_variable_port_identifiersContext) Port_identifier(i int) IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *List_of_variable_port_identifiersContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *List_of_variable_port_identifiersContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *List_of_variable_port_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_variable_port_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_variable_port_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_variable_port_identifiers(s)
	}
}

func (s *List_of_variable_port_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_variable_port_identifiers(s)
	}
}

func (p *VerilogParser) List_of_variable_port_identifiers() (localctx IList_of_variable_port_identifiersContext) {
	localctx = NewList_of_variable_port_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, VerilogParserRULE_list_of_variable_port_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1538)
		p.Port_identifier()
	}
	p.SetState(1541)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__50 {
		{
			p.SetState(1539)
			p.Match(VerilogParserT__50)
		}
		{
			p.SetState(1540)
			p.Constant_expression()
		}

	}
	p.SetState(1551)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1543)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1544)
				p.Port_identifier()
			}
			p.SetState(1547)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == VerilogParserT__50 {
				{
					p.SetState(1545)
					p.Match(VerilogParserT__50)
				}
				{
					p.SetState(1546)
					p.Constant_expression()
				}

			}

		}
		p.SetState(1553)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext())
	}

	return localctx
}

// INet_decl_assignmentContext is an interface to support dynamic dispatch.
type INet_decl_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_decl_assignmentContext differentiates from other interfaces.
	IsNet_decl_assignmentContext()
}

type Net_decl_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_decl_assignmentContext() *Net_decl_assignmentContext {
	var p = new(Net_decl_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_decl_assignment
	return p
}

func (*Net_decl_assignmentContext) IsNet_decl_assignmentContext() {}

func NewNet_decl_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_decl_assignmentContext {
	var p = new(Net_decl_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_decl_assignment

	return p
}

func (s *Net_decl_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_decl_assignmentContext) Net_identifier() INet_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_identifierContext)
}

func (s *Net_decl_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Net_decl_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_decl_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_decl_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNet_decl_assignment(s)
	}
}

func (s *Net_decl_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNet_decl_assignment(s)
	}
}

func (p *VerilogParser) Net_decl_assignment() (localctx INet_decl_assignmentContext) {
	localctx = NewNet_decl_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, VerilogParserRULE_net_decl_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1554)
		p.Net_identifier()
	}
	{
		p.SetState(1555)
		p.Match(VerilogParserT__50)
	}
	{
		p.SetState(1556)
		p.Expression()
	}

	return localctx
}

// IParam_assignmentContext is an interface to support dynamic dispatch.
type IParam_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_assignmentContext differentiates from other interfaces.
	IsParam_assignmentContext()
}

type Param_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_assignmentContext() *Param_assignmentContext {
	var p = new(Param_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_param_assignment
	return p
}

func (*Param_assignmentContext) IsParam_assignmentContext() {}

func NewParam_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_assignmentContext {
	var p = new(Param_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_param_assignment

	return p
}

func (s *Param_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_assignmentContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Param_assignmentContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Param_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterParam_assignment(s)
	}
}

func (s *Param_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitParam_assignment(s)
	}
}

func (p *VerilogParser) Param_assignment() (localctx IParam_assignmentContext) {
	localctx = NewParam_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, VerilogParserRULE_param_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1558)
		p.Parameter_identifier()
	}
	{
		p.SetState(1559)
		p.Match(VerilogParserT__50)
	}
	{
		p.SetState(1560)
		p.Constant_expression()
	}

	return localctx
}

// ISpecparam_assignmentContext is an interface to support dynamic dispatch.
type ISpecparam_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecparam_assignmentContext differentiates from other interfaces.
	IsSpecparam_assignmentContext()
}

type Specparam_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecparam_assignmentContext() *Specparam_assignmentContext {
	var p = new(Specparam_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specparam_assignment
	return p
}

func (*Specparam_assignmentContext) IsSpecparam_assignmentContext() {}

func NewSpecparam_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specparam_assignmentContext {
	var p = new(Specparam_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specparam_assignment

	return p
}

func (s *Specparam_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Specparam_assignmentContext) Specparam_identifier() ISpecparam_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_identifierContext)
}

func (s *Specparam_assignmentContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Specparam_assignmentContext) Pulse_control_specparam() IPulse_control_specparamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulse_control_specparamContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulse_control_specparamContext)
}

func (s *Specparam_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specparam_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specparam_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSpecparam_assignment(s)
	}
}

func (s *Specparam_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSpecparam_assignment(s)
	}
}

func (p *VerilogParser) Specparam_assignment() (localctx ISpecparam_assignmentContext) {
	localctx = NewSpecparam_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, VerilogParserRULE_specparam_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1567)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1562)
			p.Specparam_identifier()
		}
		{
			p.SetState(1563)
			p.Match(VerilogParserT__50)
		}
		{
			p.SetState(1564)
			p.Constant_mintypmax_expression()
		}

	case VerilogParserT__62:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1566)
			p.Pulse_control_specparam()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPulse_control_specparamContext is an interface to support dynamic dispatch.
type IPulse_control_specparamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulse_control_specparamContext differentiates from other interfaces.
	IsPulse_control_specparamContext()
}

type Pulse_control_specparamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulse_control_specparamContext() *Pulse_control_specparamContext {
	var p = new(Pulse_control_specparamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pulse_control_specparam
	return p
}

func (*Pulse_control_specparamContext) IsPulse_control_specparamContext() {}

func NewPulse_control_specparamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulse_control_specparamContext {
	var p = new(Pulse_control_specparamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pulse_control_specparam

	return p
}

func (s *Pulse_control_specparamContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulse_control_specparamContext) Reject_limit_value() IReject_limit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReject_limit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReject_limit_valueContext)
}

func (s *Pulse_control_specparamContext) Error_limit_value() IError_limit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IError_limit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IError_limit_valueContext)
}

func (s *Pulse_control_specparamContext) Specify_input_terminal_descriptor() ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *Pulse_control_specparamContext) Specify_output_terminal_descriptor() ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *Pulse_control_specparamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulse_control_specparamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulse_control_specparamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPulse_control_specparam(s)
	}
}

func (s *Pulse_control_specparamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPulse_control_specparam(s)
	}
}

func (p *VerilogParser) Pulse_control_specparam() (localctx IPulse_control_specparamContext) {
	localctx = NewPulse_control_specparamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, VerilogParserRULE_pulse_control_specparam)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1594)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1569)
			p.Match(VerilogParserT__62)
		}
		{
			p.SetState(1570)
			p.Match(VerilogParserT__50)
		}
		{
			p.SetState(1571)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1572)
			p.Reject_limit_value()
		}
		p.SetState(1575)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__16 {
			{
				p.SetState(1573)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1574)
				p.Error_limit_value()
			}

		}
		{
			p.SetState(1577)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(1578)
			p.Match(VerilogParserT__1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1580)
			p.Match(VerilogParserT__62)
		}
		{
			p.SetState(1581)
			p.Specify_input_terminal_descriptor()
		}
		{
			p.SetState(1582)
			p.Match(VerilogParserT__63)
		}
		{
			p.SetState(1583)
			p.Specify_output_terminal_descriptor()
		}
		{
			p.SetState(1584)
			p.Match(VerilogParserT__50)
		}
		{
			p.SetState(1585)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1586)
			p.Reject_limit_value()
		}
		p.SetState(1589)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__16 {
			{
				p.SetState(1587)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1588)
				p.Error_limit_value()
			}

		}
		{
			p.SetState(1591)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(1592)
			p.Match(VerilogParserT__1)
		}

	}

	return localctx
}

// IError_limit_valueContext is an interface to support dynamic dispatch.
type IError_limit_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsError_limit_valueContext differentiates from other interfaces.
	IsError_limit_valueContext()
}

type Error_limit_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyError_limit_valueContext() *Error_limit_valueContext {
	var p = new(Error_limit_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_error_limit_value
	return p
}

func (*Error_limit_valueContext) IsError_limit_valueContext() {}

func NewError_limit_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Error_limit_valueContext {
	var p = new(Error_limit_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_error_limit_value

	return p
}

func (s *Error_limit_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Error_limit_valueContext) Limit_value() ILimit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimit_valueContext)
}

func (s *Error_limit_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Error_limit_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Error_limit_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterError_limit_value(s)
	}
}

func (s *Error_limit_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitError_limit_value(s)
	}
}

func (p *VerilogParser) Error_limit_value() (localctx IError_limit_valueContext) {
	localctx = NewError_limit_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, VerilogParserRULE_error_limit_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1596)
		p.Limit_value()
	}

	return localctx
}

// IReject_limit_valueContext is an interface to support dynamic dispatch.
type IReject_limit_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReject_limit_valueContext differentiates from other interfaces.
	IsReject_limit_valueContext()
}

type Reject_limit_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReject_limit_valueContext() *Reject_limit_valueContext {
	var p = new(Reject_limit_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_reject_limit_value
	return p
}

func (*Reject_limit_valueContext) IsReject_limit_valueContext() {}

func NewReject_limit_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reject_limit_valueContext {
	var p = new(Reject_limit_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_reject_limit_value

	return p
}

func (s *Reject_limit_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Reject_limit_valueContext) Limit_value() ILimit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimit_valueContext)
}

func (s *Reject_limit_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reject_limit_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reject_limit_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterReject_limit_value(s)
	}
}

func (s *Reject_limit_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitReject_limit_value(s)
	}
}

func (p *VerilogParser) Reject_limit_value() (localctx IReject_limit_valueContext) {
	localctx = NewReject_limit_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, VerilogParserRULE_reject_limit_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1598)
		p.Limit_value()
	}

	return localctx
}

// ILimit_valueContext is an interface to support dynamic dispatch.
type ILimit_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimit_valueContext differentiates from other interfaces.
	IsLimit_valueContext()
}

type Limit_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimit_valueContext() *Limit_valueContext {
	var p = new(Limit_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_limit_value
	return p
}

func (*Limit_valueContext) IsLimit_valueContext() {}

func NewLimit_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Limit_valueContext {
	var p = new(Limit_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_limit_value

	return p
}

func (s *Limit_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Limit_valueContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Limit_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Limit_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Limit_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterLimit_value(s)
	}
}

func (s *Limit_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitLimit_value(s)
	}
}

func (p *VerilogParser) Limit_value() (localctx ILimit_valueContext) {
	localctx = NewLimit_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, VerilogParserRULE_limit_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1600)
		p.Constant_mintypmax_expression()
	}

	return localctx
}

// IDimensionContext is an interface to support dynamic dispatch.
type IDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimensionContext differentiates from other interfaces.
	IsDimensionContext()
}

type DimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimensionContext() *DimensionContext {
	var p = new(DimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dimension
	return p
}

func (*DimensionContext) IsDimensionContext() {}

func NewDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimensionContext {
	var p = new(DimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dimension

	return p
}

func (s *DimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *DimensionContext) AllDimension_constant_expression() []IDimension_constant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimension_constant_expressionContext)(nil)).Elem())
	var tst = make([]IDimension_constant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimension_constant_expressionContext)
		}
	}

	return tst
}

func (s *DimensionContext) Dimension_constant_expression(i int) IDimension_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_constant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimension_constant_expressionContext)
}

func (s *DimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDimension(s)
	}
}

func (s *DimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDimension(s)
	}
}

func (p *VerilogParser) Dimension() (localctx IDimensionContext) {
	localctx = NewDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, VerilogParserRULE_dimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1602)
		p.Match(VerilogParserT__20)
	}
	{
		p.SetState(1603)
		p.Dimension_constant_expression()
	}
	{
		p.SetState(1604)
		p.Match(VerilogParserT__64)
	}
	{
		p.SetState(1605)
		p.Dimension_constant_expression()
	}
	{
		p.SetState(1606)
		p.Match(VerilogParserT__21)
	}

	return localctx
}

// IRange_Context is an interface to support dynamic dispatch.
type IRange_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_Context differentiates from other interfaces.
	IsRange_Context()
}

type Range_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_Context() *Range_Context {
	var p = new(Range_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_range_
	return p
}

func (*Range_Context) IsRange_Context() {}

func NewRange_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_Context {
	var p = new(Range_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_range_

	return p
}

func (s *Range_Context) GetParser() antlr.Parser { return s.parser }

func (s *Range_Context) Msb_constant_expression() IMsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMsb_constant_expressionContext)
}

func (s *Range_Context) Lsb_constant_expression() ILsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILsb_constant_expressionContext)
}

func (s *Range_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterRange_(s)
	}
}

func (s *Range_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitRange_(s)
	}
}

func (p *VerilogParser) Range_() (localctx IRange_Context) {
	localctx = NewRange_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, VerilogParserRULE_range_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1608)
		p.Match(VerilogParserT__20)
	}
	{
		p.SetState(1609)
		p.Msb_constant_expression()
	}
	{
		p.SetState(1610)
		p.Match(VerilogParserT__64)
	}
	{
		p.SetState(1611)
		p.Lsb_constant_expression()
	}
	{
		p.SetState(1612)
		p.Match(VerilogParserT__21)
	}

	return localctx
}

// IFunction_declarationContext is an interface to support dynamic dispatch.
type IFunction_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_declarationContext differentiates from other interfaces.
	IsFunction_declarationContext()
}

type Function_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_declarationContext() *Function_declarationContext {
	var p = new(Function_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_declaration
	return p
}

func (*Function_declarationContext) IsFunction_declarationContext() {}

func NewFunction_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_declarationContext {
	var p = new(Function_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_declaration

	return p
}

func (s *Function_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_declarationContext) Function_identifier() IFunction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_identifierContext)
}

func (s *Function_declarationContext) Range_or_type() IRange_or_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_or_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_or_typeContext)
}

func (s *Function_declarationContext) AllFunction_item_declaration() []IFunction_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_item_declarationContext)(nil)).Elem())
	var tst = make([]IFunction_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_item_declarationContext)
		}
	}

	return tst
}

func (s *Function_declarationContext) Function_item_declaration(i int) IFunction_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_item_declarationContext)
}

func (s *Function_declarationContext) Function_statement() IFunction_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_statementContext)
}

func (s *Function_declarationContext) Function_port_list() IFunction_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_port_listContext)
}

func (s *Function_declarationContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Function_declarationContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Function_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_declaration(s)
	}
}

func (s *Function_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_declaration(s)
	}
}

func (p *VerilogParser) Function_declaration() (localctx IFunction_declarationContext) {
	localctx = NewFunction_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, VerilogParserRULE_function_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1663)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1614)
			p.Match(VerilogParserT__65)
		}
		p.SetState(1616)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__66 {
			{
				p.SetState(1615)
				p.Match(VerilogParserT__66)
			}

		}
		p.SetState(1619)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1618)
				p.Match(VerilogParserT__24)
			}

		}
		p.SetState(1622)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__20)|(1<<VerilogParserT__25)|(1<<VerilogParserT__26)|(1<<VerilogParserT__27)|(1<<VerilogParserT__28))) != 0 {
			{
				p.SetState(1621)
				p.Range_or_type()
			}

		}
		{
			p.SetState(1624)
			p.Function_identifier()
		}
		{
			p.SetState(1625)
			p.Match(VerilogParserT__1)
		}
		p.SetState(1629)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1626)
					p.Function_item_declaration()
				}

			}
			p.SetState(1631)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())
		}
		p.SetState(1633)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__15 || _la == VerilogParserT__18 || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(VerilogParserT__98-99))|(1<<(VerilogParserT__100-99))|(1<<(VerilogParserT__102-99))|(1<<(VerilogParserT__103-99))|(1<<(VerilogParserT__114-99))|(1<<(VerilogParserT__115-99))|(1<<(VerilogParserT__122-99))|(1<<(VerilogParserT__123-99))|(1<<(VerilogParserT__124-99))|(1<<(VerilogParserT__125-99)))) != 0) || (((_la-176)&-(0x1f+1)) == 0 && ((1<<uint((_la-176)))&((1<<(VerilogParserEscaped_identifier-176))|(1<<(VerilogParserSimple_identifier-176))|(1<<(VerilogParserDollar_Identifier-176)))) != 0) {
			{
				p.SetState(1632)
				p.Function_statement()
			}

		}
		{
			p.SetState(1635)
			p.Match(VerilogParserT__67)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1637)
			p.Match(VerilogParserT__65)
		}
		p.SetState(1639)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__66 {
			{
				p.SetState(1638)
				p.Match(VerilogParserT__66)
			}

		}
		p.SetState(1642)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1641)
				p.Match(VerilogParserT__24)
			}

		}
		p.SetState(1645)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__20)|(1<<VerilogParserT__25)|(1<<VerilogParserT__26)|(1<<VerilogParserT__27)|(1<<VerilogParserT__28))) != 0 {
			{
				p.SetState(1644)
				p.Range_or_type()
			}

		}
		{
			p.SetState(1647)
			p.Function_identifier()
		}
		{
			p.SetState(1648)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(1649)
			p.Function_port_list()
		}
		{
			p.SetState(1650)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(1651)
			p.Match(VerilogParserT__1)
		}
		p.SetState(1655)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1652)
					p.Block_item_declaration()
				}

			}
			p.SetState(1657)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext())
		}
		p.SetState(1659)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__15 || _la == VerilogParserT__18 || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(VerilogParserT__98-99))|(1<<(VerilogParserT__100-99))|(1<<(VerilogParserT__102-99))|(1<<(VerilogParserT__103-99))|(1<<(VerilogParserT__114-99))|(1<<(VerilogParserT__115-99))|(1<<(VerilogParserT__122-99))|(1<<(VerilogParserT__123-99))|(1<<(VerilogParserT__124-99))|(1<<(VerilogParserT__125-99)))) != 0) || (((_la-176)&-(0x1f+1)) == 0 && ((1<<uint((_la-176)))&((1<<(VerilogParserEscaped_identifier-176))|(1<<(VerilogParserSimple_identifier-176))|(1<<(VerilogParserDollar_Identifier-176)))) != 0) {
			{
				p.SetState(1658)
				p.Function_statement()
			}

		}
		{
			p.SetState(1661)
			p.Match(VerilogParserT__67)
		}

	}

	return localctx
}

// IFunction_item_declarationContext is an interface to support dynamic dispatch.
type IFunction_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_item_declarationContext differentiates from other interfaces.
	IsFunction_item_declarationContext()
}

type Function_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_item_declarationContext() *Function_item_declarationContext {
	var p = new(Function_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_item_declaration
	return p
}

func (*Function_item_declarationContext) IsFunction_item_declarationContext() {}

func NewFunction_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_item_declarationContext {
	var p = new(Function_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_item_declaration

	return p
}

func (s *Function_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_item_declarationContext) Block_item_declaration() IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Function_item_declarationContext) Tf_declaration() ITf_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_declarationContext)
}

func (s *Function_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_item_declaration(s)
	}
}

func (s *Function_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_item_declaration(s)
	}
}

func (p *VerilogParser) Function_item_declaration() (localctx IFunction_item_declarationContext) {
	localctx = NewFunction_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, VerilogParserRULE_function_item_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1669)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__15, VerilogParserT__23, VerilogParserT__25, VerilogParserT__26, VerilogParserT__27, VerilogParserT__28, VerilogParserT__29, VerilogParserT__34, VerilogParserT__35:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1665)
			p.Block_item_declaration()
		}

	case VerilogParserT__31, VerilogParserT__32, VerilogParserT__33:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1666)
			p.Tf_declaration()
		}
		{
			p.SetState(1667)
			p.Match(VerilogParserT__1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_port_listContext is an interface to support dynamic dispatch.
type IFunction_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_port_listContext differentiates from other interfaces.
	IsFunction_port_listContext()
}

type Function_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_port_listContext() *Function_port_listContext {
	var p = new(Function_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_port_list
	return p
}

func (*Function_port_listContext) IsFunction_port_listContext() {}

func NewFunction_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_port_listContext {
	var p = new(Function_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_port_list

	return p
}

func (s *Function_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_port_listContext) AllFunction_port() []IFunction_portContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_portContext)(nil)).Elem())
	var tst = make([]IFunction_portContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_portContext)
		}
	}

	return tst
}

func (s *Function_port_listContext) Function_port(i int) IFunction_portContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_portContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_portContext)
}

func (s *Function_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_port_list(s)
	}
}

func (s *Function_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_port_list(s)
	}
}

func (p *VerilogParser) Function_port_list() (localctx IFunction_port_listContext) {
	localctx = NewFunction_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, VerilogParserRULE_function_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1671)
		p.Function_port()
	}
	p.SetState(1676)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(1672)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1673)
			p.Function_port()
		}

		p.SetState(1678)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunction_portContext is an interface to support dynamic dispatch.
type IFunction_portContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_portContext differentiates from other interfaces.
	IsFunction_portContext()
}

type Function_portContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_portContext() *Function_portContext {
	var p = new(Function_portContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_port
	return p
}

func (*Function_portContext) IsFunction_portContext() {}

func NewFunction_portContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_portContext {
	var p = new(Function_portContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_port

	return p
}

func (s *Function_portContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_portContext) Tf_declaration() ITf_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_declarationContext)
}

func (s *Function_portContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Function_portContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Function_portContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_portContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_portContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_port(s)
	}
}

func (s *Function_portContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_port(s)
	}
}

func (p *VerilogParser) Function_port() (localctx IFunction_portContext) {
	localctx = NewFunction_portContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, VerilogParserRULE_function_port)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1682)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__15 {
		{
			p.SetState(1679)
			p.Attribute_instance()
		}

		p.SetState(1684)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1685)
		p.Tf_declaration()
	}

	return localctx
}

// IRange_or_typeContext is an interface to support dynamic dispatch.
type IRange_or_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_or_typeContext differentiates from other interfaces.
	IsRange_or_typeContext()
}

type Range_or_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_or_typeContext() *Range_or_typeContext {
	var p = new(Range_or_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_range_or_type
	return p
}

func (*Range_or_typeContext) IsRange_or_typeContext() {}

func NewRange_or_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_or_typeContext {
	var p = new(Range_or_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_range_or_type

	return p
}

func (s *Range_or_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_or_typeContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Range_or_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_or_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_or_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterRange_or_type(s)
	}
}

func (s *Range_or_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitRange_or_type(s)
	}
}

func (p *VerilogParser) Range_or_type() (localctx IRange_or_typeContext) {
	localctx = NewRange_or_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, VerilogParserRULE_range_or_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1692)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__20:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1687)
			p.Range_()
		}

	case VerilogParserT__25:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1688)
			p.Match(VerilogParserT__25)
		}

	case VerilogParserT__26:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1689)
			p.Match(VerilogParserT__26)
		}

	case VerilogParserT__27:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1690)
			p.Match(VerilogParserT__27)
		}

	case VerilogParserT__28:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1691)
			p.Match(VerilogParserT__28)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITask_declarationContext is an interface to support dynamic dispatch.
type ITask_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_declarationContext differentiates from other interfaces.
	IsTask_declarationContext()
}

type Task_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_declarationContext() *Task_declarationContext {
	var p = new(Task_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_declaration
	return p
}

func (*Task_declarationContext) IsTask_declarationContext() {}

func NewTask_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_declarationContext {
	var p = new(Task_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_declaration

	return p
}

func (s *Task_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_declarationContext) Task_identifier() ITask_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_identifierContext)
}

func (s *Task_declarationContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Task_declarationContext) AllTask_item_declaration() []ITask_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITask_item_declarationContext)(nil)).Elem())
	var tst = make([]ITask_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITask_item_declarationContext)
		}
	}

	return tst
}

func (s *Task_declarationContext) Task_item_declaration(i int) ITask_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITask_item_declarationContext)
}

func (s *Task_declarationContext) Task_port_list() ITask_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_port_listContext)
}

func (s *Task_declarationContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Task_declarationContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Task_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTask_declaration(s)
	}
}

func (s *Task_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTask_declaration(s)
	}
}

func (p *VerilogParser) Task_declaration() (localctx ITask_declarationContext) {
	localctx = NewTask_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, VerilogParserRULE_task_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1729)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1694)
			p.Match(VerilogParserT__68)
		}
		p.SetState(1696)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__66 {
			{
				p.SetState(1695)
				p.Match(VerilogParserT__66)
			}

		}
		{
			p.SetState(1698)
			p.Task_identifier()
		}
		{
			p.SetState(1699)
			p.Match(VerilogParserT__1)
		}
		p.SetState(1703)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1700)
					p.Task_item_declaration()
				}

			}
			p.SetState(1705)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext())
		}
		{
			p.SetState(1706)
			p.Statement()
		}
		{
			p.SetState(1707)
			p.Match(VerilogParserT__69)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1709)
			p.Match(VerilogParserT__68)
		}
		p.SetState(1711)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__66 {
			{
				p.SetState(1710)
				p.Match(VerilogParserT__66)
			}

		}
		{
			p.SetState(1713)
			p.Task_identifier()
		}
		{
			p.SetState(1714)
			p.Match(VerilogParserT__15)
		}
		p.SetState(1716)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-16)&-(0x1f+1)) == 0 && ((1<<uint((_la-16)))&((1<<(VerilogParserT__15-16))|(1<<(VerilogParserT__31-16))|(1<<(VerilogParserT__32-16))|(1<<(VerilogParserT__33-16)))) != 0 {
			{
				p.SetState(1715)
				p.Task_port_list()
			}

		}
		{
			p.SetState(1718)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(1719)
			p.Match(VerilogParserT__1)
		}
		p.SetState(1723)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1720)
					p.Block_item_declaration()
				}

			}
			p.SetState(1725)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())
		}
		{
			p.SetState(1726)
			p.Statement()
		}
		{
			p.SetState(1727)
			p.Match(VerilogParserT__69)
		}

	}

	return localctx
}

// ITask_item_declarationContext is an interface to support dynamic dispatch.
type ITask_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_item_declarationContext differentiates from other interfaces.
	IsTask_item_declarationContext()
}

type Task_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_item_declarationContext() *Task_item_declarationContext {
	var p = new(Task_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_item_declaration
	return p
}

func (*Task_item_declarationContext) IsTask_item_declarationContext() {}

func NewTask_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_item_declarationContext {
	var p = new(Task_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_item_declaration

	return p
}

func (s *Task_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_item_declarationContext) Block_item_declaration() IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Task_item_declarationContext) Tf_declaration() ITf_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_declarationContext)
}

func (s *Task_item_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Task_item_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Task_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTask_item_declaration(s)
	}
}

func (s *Task_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTask_item_declaration(s)
	}
}

func (p *VerilogParser) Task_item_declaration() (localctx ITask_item_declarationContext) {
	localctx = NewTask_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, VerilogParserRULE_task_item_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1741)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1731)
			p.Block_item_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1735)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(1732)
				p.Attribute_instance()
			}

			p.SetState(1737)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1738)
			p.Tf_declaration()
		}
		{
			p.SetState(1739)
			p.Match(VerilogParserT__1)
		}

	}

	return localctx
}

// ITask_port_listContext is an interface to support dynamic dispatch.
type ITask_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_port_listContext differentiates from other interfaces.
	IsTask_port_listContext()
}

type Task_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_port_listContext() *Task_port_listContext {
	var p = new(Task_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_port_list
	return p
}

func (*Task_port_listContext) IsTask_port_listContext() {}

func NewTask_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_port_listContext {
	var p = new(Task_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_port_list

	return p
}

func (s *Task_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_port_listContext) AllTask_port_item() []ITask_port_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITask_port_itemContext)(nil)).Elem())
	var tst = make([]ITask_port_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITask_port_itemContext)
		}
	}

	return tst
}

func (s *Task_port_listContext) Task_port_item(i int) ITask_port_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_port_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITask_port_itemContext)
}

func (s *Task_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTask_port_list(s)
	}
}

func (s *Task_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTask_port_list(s)
	}
}

func (p *VerilogParser) Task_port_list() (localctx ITask_port_listContext) {
	localctx = NewTask_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, VerilogParserRULE_task_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1743)
		p.Task_port_item()
	}
	p.SetState(1748)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(1744)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1745)
			p.Task_port_item()
		}

		p.SetState(1750)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITask_port_itemContext is an interface to support dynamic dispatch.
type ITask_port_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_port_itemContext differentiates from other interfaces.
	IsTask_port_itemContext()
}

type Task_port_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_port_itemContext() *Task_port_itemContext {
	var p = new(Task_port_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_port_item
	return p
}

func (*Task_port_itemContext) IsTask_port_itemContext() {}

func NewTask_port_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_port_itemContext {
	var p = new(Task_port_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_port_item

	return p
}

func (s *Task_port_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_port_itemContext) Tf_declaration() ITf_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_declarationContext)
}

func (s *Task_port_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Task_port_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Task_port_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_port_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_port_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTask_port_item(s)
	}
}

func (s *Task_port_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTask_port_item(s)
	}
}

func (p *VerilogParser) Task_port_item() (localctx ITask_port_itemContext) {
	localctx = NewTask_port_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, VerilogParserRULE_task_port_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1754)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__15 {
		{
			p.SetState(1751)
			p.Attribute_instance()
		}

		p.SetState(1756)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1757)
		p.Tf_declaration()
	}

	return localctx
}

// ITf_decl_headerContext is an interface to support dynamic dispatch.
type ITf_decl_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_decl_headerContext differentiates from other interfaces.
	IsTf_decl_headerContext()
}

type Tf_decl_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_decl_headerContext() *Tf_decl_headerContext {
	var p = new(Tf_decl_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tf_decl_header
	return p
}

func (*Tf_decl_headerContext) IsTf_decl_headerContext() {}

func NewTf_decl_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_decl_headerContext {
	var p = new(Tf_decl_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tf_decl_header

	return p
}

func (s *Tf_decl_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_decl_headerContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Tf_decl_headerContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Tf_decl_headerContext) Task_port_type() ITask_port_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_port_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_port_typeContext)
}

func (s *Tf_decl_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_decl_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_decl_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTf_decl_header(s)
	}
}

func (s *Tf_decl_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTf_decl_header(s)
	}
}

func (p *VerilogParser) Tf_decl_header() (localctx ITf_decl_headerContext) {
	localctx = NewTf_decl_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, VerilogParserRULE_tf_decl_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1779)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1759)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(VerilogParserT__31-32))|(1<<(VerilogParserT__32-32))|(1<<(VerilogParserT__33-32)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1761)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(VerilogParserT__40-41))|(1<<(VerilogParserT__41-41))|(1<<(VerilogParserT__42-41))|(1<<(VerilogParserT__43-41))|(1<<(VerilogParserT__44-41))|(1<<(VerilogParserT__45-41))|(1<<(VerilogParserT__46-41))|(1<<(VerilogParserT__47-41))|(1<<(VerilogParserT__48-41))|(1<<(VerilogParserT__49-41)))) != 0 {
			{
				p.SetState(1760)
				p.Net_type()
			}

		}
		p.SetState(1764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__34 {
			{
				p.SetState(1763)
				p.Match(VerilogParserT__34)
			}

		}
		p.SetState(1767)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__24 {
			{
				p.SetState(1766)
				p.Match(VerilogParserT__24)
			}

		}
		p.SetState(1770)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__20 {
			{
				p.SetState(1769)
				p.Range_()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1772)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(VerilogParserT__31-32))|(1<<(VerilogParserT__32-32))|(1<<(VerilogParserT__33-32)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1774)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(VerilogParserT__40-41))|(1<<(VerilogParserT__41-41))|(1<<(VerilogParserT__42-41))|(1<<(VerilogParserT__43-41))|(1<<(VerilogParserT__44-41))|(1<<(VerilogParserT__45-41))|(1<<(VerilogParserT__46-41))|(1<<(VerilogParserT__47-41))|(1<<(VerilogParserT__48-41))|(1<<(VerilogParserT__49-41)))) != 0 {
			{
				p.SetState(1773)
				p.Net_type()
			}

		}
		p.SetState(1777)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__25)|(1<<VerilogParserT__26)|(1<<VerilogParserT__27)|(1<<VerilogParserT__28))) != 0 {
			{
				p.SetState(1776)
				p.Task_port_type()
			}

		}

	}

	return localctx
}

// ITf_declarationContext is an interface to support dynamic dispatch.
type ITf_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_declarationContext differentiates from other interfaces.
	IsTf_declarationContext()
}

type Tf_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_declarationContext() *Tf_declarationContext {
	var p = new(Tf_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tf_declaration
	return p
}

func (*Tf_declarationContext) IsTf_declarationContext() {}

func NewTf_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_declarationContext {
	var p = new(Tf_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tf_declaration

	return p
}

func (s *Tf_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_declarationContext) Tf_decl_header() ITf_decl_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_decl_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_decl_headerContext)
}

func (s *Tf_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Tf_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTf_declaration(s)
	}
}

func (s *Tf_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTf_declaration(s)
	}
}

func (p *VerilogParser) Tf_declaration() (localctx ITf_declarationContext) {
	localctx = NewTf_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, VerilogParserRULE_tf_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1781)
		p.Tf_decl_header()
	}
	{
		p.SetState(1782)
		p.List_of_port_identifiers()
	}

	return localctx
}

// ITask_port_typeContext is an interface to support dynamic dispatch.
type ITask_port_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_port_typeContext differentiates from other interfaces.
	IsTask_port_typeContext()
}

type Task_port_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_port_typeContext() *Task_port_typeContext {
	var p = new(Task_port_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_port_type
	return p
}

func (*Task_port_typeContext) IsTask_port_typeContext() {}

func NewTask_port_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_port_typeContext {
	var p = new(Task_port_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_port_type

	return p
}

func (s *Task_port_typeContext) GetParser() antlr.Parser { return s.parser }
func (s *Task_port_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_port_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_port_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTask_port_type(s)
	}
}

func (s *Task_port_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTask_port_type(s)
	}
}

func (p *VerilogParser) Task_port_type() (localctx ITask_port_typeContext) {
	localctx = NewTask_port_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, VerilogParserRULE_task_port_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1784)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__25)|(1<<VerilogParserT__26)|(1<<VerilogParserT__27)|(1<<VerilogParserT__28))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBlock_item_declarationContext is an interface to support dynamic dispatch.
type IBlock_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_item_declarationContext differentiates from other interfaces.
	IsBlock_item_declarationContext()
}

type Block_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_item_declarationContext() *Block_item_declarationContext {
	var p = new(Block_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_block_item_declaration
	return p
}

func (*Block_item_declarationContext) IsBlock_item_declarationContext() {}

func NewBlock_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_item_declarationContext {
	var p = new(Block_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_block_item_declaration

	return p
}

func (s *Block_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_item_declarationContext) Block_reg_declaration() IBlock_reg_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_reg_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_reg_declarationContext)
}

func (s *Block_item_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Block_item_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Block_item_declarationContext) Event_declaration() IEvent_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_declarationContext)
}

func (s *Block_item_declarationContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Block_item_declarationContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Block_item_declarationContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Block_item_declarationContext) Real_declaration() IReal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_declarationContext)
}

func (s *Block_item_declarationContext) Realtime_declaration() IRealtime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRealtime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRealtime_declarationContext)
}

func (s *Block_item_declarationContext) Time_declaration() ITime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_declarationContext)
}

func (s *Block_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterBlock_item_declaration(s)
	}
}

func (s *Block_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitBlock_item_declaration(s)
	}
}

func (p *VerilogParser) Block_item_declaration() (localctx IBlock_item_declarationContext) {
	localctx = NewBlock_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, VerilogParserRULE_block_item_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1842)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1789)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(1786)
				p.Attribute_instance()
			}

			p.SetState(1791)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1792)
			p.Block_reg_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1796)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(1793)
				p.Attribute_instance()
			}

			p.SetState(1798)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1799)
			p.Event_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1803)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(1800)
				p.Attribute_instance()
			}

			p.SetState(1805)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1806)
			p.Integer_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1810)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(1807)
				p.Attribute_instance()
			}

			p.SetState(1812)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1813)
			p.Local_parameter_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1817)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(1814)
				p.Attribute_instance()
			}

			p.SetState(1819)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1820)
			p.Parameter_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1824)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(1821)
				p.Attribute_instance()
			}

			p.SetState(1826)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1827)
			p.Real_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(1831)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(1828)
				p.Attribute_instance()
			}

			p.SetState(1833)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1834)
			p.Realtime_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(1838)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(1835)
				p.Attribute_instance()
			}

			p.SetState(1840)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1841)
			p.Time_declaration()
		}

	}

	return localctx
}

// IBlock_reg_declarationContext is an interface to support dynamic dispatch.
type IBlock_reg_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_reg_declarationContext differentiates from other interfaces.
	IsBlock_reg_declarationContext()
}

type Block_reg_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_reg_declarationContext() *Block_reg_declarationContext {
	var p = new(Block_reg_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_block_reg_declaration
	return p
}

func (*Block_reg_declarationContext) IsBlock_reg_declarationContext() {}

func NewBlock_reg_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_reg_declarationContext {
	var p = new(Block_reg_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_block_reg_declaration

	return p
}

func (s *Block_reg_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_reg_declarationContext) List_of_block_variable_identifiers() IList_of_block_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_block_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_block_variable_identifiersContext)
}

func (s *Block_reg_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Block_reg_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_reg_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_reg_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterBlock_reg_declaration(s)
	}
}

func (s *Block_reg_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitBlock_reg_declaration(s)
	}
}

func (p *VerilogParser) Block_reg_declaration() (localctx IBlock_reg_declarationContext) {
	localctx = NewBlock_reg_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, VerilogParserRULE_block_reg_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1844)
		p.Match(VerilogParserT__34)
	}
	p.SetState(1846)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__24 {
		{
			p.SetState(1845)
			p.Match(VerilogParserT__24)
		}

	}
	p.SetState(1849)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__20 {
		{
			p.SetState(1848)
			p.Range_()
		}

	}
	{
		p.SetState(1851)
		p.List_of_block_variable_identifiers()
	}
	{
		p.SetState(1852)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// IList_of_block_variable_identifiersContext is an interface to support dynamic dispatch.
type IList_of_block_variable_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_block_variable_identifiersContext differentiates from other interfaces.
	IsList_of_block_variable_identifiersContext()
}

type List_of_block_variable_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_block_variable_identifiersContext() *List_of_block_variable_identifiersContext {
	var p = new(List_of_block_variable_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_block_variable_identifiers
	return p
}

func (*List_of_block_variable_identifiersContext) IsList_of_block_variable_identifiersContext() {}

func NewList_of_block_variable_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_block_variable_identifiersContext {
	var p = new(List_of_block_variable_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_block_variable_identifiers

	return p
}

func (s *List_of_block_variable_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_block_variable_identifiersContext) AllBlock_variable_type() []IBlock_variable_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_variable_typeContext)(nil)).Elem())
	var tst = make([]IBlock_variable_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_variable_typeContext)
		}
	}

	return tst
}

func (s *List_of_block_variable_identifiersContext) Block_variable_type(i int) IBlock_variable_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_variable_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_variable_typeContext)
}

func (s *List_of_block_variable_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_block_variable_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_block_variable_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_block_variable_identifiers(s)
	}
}

func (s *List_of_block_variable_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_block_variable_identifiers(s)
	}
}

func (p *VerilogParser) List_of_block_variable_identifiers() (localctx IList_of_block_variable_identifiersContext) {
	localctx = NewList_of_block_variable_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, VerilogParserRULE_list_of_block_variable_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1854)
		p.Block_variable_type()
	}
	p.SetState(1859)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(1855)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(1856)
			p.Block_variable_type()
		}

		p.SetState(1861)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBlock_variable_typeContext is an interface to support dynamic dispatch.
type IBlock_variable_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_variable_typeContext differentiates from other interfaces.
	IsBlock_variable_typeContext()
}

type Block_variable_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_variable_typeContext() *Block_variable_typeContext {
	var p = new(Block_variable_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_block_variable_type
	return p
}

func (*Block_variable_typeContext) IsBlock_variable_typeContext() {}

func NewBlock_variable_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_variable_typeContext {
	var p = new(Block_variable_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_block_variable_type

	return p
}

func (s *Block_variable_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_variable_typeContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Block_variable_typeContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *Block_variable_typeContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Block_variable_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_variable_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_variable_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterBlock_variable_type(s)
	}
}

func (s *Block_variable_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitBlock_variable_type(s)
	}
}

func (p *VerilogParser) Block_variable_type() (localctx IBlock_variable_typeContext) {
	localctx = NewBlock_variable_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, VerilogParserRULE_block_variable_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1871)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 192, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1862)
			p.Variable_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1863)
			p.Variable_identifier()
		}
		{
			p.SetState(1864)
			p.Dimension()
		}
		p.SetState(1868)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__20 {
			{
				p.SetState(1865)
				p.Dimension()
			}

			p.SetState(1870)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IGate_instantiationContext is an interface to support dynamic dispatch.
type IGate_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGate_instantiationContext differentiates from other interfaces.
	IsGate_instantiationContext()
}

type Gate_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGate_instantiationContext() *Gate_instantiationContext {
	var p = new(Gate_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_gate_instantiation
	return p
}

func (*Gate_instantiationContext) IsGate_instantiationContext() {}

func NewGate_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Gate_instantiationContext {
	var p = new(Gate_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_gate_instantiation

	return p
}

func (s *Gate_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Gate_instantiationContext) Cmos_switchtype() ICmos_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmos_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmos_switchtypeContext)
}

func (s *Gate_instantiationContext) AllCmos_switch_instance() []ICmos_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICmos_switch_instanceContext)(nil)).Elem())
	var tst = make([]ICmos_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICmos_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Cmos_switch_instance(i int) ICmos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmos_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICmos_switch_instanceContext)
}

func (s *Gate_instantiationContext) Delay3() IDelay3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay3Context)
}

func (s *Gate_instantiationContext) Mos_switchtype() IMos_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMos_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMos_switchtypeContext)
}

func (s *Gate_instantiationContext) AllMos_switch_instance() []IMos_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMos_switch_instanceContext)(nil)).Elem())
	var tst = make([]IMos_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMos_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Mos_switch_instance(i int) IMos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMos_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMos_switch_instanceContext)
}

func (s *Gate_instantiationContext) Pass_switchtype() IPass_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_switchtypeContext)
}

func (s *Gate_instantiationContext) AllPass_switch_instance() []IPass_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPass_switch_instanceContext)(nil)).Elem())
	var tst = make([]IPass_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPass_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Pass_switch_instance(i int) IPass_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPass_switch_instanceContext)
}

func (s *Gate_instantiationContext) AllPull_gate_instance() []IPull_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPull_gate_instanceContext)(nil)).Elem())
	var tst = make([]IPull_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPull_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Pull_gate_instance(i int) IPull_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPull_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPull_gate_instanceContext)
}

func (s *Gate_instantiationContext) Pulldown_strength() IPulldown_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulldown_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulldown_strengthContext)
}

func (s *Gate_instantiationContext) Pullup_strength() IPullup_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPullup_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPullup_strengthContext)
}

func (s *Gate_instantiationContext) Enable_gatetype() IEnable_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_gatetypeContext)
}

func (s *Gate_instantiationContext) AllEnable_gate_instance() []IEnable_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnable_gate_instanceContext)(nil)).Elem())
	var tst = make([]IEnable_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnable_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Enable_gate_instance(i int) IEnable_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnable_gate_instanceContext)
}

func (s *Gate_instantiationContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Gate_instantiationContext) N_input_gatetype() IN_input_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_input_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_input_gatetypeContext)
}

func (s *Gate_instantiationContext) AllN_input_gate_instance() []IN_input_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IN_input_gate_instanceContext)(nil)).Elem())
	var tst = make([]IN_input_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IN_input_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) N_input_gate_instance(i int) IN_input_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_input_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IN_input_gate_instanceContext)
}

func (s *Gate_instantiationContext) Delay2() IDelay2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay2Context)
}

func (s *Gate_instantiationContext) N_output_gatetype() IN_output_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_output_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_output_gatetypeContext)
}

func (s *Gate_instantiationContext) AllN_output_gate_instance() []IN_output_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IN_output_gate_instanceContext)(nil)).Elem())
	var tst = make([]IN_output_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IN_output_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) N_output_gate_instance(i int) IN_output_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_output_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IN_output_gate_instanceContext)
}

func (s *Gate_instantiationContext) Pass_en_switchtype() IPass_en_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_en_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_en_switchtypeContext)
}

func (s *Gate_instantiationContext) AllPass_enable_switch_instance() []IPass_enable_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPass_enable_switch_instanceContext)(nil)).Elem())
	var tst = make([]IPass_enable_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPass_enable_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Pass_enable_switch_instance(i int) IPass_enable_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_enable_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPass_enable_switch_instanceContext)
}

func (s *Gate_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Gate_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Gate_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGate_instantiation(s)
	}
}

func (s *Gate_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGate_instantiation(s)
	}
}

func (p *VerilogParser) Gate_instantiation() (localctx IGate_instantiationContext) {
	localctx = NewGate_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, VerilogParserRULE_gate_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2005)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__72, VerilogParserT__73:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1873)
			p.Cmos_switchtype()
		}
		p.SetState(1875)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1874)
				p.Delay3()
			}

		}
		{
			p.SetState(1877)
			p.Cmos_switch_instance()
		}
		p.SetState(1882)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(1878)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1879)
				p.Cmos_switch_instance()
			}

			p.SetState(1884)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1885)
			p.Match(VerilogParserT__1)
		}

	case VerilogParserT__78, VerilogParserT__79, VerilogParserT__80, VerilogParserT__81:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1887)
			p.Mos_switchtype()
		}
		p.SetState(1889)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1888)
				p.Delay3()
			}

		}
		{
			p.SetState(1891)
			p.Mos_switch_instance()
		}
		p.SetState(1896)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(1892)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1893)
				p.Mos_switch_instance()
			}

			p.SetState(1898)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1899)
			p.Match(VerilogParserT__1)
		}

	case VerilogParserT__94, VerilogParserT__95:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1901)
			p.Pass_switchtype()
		}
		{
			p.SetState(1902)
			p.Pass_switch_instance()
		}
		p.SetState(1907)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(1903)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1904)
				p.Pass_switch_instance()
			}

			p.SetState(1909)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1910)
			p.Match(VerilogParserT__1)
		}

	case VerilogParserT__70:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1912)
			p.Match(VerilogParserT__70)
		}
		p.SetState(1914)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1913)
				p.Pulldown_strength()
			}

		}
		{
			p.SetState(1916)
			p.Pull_gate_instance()
		}
		p.SetState(1921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(1917)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1918)
				p.Pull_gate_instance()
			}

			p.SetState(1923)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1924)
			p.Match(VerilogParserT__1)
		}

	case VerilogParserT__71:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1926)
			p.Match(VerilogParserT__71)
		}
		p.SetState(1928)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1927)
				p.Pullup_strength()
			}

		}
		{
			p.SetState(1930)
			p.Pull_gate_instance()
		}
		p.SetState(1935)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(1931)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1932)
				p.Pull_gate_instance()
			}

			p.SetState(1937)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1938)
			p.Match(VerilogParserT__1)
		}

	case VerilogParserT__74, VerilogParserT__75, VerilogParserT__76, VerilogParserT__77:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1940)
			p.Enable_gatetype()
		}
		p.SetState(1942)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 202, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1941)
				p.Drive_strength()
			}

		}
		p.SetState(1945)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1944)
				p.Delay3()
			}

		}
		{
			p.SetState(1947)
			p.Enable_gate_instance()
		}
		p.SetState(1952)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(1948)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1949)
				p.Enable_gate_instance()
			}

			p.SetState(1954)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1955)
			p.Match(VerilogParserT__1)
		}

	case VerilogParserT__82, VerilogParserT__83, VerilogParserT__84, VerilogParserT__85, VerilogParserT__86, VerilogParserT__87:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1957)
			p.N_input_gatetype()
		}
		p.SetState(1959)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1958)
				p.Drive_strength()
			}

		}
		p.SetState(1962)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1961)
				p.Delay2()
			}

		}
		{
			p.SetState(1964)
			p.N_input_gate_instance()
		}
		p.SetState(1969)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(1965)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1966)
				p.N_input_gate_instance()
			}

			p.SetState(1971)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1972)
			p.Match(VerilogParserT__1)
		}

	case VerilogParserT__88, VerilogParserT__89:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1974)
			p.N_output_gatetype()
		}
		p.SetState(1976)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1975)
				p.Drive_strength()
			}

		}
		p.SetState(1979)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1978)
				p.Delay2()
			}

		}
		{
			p.SetState(1981)
			p.N_output_gate_instance()
		}
		p.SetState(1986)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(1982)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1983)
				p.N_output_gate_instance()
			}

			p.SetState(1988)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1989)
			p.Match(VerilogParserT__1)
		}

	case VerilogParserT__90, VerilogParserT__91, VerilogParserT__92, VerilogParserT__93:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1991)
			p.Pass_en_switchtype()
		}
		p.SetState(1993)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__14 {
			{
				p.SetState(1992)
				p.Delay2()
			}

		}
		{
			p.SetState(1995)
			p.Pass_enable_switch_instance()
		}
		p.SetState(2000)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(1996)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(1997)
				p.Pass_enable_switch_instance()
			}

			p.SetState(2002)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2003)
			p.Match(VerilogParserT__1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICmos_switch_instanceContext is an interface to support dynamic dispatch.
type ICmos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmos_switch_instanceContext differentiates from other interfaces.
	IsCmos_switch_instanceContext()
}

type Cmos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmos_switch_instanceContext() *Cmos_switch_instanceContext {
	var p = new(Cmos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_cmos_switch_instance
	return p
}

func (*Cmos_switch_instanceContext) IsCmos_switch_instanceContext() {}

func NewCmos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmos_switch_instanceContext {
	var p = new(Cmos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_cmos_switch_instance

	return p
}

func (s *Cmos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmos_switch_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Cmos_switch_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Cmos_switch_instanceContext) Ncontrol_terminal() INcontrol_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INcontrol_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INcontrol_terminalContext)
}

func (s *Cmos_switch_instanceContext) Pcontrol_terminal() IPcontrol_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPcontrol_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPcontrol_terminalContext)
}

func (s *Cmos_switch_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Cmos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterCmos_switch_instance(s)
	}
}

func (s *Cmos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitCmos_switch_instance(s)
	}
}

func (p *VerilogParser) Cmos_switch_instance() (localctx ICmos_switch_instanceContext) {
	localctx = NewCmos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, VerilogParserRULE_cmos_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2008)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2007)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2010)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2011)
		p.Output_terminal()
	}
	{
		p.SetState(2012)
		p.Match(VerilogParserT__16)
	}
	{
		p.SetState(2013)
		p.Input_terminal()
	}
	{
		p.SetState(2014)
		p.Match(VerilogParserT__16)
	}
	{
		p.SetState(2015)
		p.Ncontrol_terminal()
	}
	{
		p.SetState(2016)
		p.Match(VerilogParserT__16)
	}
	{
		p.SetState(2017)
		p.Pcontrol_terminal()
	}
	{
		p.SetState(2018)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IEnable_gate_instanceContext is an interface to support dynamic dispatch.
type IEnable_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_gate_instanceContext differentiates from other interfaces.
	IsEnable_gate_instanceContext()
}

type Enable_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_gate_instanceContext() *Enable_gate_instanceContext {
	var p = new(Enable_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_enable_gate_instance
	return p
}

func (*Enable_gate_instanceContext) IsEnable_gate_instanceContext() {}

func NewEnable_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_gate_instanceContext {
	var p = new(Enable_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_enable_gate_instance

	return p
}

func (s *Enable_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_gate_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Enable_gate_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Enable_gate_instanceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Enable_gate_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Enable_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEnable_gate_instance(s)
	}
}

func (s *Enable_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEnable_gate_instance(s)
	}
}

func (p *VerilogParser) Enable_gate_instance() (localctx IEnable_gate_instanceContext) {
	localctx = NewEnable_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, VerilogParserRULE_enable_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2021)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2020)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2023)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2024)
		p.Output_terminal()
	}
	{
		p.SetState(2025)
		p.Match(VerilogParserT__16)
	}
	{
		p.SetState(2026)
		p.Input_terminal()
	}
	{
		p.SetState(2027)
		p.Match(VerilogParserT__16)
	}
	{
		p.SetState(2028)
		p.Enable_terminal()
	}
	{
		p.SetState(2029)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IMos_switch_instanceContext is an interface to support dynamic dispatch.
type IMos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMos_switch_instanceContext differentiates from other interfaces.
	IsMos_switch_instanceContext()
}

type Mos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMos_switch_instanceContext() *Mos_switch_instanceContext {
	var p = new(Mos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_mos_switch_instance
	return p
}

func (*Mos_switch_instanceContext) IsMos_switch_instanceContext() {}

func NewMos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mos_switch_instanceContext {
	var p = new(Mos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_mos_switch_instance

	return p
}

func (s *Mos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Mos_switch_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Mos_switch_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Mos_switch_instanceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Mos_switch_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Mos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterMos_switch_instance(s)
	}
}

func (s *Mos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitMos_switch_instance(s)
	}
}

func (p *VerilogParser) Mos_switch_instance() (localctx IMos_switch_instanceContext) {
	localctx = NewMos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, VerilogParserRULE_mos_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2032)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2031)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2034)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2035)
		p.Output_terminal()
	}
	{
		p.SetState(2036)
		p.Match(VerilogParserT__16)
	}
	{
		p.SetState(2037)
		p.Input_terminal()
	}
	{
		p.SetState(2038)
		p.Match(VerilogParserT__16)
	}
	{
		p.SetState(2039)
		p.Enable_terminal()
	}
	{
		p.SetState(2040)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IN_input_gate_instanceContext is an interface to support dynamic dispatch.
type IN_input_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_input_gate_instanceContext differentiates from other interfaces.
	IsN_input_gate_instanceContext()
}

type N_input_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_input_gate_instanceContext() *N_input_gate_instanceContext {
	var p = new(N_input_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_n_input_gate_instance
	return p
}

func (*N_input_gate_instanceContext) IsN_input_gate_instanceContext() {}

func NewN_input_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_input_gate_instanceContext {
	var p = new(N_input_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_n_input_gate_instance

	return p
}

func (s *N_input_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *N_input_gate_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *N_input_gate_instanceContext) AllInput_terminal() []IInput_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem())
	var tst = make([]IInput_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInput_terminalContext)
		}
	}

	return tst
}

func (s *N_input_gate_instanceContext) Input_terminal(i int) IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *N_input_gate_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *N_input_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_input_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_input_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterN_input_gate_instance(s)
	}
}

func (s *N_input_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitN_input_gate_instance(s)
	}
}

func (p *VerilogParser) N_input_gate_instance() (localctx IN_input_gate_instanceContext) {
	localctx = NewN_input_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, VerilogParserRULE_n_input_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2043)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2042)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2045)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2046)
		p.Output_terminal()
	}
	{
		p.SetState(2047)
		p.Match(VerilogParserT__16)
	}
	{
		p.SetState(2048)
		p.Input_terminal()
	}
	p.SetState(2053)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(2049)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(2050)
			p.Input_terminal()
		}

		p.SetState(2055)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2056)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IN_output_gate_instanceContext is an interface to support dynamic dispatch.
type IN_output_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_output_gate_instanceContext differentiates from other interfaces.
	IsN_output_gate_instanceContext()
}

type N_output_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_output_gate_instanceContext() *N_output_gate_instanceContext {
	var p = new(N_output_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_n_output_gate_instance
	return p
}

func (*N_output_gate_instanceContext) IsN_output_gate_instanceContext() {}

func NewN_output_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_output_gate_instanceContext {
	var p = new(N_output_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_n_output_gate_instance

	return p
}

func (s *N_output_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *N_output_gate_instanceContext) AllOutput_terminal() []IOutput_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem())
	var tst = make([]IOutput_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOutput_terminalContext)
		}
	}

	return tst
}

func (s *N_output_gate_instanceContext) Output_terminal(i int) IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *N_output_gate_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *N_output_gate_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *N_output_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_output_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_output_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterN_output_gate_instance(s)
	}
}

func (s *N_output_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitN_output_gate_instance(s)
	}
}

func (p *VerilogParser) N_output_gate_instance() (localctx IN_output_gate_instanceContext) {
	localctx = NewN_output_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, VerilogParserRULE_n_output_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2059)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2058)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2061)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2062)
		p.Output_terminal()
	}
	p.SetState(2067)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 220, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2063)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(2064)
				p.Output_terminal()
			}

		}
		p.SetState(2069)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 220, p.GetParserRuleContext())
	}
	{
		p.SetState(2070)
		p.Match(VerilogParserT__16)
	}
	{
		p.SetState(2071)
		p.Input_terminal()
	}
	{
		p.SetState(2072)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IPass_switch_instanceContext is an interface to support dynamic dispatch.
type IPass_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_switch_instanceContext differentiates from other interfaces.
	IsPass_switch_instanceContext()
}

type Pass_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_switch_instanceContext() *Pass_switch_instanceContext {
	var p = new(Pass_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pass_switch_instance
	return p
}

func (*Pass_switch_instanceContext) IsPass_switch_instanceContext() {}

func NewPass_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_switch_instanceContext {
	var p = new(Pass_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pass_switch_instance

	return p
}

func (s *Pass_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_switch_instanceContext) AllInout_terminal() []IInout_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem())
	var tst = make([]IInout_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInout_terminalContext)
		}
	}

	return tst
}

func (s *Pass_switch_instanceContext) Inout_terminal(i int) IInout_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInout_terminalContext)
}

func (s *Pass_switch_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Pass_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPass_switch_instance(s)
	}
}

func (s *Pass_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPass_switch_instance(s)
	}
}

func (p *VerilogParser) Pass_switch_instance() (localctx IPass_switch_instanceContext) {
	localctx = NewPass_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, VerilogParserRULE_pass_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2075)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2074)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2077)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2078)
		p.Inout_terminal()
	}
	{
		p.SetState(2079)
		p.Match(VerilogParserT__16)
	}
	{
		p.SetState(2080)
		p.Inout_terminal()
	}
	{
		p.SetState(2081)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IPass_enable_switch_instanceContext is an interface to support dynamic dispatch.
type IPass_enable_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_enable_switch_instanceContext differentiates from other interfaces.
	IsPass_enable_switch_instanceContext()
}

type Pass_enable_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_enable_switch_instanceContext() *Pass_enable_switch_instanceContext {
	var p = new(Pass_enable_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pass_enable_switch_instance
	return p
}

func (*Pass_enable_switch_instanceContext) IsPass_enable_switch_instanceContext() {}

func NewPass_enable_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_enable_switch_instanceContext {
	var p = new(Pass_enable_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pass_enable_switch_instance

	return p
}

func (s *Pass_enable_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_enable_switch_instanceContext) AllInout_terminal() []IInout_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem())
	var tst = make([]IInout_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInout_terminalContext)
		}
	}

	return tst
}

func (s *Pass_enable_switch_instanceContext) Inout_terminal(i int) IInout_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInout_terminalContext)
}

func (s *Pass_enable_switch_instanceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Pass_enable_switch_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Pass_enable_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_enable_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_enable_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPass_enable_switch_instance(s)
	}
}

func (s *Pass_enable_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPass_enable_switch_instance(s)
	}
}

func (p *VerilogParser) Pass_enable_switch_instance() (localctx IPass_enable_switch_instanceContext) {
	localctx = NewPass_enable_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, VerilogParserRULE_pass_enable_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2084)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2083)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2086)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2087)
		p.Inout_terminal()
	}
	{
		p.SetState(2088)
		p.Match(VerilogParserT__16)
	}
	{
		p.SetState(2089)
		p.Inout_terminal()
	}
	{
		p.SetState(2090)
		p.Match(VerilogParserT__16)
	}
	{
		p.SetState(2091)
		p.Enable_terminal()
	}
	{
		p.SetState(2092)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IPull_gate_instanceContext is an interface to support dynamic dispatch.
type IPull_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPull_gate_instanceContext differentiates from other interfaces.
	IsPull_gate_instanceContext()
}

type Pull_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPull_gate_instanceContext() *Pull_gate_instanceContext {
	var p = new(Pull_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pull_gate_instance
	return p
}

func (*Pull_gate_instanceContext) IsPull_gate_instanceContext() {}

func NewPull_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pull_gate_instanceContext {
	var p = new(Pull_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pull_gate_instance

	return p
}

func (s *Pull_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pull_gate_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Pull_gate_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Pull_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pull_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pull_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPull_gate_instance(s)
	}
}

func (s *Pull_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPull_gate_instance(s)
	}
}

func (p *VerilogParser) Pull_gate_instance() (localctx IPull_gate_instanceContext) {
	localctx = NewPull_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, VerilogParserRULE_pull_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2095)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2094)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2097)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2098)
		p.Output_terminal()
	}
	{
		p.SetState(2099)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IName_of_gate_instanceContext is an interface to support dynamic dispatch.
type IName_of_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_of_gate_instanceContext differentiates from other interfaces.
	IsName_of_gate_instanceContext()
}

type Name_of_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_of_gate_instanceContext() *Name_of_gate_instanceContext {
	var p = new(Name_of_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_name_of_gate_instance
	return p
}

func (*Name_of_gate_instanceContext) IsName_of_gate_instanceContext() {}

func NewName_of_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_of_gate_instanceContext {
	var p = new(Name_of_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_name_of_gate_instance

	return p
}

func (s *Name_of_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_of_gate_instanceContext) Gate_instance_identifier() IGate_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instance_identifierContext)
}

func (s *Name_of_gate_instanceContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Name_of_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_of_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_of_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterName_of_gate_instance(s)
	}
}

func (s *Name_of_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitName_of_gate_instance(s)
	}
}

func (p *VerilogParser) Name_of_gate_instance() (localctx IName_of_gate_instanceContext) {
	localctx = NewName_of_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, VerilogParserRULE_name_of_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2101)
		p.Gate_instance_identifier()
	}
	p.SetState(2103)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__20 {
		{
			p.SetState(2102)
			p.Range_()
		}

	}

	return localctx
}

// IPulldown_strengthContext is an interface to support dynamic dispatch.
type IPulldown_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulldown_strengthContext differentiates from other interfaces.
	IsPulldown_strengthContext()
}

type Pulldown_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulldown_strengthContext() *Pulldown_strengthContext {
	var p = new(Pulldown_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pulldown_strength
	return p
}

func (*Pulldown_strengthContext) IsPulldown_strengthContext() {}

func NewPulldown_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulldown_strengthContext {
	var p = new(Pulldown_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pulldown_strength

	return p
}

func (s *Pulldown_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulldown_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Pulldown_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Pulldown_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulldown_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulldown_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPulldown_strength(s)
	}
}

func (s *Pulldown_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPulldown_strength(s)
	}
}

func (p *VerilogParser) Pulldown_strength() (localctx IPulldown_strengthContext) {
	localctx = NewPulldown_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, VerilogParserRULE_pulldown_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2121)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 225, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2105)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2106)
			p.Strength0()
		}
		{
			p.SetState(2107)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(2108)
			p.Strength1()
		}
		{
			p.SetState(2109)
			p.Match(VerilogParserT__17)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2111)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2112)
			p.Strength1()
		}
		{
			p.SetState(2113)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(2114)
			p.Strength0()
		}
		{
			p.SetState(2115)
			p.Match(VerilogParserT__17)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2117)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2118)
			p.Strength0()
		}
		{
			p.SetState(2119)
			p.Match(VerilogParserT__17)
		}

	}

	return localctx
}

// IPullup_strengthContext is an interface to support dynamic dispatch.
type IPullup_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPullup_strengthContext differentiates from other interfaces.
	IsPullup_strengthContext()
}

type Pullup_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPullup_strengthContext() *Pullup_strengthContext {
	var p = new(Pullup_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pullup_strength
	return p
}

func (*Pullup_strengthContext) IsPullup_strengthContext() {}

func NewPullup_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pullup_strengthContext {
	var p = new(Pullup_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pullup_strength

	return p
}

func (s *Pullup_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Pullup_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Pullup_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Pullup_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pullup_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pullup_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPullup_strength(s)
	}
}

func (s *Pullup_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPullup_strength(s)
	}
}

func (p *VerilogParser) Pullup_strength() (localctx IPullup_strengthContext) {
	localctx = NewPullup_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, VerilogParserRULE_pullup_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2139)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 226, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2123)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2124)
			p.Strength0()
		}
		{
			p.SetState(2125)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(2126)
			p.Strength1()
		}
		{
			p.SetState(2127)
			p.Match(VerilogParserT__17)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2129)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2130)
			p.Strength1()
		}
		{
			p.SetState(2131)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(2132)
			p.Strength0()
		}
		{
			p.SetState(2133)
			p.Match(VerilogParserT__17)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2135)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2136)
			p.Strength1()
		}
		{
			p.SetState(2137)
			p.Match(VerilogParserT__17)
		}

	}

	return localctx
}

// IEnable_terminalContext is an interface to support dynamic dispatch.
type IEnable_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_terminalContext differentiates from other interfaces.
	IsEnable_terminalContext()
}

type Enable_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_terminalContext() *Enable_terminalContext {
	var p = new(Enable_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_enable_terminal
	return p
}

func (*Enable_terminalContext) IsEnable_terminalContext() {}

func NewEnable_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_terminalContext {
	var p = new(Enable_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_enable_terminal

	return p
}

func (s *Enable_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Enable_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEnable_terminal(s)
	}
}

func (s *Enable_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEnable_terminal(s)
	}
}

func (p *VerilogParser) Enable_terminal() (localctx IEnable_terminalContext) {
	localctx = NewEnable_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, VerilogParserRULE_enable_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2141)
		p.Expression()
	}

	return localctx
}

// INcontrol_terminalContext is an interface to support dynamic dispatch.
type INcontrol_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNcontrol_terminalContext differentiates from other interfaces.
	IsNcontrol_terminalContext()
}

type Ncontrol_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNcontrol_terminalContext() *Ncontrol_terminalContext {
	var p = new(Ncontrol_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_ncontrol_terminal
	return p
}

func (*Ncontrol_terminalContext) IsNcontrol_terminalContext() {}

func NewNcontrol_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ncontrol_terminalContext {
	var p = new(Ncontrol_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_ncontrol_terminal

	return p
}

func (s *Ncontrol_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Ncontrol_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ncontrol_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ncontrol_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ncontrol_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNcontrol_terminal(s)
	}
}

func (s *Ncontrol_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNcontrol_terminal(s)
	}
}

func (p *VerilogParser) Ncontrol_terminal() (localctx INcontrol_terminalContext) {
	localctx = NewNcontrol_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, VerilogParserRULE_ncontrol_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2143)
		p.Expression()
	}

	return localctx
}

// IPcontrol_terminalContext is an interface to support dynamic dispatch.
type IPcontrol_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPcontrol_terminalContext differentiates from other interfaces.
	IsPcontrol_terminalContext()
}

type Pcontrol_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPcontrol_terminalContext() *Pcontrol_terminalContext {
	var p = new(Pcontrol_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pcontrol_terminal
	return p
}

func (*Pcontrol_terminalContext) IsPcontrol_terminalContext() {}

func NewPcontrol_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pcontrol_terminalContext {
	var p = new(Pcontrol_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pcontrol_terminal

	return p
}

func (s *Pcontrol_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Pcontrol_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Pcontrol_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pcontrol_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pcontrol_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPcontrol_terminal(s)
	}
}

func (s *Pcontrol_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPcontrol_terminal(s)
	}
}

func (p *VerilogParser) Pcontrol_terminal() (localctx IPcontrol_terminalContext) {
	localctx = NewPcontrol_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, VerilogParserRULE_pcontrol_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2145)
		p.Expression()
	}

	return localctx
}

// IInput_terminalContext is an interface to support dynamic dispatch.
type IInput_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_terminalContext differentiates from other interfaces.
	IsInput_terminalContext()
}

type Input_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_terminalContext() *Input_terminalContext {
	var p = new(Input_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_input_terminal
	return p
}

func (*Input_terminalContext) IsInput_terminalContext() {}

func NewInput_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_terminalContext {
	var p = new(Input_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_input_terminal

	return p
}

func (s *Input_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Input_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterInput_terminal(s)
	}
}

func (s *Input_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitInput_terminal(s)
	}
}

func (p *VerilogParser) Input_terminal() (localctx IInput_terminalContext) {
	localctx = NewInput_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, VerilogParserRULE_input_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2147)
		p.Expression()
	}

	return localctx
}

// IInout_terminalContext is an interface to support dynamic dispatch.
type IInout_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_terminalContext differentiates from other interfaces.
	IsInout_terminalContext()
}

type Inout_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_terminalContext() *Inout_terminalContext {
	var p = new(Inout_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inout_terminal
	return p
}

func (*Inout_terminalContext) IsInout_terminalContext() {}

func NewInout_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_terminalContext {
	var p = new(Inout_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inout_terminal

	return p
}

func (s *Inout_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_terminalContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Inout_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterInout_terminal(s)
	}
}

func (s *Inout_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitInout_terminal(s)
	}
}

func (p *VerilogParser) Inout_terminal() (localctx IInout_terminalContext) {
	localctx = NewInout_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, VerilogParserRULE_inout_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2149)
		p.Net_lvalue()
	}

	return localctx
}

// IOutput_terminalContext is an interface to support dynamic dispatch.
type IOutput_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_terminalContext differentiates from other interfaces.
	IsOutput_terminalContext()
}

type Output_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_terminalContext() *Output_terminalContext {
	var p = new(Output_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_terminal
	return p
}

func (*Output_terminalContext) IsOutput_terminalContext() {}

func NewOutput_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_terminalContext {
	var p = new(Output_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_terminal

	return p
}

func (s *Output_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_terminalContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Output_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterOutput_terminal(s)
	}
}

func (s *Output_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitOutput_terminal(s)
	}
}

func (p *VerilogParser) Output_terminal() (localctx IOutput_terminalContext) {
	localctx = NewOutput_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, VerilogParserRULE_output_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2151)
		p.Net_lvalue()
	}

	return localctx
}

// ICmos_switchtypeContext is an interface to support dynamic dispatch.
type ICmos_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmos_switchtypeContext differentiates from other interfaces.
	IsCmos_switchtypeContext()
}

type Cmos_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmos_switchtypeContext() *Cmos_switchtypeContext {
	var p = new(Cmos_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_cmos_switchtype
	return p
}

func (*Cmos_switchtypeContext) IsCmos_switchtypeContext() {}

func NewCmos_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmos_switchtypeContext {
	var p = new(Cmos_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_cmos_switchtype

	return p
}

func (s *Cmos_switchtypeContext) GetParser() antlr.Parser { return s.parser }
func (s *Cmos_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmos_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmos_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterCmos_switchtype(s)
	}
}

func (s *Cmos_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitCmos_switchtype(s)
	}
}

func (p *VerilogParser) Cmos_switchtype() (localctx ICmos_switchtypeContext) {
	localctx = NewCmos_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, VerilogParserRULE_cmos_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2153)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserT__72 || _la == VerilogParserT__73) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEnable_gatetypeContext is an interface to support dynamic dispatch.
type IEnable_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_gatetypeContext differentiates from other interfaces.
	IsEnable_gatetypeContext()
}

type Enable_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_gatetypeContext() *Enable_gatetypeContext {
	var p = new(Enable_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_enable_gatetype
	return p
}

func (*Enable_gatetypeContext) IsEnable_gatetypeContext() {}

func NewEnable_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_gatetypeContext {
	var p = new(Enable_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_enable_gatetype

	return p
}

func (s *Enable_gatetypeContext) GetParser() antlr.Parser { return s.parser }
func (s *Enable_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEnable_gatetype(s)
	}
}

func (s *Enable_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEnable_gatetype(s)
	}
}

func (p *VerilogParser) Enable_gatetype() (localctx IEnable_gatetypeContext) {
	localctx = NewEnable_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, VerilogParserRULE_enable_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2155)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(VerilogParserT__74-75))|(1<<(VerilogParserT__75-75))|(1<<(VerilogParserT__76-75))|(1<<(VerilogParserT__77-75)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMos_switchtypeContext is an interface to support dynamic dispatch.
type IMos_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMos_switchtypeContext differentiates from other interfaces.
	IsMos_switchtypeContext()
}

type Mos_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMos_switchtypeContext() *Mos_switchtypeContext {
	var p = new(Mos_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_mos_switchtype
	return p
}

func (*Mos_switchtypeContext) IsMos_switchtypeContext() {}

func NewMos_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mos_switchtypeContext {
	var p = new(Mos_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_mos_switchtype

	return p
}

func (s *Mos_switchtypeContext) GetParser() antlr.Parser { return s.parser }
func (s *Mos_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mos_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mos_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterMos_switchtype(s)
	}
}

func (s *Mos_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitMos_switchtype(s)
	}
}

func (p *VerilogParser) Mos_switchtype() (localctx IMos_switchtypeContext) {
	localctx = NewMos_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, VerilogParserRULE_mos_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2157)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(VerilogParserT__78-79))|(1<<(VerilogParserT__79-79))|(1<<(VerilogParserT__80-79))|(1<<(VerilogParserT__81-79)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IN_input_gatetypeContext is an interface to support dynamic dispatch.
type IN_input_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_input_gatetypeContext differentiates from other interfaces.
	IsN_input_gatetypeContext()
}

type N_input_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_input_gatetypeContext() *N_input_gatetypeContext {
	var p = new(N_input_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_n_input_gatetype
	return p
}

func (*N_input_gatetypeContext) IsN_input_gatetypeContext() {}

func NewN_input_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_input_gatetypeContext {
	var p = new(N_input_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_n_input_gatetype

	return p
}

func (s *N_input_gatetypeContext) GetParser() antlr.Parser { return s.parser }
func (s *N_input_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_input_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_input_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterN_input_gatetype(s)
	}
}

func (s *N_input_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitN_input_gatetype(s)
	}
}

func (p *VerilogParser) N_input_gatetype() (localctx IN_input_gatetypeContext) {
	localctx = NewN_input_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, VerilogParserRULE_n_input_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2159)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(VerilogParserT__82-83))|(1<<(VerilogParserT__83-83))|(1<<(VerilogParserT__84-83))|(1<<(VerilogParserT__85-83))|(1<<(VerilogParserT__86-83))|(1<<(VerilogParserT__87-83)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IN_output_gatetypeContext is an interface to support dynamic dispatch.
type IN_output_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_output_gatetypeContext differentiates from other interfaces.
	IsN_output_gatetypeContext()
}

type N_output_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_output_gatetypeContext() *N_output_gatetypeContext {
	var p = new(N_output_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_n_output_gatetype
	return p
}

func (*N_output_gatetypeContext) IsN_output_gatetypeContext() {}

func NewN_output_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_output_gatetypeContext {
	var p = new(N_output_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_n_output_gatetype

	return p
}

func (s *N_output_gatetypeContext) GetParser() antlr.Parser { return s.parser }
func (s *N_output_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_output_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_output_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterN_output_gatetype(s)
	}
}

func (s *N_output_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitN_output_gatetype(s)
	}
}

func (p *VerilogParser) N_output_gatetype() (localctx IN_output_gatetypeContext) {
	localctx = NewN_output_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, VerilogParserRULE_n_output_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2161)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserT__88 || _la == VerilogParserT__89) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPass_en_switchtypeContext is an interface to support dynamic dispatch.
type IPass_en_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_en_switchtypeContext differentiates from other interfaces.
	IsPass_en_switchtypeContext()
}

type Pass_en_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_en_switchtypeContext() *Pass_en_switchtypeContext {
	var p = new(Pass_en_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pass_en_switchtype
	return p
}

func (*Pass_en_switchtypeContext) IsPass_en_switchtypeContext() {}

func NewPass_en_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_en_switchtypeContext {
	var p = new(Pass_en_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pass_en_switchtype

	return p
}

func (s *Pass_en_switchtypeContext) GetParser() antlr.Parser { return s.parser }
func (s *Pass_en_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_en_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_en_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPass_en_switchtype(s)
	}
}

func (s *Pass_en_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPass_en_switchtype(s)
	}
}

func (p *VerilogParser) Pass_en_switchtype() (localctx IPass_en_switchtypeContext) {
	localctx = NewPass_en_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, VerilogParserRULE_pass_en_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2163)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(VerilogParserT__90-91))|(1<<(VerilogParserT__91-91))|(1<<(VerilogParserT__92-91))|(1<<(VerilogParserT__93-91)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPass_switchtypeContext is an interface to support dynamic dispatch.
type IPass_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_switchtypeContext differentiates from other interfaces.
	IsPass_switchtypeContext()
}

type Pass_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_switchtypeContext() *Pass_switchtypeContext {
	var p = new(Pass_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pass_switchtype
	return p
}

func (*Pass_switchtypeContext) IsPass_switchtypeContext() {}

func NewPass_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_switchtypeContext {
	var p = new(Pass_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pass_switchtype

	return p
}

func (s *Pass_switchtypeContext) GetParser() antlr.Parser { return s.parser }
func (s *Pass_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPass_switchtype(s)
	}
}

func (s *Pass_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPass_switchtype(s)
	}
}

func (p *VerilogParser) Pass_switchtype() (localctx IPass_switchtypeContext) {
	localctx = NewPass_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, VerilogParserRULE_pass_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2165)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserT__94 || _la == VerilogParserT__95) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IModule_instantiationContext is an interface to support dynamic dispatch.
type IModule_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_instantiationContext differentiates from other interfaces.
	IsModule_instantiationContext()
}

type Module_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_instantiationContext() *Module_instantiationContext {
	var p = new(Module_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_instantiation
	return p
}

func (*Module_instantiationContext) IsModule_instantiationContext() {}

func NewModule_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_instantiationContext {
	var p = new(Module_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_instantiation

	return p
}

func (s *Module_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_instantiationContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Module_instantiationContext) AllModule_instance() []IModule_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_instanceContext)(nil)).Elem())
	var tst = make([]IModule_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_instanceContext)
		}
	}

	return tst
}

func (s *Module_instantiationContext) Module_instance(i int) IModule_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_instanceContext)
}

func (s *Module_instantiationContext) Parameter_value_assignment() IParameter_value_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_value_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_value_assignmentContext)
}

func (s *Module_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_instantiation(s)
	}
}

func (s *Module_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_instantiation(s)
	}
}

func (p *VerilogParser) Module_instantiation() (localctx IModule_instantiationContext) {
	localctx = NewModule_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, VerilogParserRULE_module_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2167)
		p.Module_identifier()
	}
	p.SetState(2169)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__14 {
		{
			p.SetState(2168)
			p.Parameter_value_assignment()
		}

	}
	{
		p.SetState(2171)
		p.Module_instance()
	}
	p.SetState(2176)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(2172)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(2173)
			p.Module_instance()
		}

		p.SetState(2178)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2179)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// IParameter_value_assignmentContext is an interface to support dynamic dispatch.
type IParameter_value_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_value_assignmentContext differentiates from other interfaces.
	IsParameter_value_assignmentContext()
}

type Parameter_value_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_value_assignmentContext() *Parameter_value_assignmentContext {
	var p = new(Parameter_value_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_value_assignment
	return p
}

func (*Parameter_value_assignmentContext) IsParameter_value_assignmentContext() {}

func NewParameter_value_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_value_assignmentContext {
	var p = new(Parameter_value_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_value_assignment

	return p
}

func (s *Parameter_value_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_value_assignmentContext) List_of_parameter_assignments() IList_of_parameter_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_parameter_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_parameter_assignmentsContext)
}

func (s *Parameter_value_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_value_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_value_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterParameter_value_assignment(s)
	}
}

func (s *Parameter_value_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitParameter_value_assignment(s)
	}
}

func (p *VerilogParser) Parameter_value_assignment() (localctx IParameter_value_assignmentContext) {
	localctx = NewParameter_value_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, VerilogParserRULE_parameter_value_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2181)
		p.Match(VerilogParserT__14)
	}
	{
		p.SetState(2182)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2183)
		p.List_of_parameter_assignments()
	}
	{
		p.SetState(2184)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IList_of_parameter_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_parameter_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_parameter_assignmentsContext differentiates from other interfaces.
	IsList_of_parameter_assignmentsContext()
}

type List_of_parameter_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_parameter_assignmentsContext() *List_of_parameter_assignmentsContext {
	var p = new(List_of_parameter_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_parameter_assignments
	return p
}

func (*List_of_parameter_assignmentsContext) IsList_of_parameter_assignmentsContext() {}

func NewList_of_parameter_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_parameter_assignmentsContext {
	var p = new(List_of_parameter_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_parameter_assignments

	return p
}

func (s *List_of_parameter_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_parameter_assignmentsContext) AllOrdered_parameter_assignment() []IOrdered_parameter_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrdered_parameter_assignmentContext)(nil)).Elem())
	var tst = make([]IOrdered_parameter_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrdered_parameter_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_parameter_assignmentsContext) Ordered_parameter_assignment(i int) IOrdered_parameter_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrdered_parameter_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrdered_parameter_assignmentContext)
}

func (s *List_of_parameter_assignmentsContext) AllNamed_parameter_assignment() []INamed_parameter_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamed_parameter_assignmentContext)(nil)).Elem())
	var tst = make([]INamed_parameter_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamed_parameter_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_parameter_assignmentsContext) Named_parameter_assignment(i int) INamed_parameter_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_parameter_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamed_parameter_assignmentContext)
}

func (s *List_of_parameter_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_parameter_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_parameter_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_parameter_assignments(s)
	}
}

func (s *List_of_parameter_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_parameter_assignments(s)
	}
}

func (p *VerilogParser) List_of_parameter_assignments() (localctx IList_of_parameter_assignmentsContext) {
	localctx = NewList_of_parameter_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, VerilogParserRULE_list_of_parameter_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2202)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__15, VerilogParserT__18, VerilogParserT__135, VerilogParserT__136, VerilogParserT__140, VerilogParserT__141, VerilogParserT__142, VerilogParserT__143, VerilogParserT__144, VerilogParserT__145, VerilogParserT__146, VerilogParserT__147, VerilogParserT__148, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserStrings, VerilogParserEscaped_identifier, VerilogParserSimple_identifier, VerilogParserDollar_Identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2186)
			p.Ordered_parameter_assignment()
		}
		p.SetState(2191)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(2187)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(2188)
				p.Ordered_parameter_assignment()
			}

			p.SetState(2193)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case VerilogParserT__4:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2194)
			p.Named_parameter_assignment()
		}
		p.SetState(2199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(2195)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(2196)
				p.Named_parameter_assignment()
			}

			p.SetState(2201)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOrdered_parameter_assignmentContext is an interface to support dynamic dispatch.
type IOrdered_parameter_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrdered_parameter_assignmentContext differentiates from other interfaces.
	IsOrdered_parameter_assignmentContext()
}

type Ordered_parameter_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdered_parameter_assignmentContext() *Ordered_parameter_assignmentContext {
	var p = new(Ordered_parameter_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_ordered_parameter_assignment
	return p
}

func (*Ordered_parameter_assignmentContext) IsOrdered_parameter_assignmentContext() {}

func NewOrdered_parameter_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordered_parameter_assignmentContext {
	var p = new(Ordered_parameter_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_ordered_parameter_assignment

	return p
}

func (s *Ordered_parameter_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordered_parameter_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ordered_parameter_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordered_parameter_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordered_parameter_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterOrdered_parameter_assignment(s)
	}
}

func (s *Ordered_parameter_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitOrdered_parameter_assignment(s)
	}
}

func (p *VerilogParser) Ordered_parameter_assignment() (localctx IOrdered_parameter_assignmentContext) {
	localctx = NewOrdered_parameter_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, VerilogParserRULE_ordered_parameter_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2204)
		p.Expression()
	}

	return localctx
}

// INamed_parameter_assignmentContext is an interface to support dynamic dispatch.
type INamed_parameter_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamed_parameter_assignmentContext differentiates from other interfaces.
	IsNamed_parameter_assignmentContext()
}

type Named_parameter_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_parameter_assignmentContext() *Named_parameter_assignmentContext {
	var p = new(Named_parameter_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_named_parameter_assignment
	return p
}

func (*Named_parameter_assignmentContext) IsNamed_parameter_assignmentContext() {}

func NewNamed_parameter_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_parameter_assignmentContext {
	var p = new(Named_parameter_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_named_parameter_assignment

	return p
}

func (s *Named_parameter_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_parameter_assignmentContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Named_parameter_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Named_parameter_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_parameter_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_parameter_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNamed_parameter_assignment(s)
	}
}

func (s *Named_parameter_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNamed_parameter_assignment(s)
	}
}

func (p *VerilogParser) Named_parameter_assignment() (localctx INamed_parameter_assignmentContext) {
	localctx = NewNamed_parameter_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, VerilogParserRULE_named_parameter_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2206)
		p.Match(VerilogParserT__4)
	}
	{
		p.SetState(2207)
		p.Parameter_identifier()
	}
	{
		p.SetState(2208)
		p.Match(VerilogParserT__15)
	}
	p.SetState(2210)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__15 || _la == VerilogParserT__18 || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
		{
			p.SetState(2209)
			p.Expression()
		}

	}
	{
		p.SetState(2212)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IModule_instanceContext is an interface to support dynamic dispatch.
type IModule_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_instanceContext differentiates from other interfaces.
	IsModule_instanceContext()
}

type Module_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_instanceContext() *Module_instanceContext {
	var p = new(Module_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_instance
	return p
}

func (*Module_instanceContext) IsModule_instanceContext() {}

func NewModule_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_instanceContext {
	var p = new(Module_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_instance

	return p
}

func (s *Module_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_instanceContext) Name_of_instance() IName_of_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_instanceContext)
}

func (s *Module_instanceContext) List_of_port_connections() IList_of_port_connectionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_connectionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_connectionsContext)
}

func (s *Module_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_instance(s)
	}
}

func (s *Module_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_instance(s)
	}
}

func (p *VerilogParser) Module_instance() (localctx IModule_instanceContext) {
	localctx = NewModule_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, VerilogParserRULE_module_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2214)
		p.Name_of_instance()
	}
	{
		p.SetState(2215)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2216)
		p.List_of_port_connections()
	}
	{
		p.SetState(2217)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IName_of_instanceContext is an interface to support dynamic dispatch.
type IName_of_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_of_instanceContext differentiates from other interfaces.
	IsName_of_instanceContext()
}

type Name_of_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_of_instanceContext() *Name_of_instanceContext {
	var p = new(Name_of_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_name_of_instance
	return p
}

func (*Name_of_instanceContext) IsName_of_instanceContext() {}

func NewName_of_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_of_instanceContext {
	var p = new(Name_of_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_name_of_instance

	return p
}

func (s *Name_of_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_of_instanceContext) Module_instance_identifier() IModule_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_instance_identifierContext)
}

func (s *Name_of_instanceContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Name_of_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_of_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_of_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterName_of_instance(s)
	}
}

func (s *Name_of_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitName_of_instance(s)
	}
}

func (p *VerilogParser) Name_of_instance() (localctx IName_of_instanceContext) {
	localctx = NewName_of_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, VerilogParserRULE_name_of_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2219)
		p.Module_instance_identifier()
	}
	p.SetState(2221)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__20 {
		{
			p.SetState(2220)
			p.Range_()
		}

	}

	return localctx
}

// IList_of_port_connectionsContext is an interface to support dynamic dispatch.
type IList_of_port_connectionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_connectionsContext differentiates from other interfaces.
	IsList_of_port_connectionsContext()
}

type List_of_port_connectionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_connectionsContext() *List_of_port_connectionsContext {
	var p = new(List_of_port_connectionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_port_connections
	return p
}

func (*List_of_port_connectionsContext) IsList_of_port_connectionsContext() {}

func NewList_of_port_connectionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_connectionsContext {
	var p = new(List_of_port_connectionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_port_connections

	return p
}

func (s *List_of_port_connectionsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_connectionsContext) AllOrdered_port_connection() []IOrdered_port_connectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrdered_port_connectionContext)(nil)).Elem())
	var tst = make([]IOrdered_port_connectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrdered_port_connectionContext)
		}
	}

	return tst
}

func (s *List_of_port_connectionsContext) Ordered_port_connection(i int) IOrdered_port_connectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrdered_port_connectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrdered_port_connectionContext)
}

func (s *List_of_port_connectionsContext) AllNamed_port_connection() []INamed_port_connectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamed_port_connectionContext)(nil)).Elem())
	var tst = make([]INamed_port_connectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamed_port_connectionContext)
		}
	}

	return tst
}

func (s *List_of_port_connectionsContext) Named_port_connection(i int) INamed_port_connectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_port_connectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamed_port_connectionContext)
}

func (s *List_of_port_connectionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_connectionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_connectionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_port_connections(s)
	}
}

func (s *List_of_port_connectionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_port_connections(s)
	}
}

func (p *VerilogParser) List_of_port_connections() (localctx IList_of_port_connectionsContext) {
	localctx = NewList_of_port_connectionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, VerilogParserRULE_list_of_port_connections)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2239)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 236, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2223)
			p.Ordered_port_connection()
		}
		p.SetState(2228)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(2224)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(2225)
				p.Ordered_port_connection()
			}

			p.SetState(2230)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2231)
			p.Named_port_connection()
		}
		p.SetState(2236)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(2232)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(2233)
				p.Named_port_connection()
			}

			p.SetState(2238)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IOrdered_port_connectionContext is an interface to support dynamic dispatch.
type IOrdered_port_connectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrdered_port_connectionContext differentiates from other interfaces.
	IsOrdered_port_connectionContext()
}

type Ordered_port_connectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdered_port_connectionContext() *Ordered_port_connectionContext {
	var p = new(Ordered_port_connectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_ordered_port_connection
	return p
}

func (*Ordered_port_connectionContext) IsOrdered_port_connectionContext() {}

func NewOrdered_port_connectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordered_port_connectionContext {
	var p = new(Ordered_port_connectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_ordered_port_connection

	return p
}

func (s *Ordered_port_connectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordered_port_connectionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Ordered_port_connectionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Ordered_port_connectionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ordered_port_connectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordered_port_connectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordered_port_connectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterOrdered_port_connection(s)
	}
}

func (s *Ordered_port_connectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitOrdered_port_connection(s)
	}
}

func (p *VerilogParser) Ordered_port_connection() (localctx IOrdered_port_connectionContext) {
	localctx = NewOrdered_port_connectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, VerilogParserRULE_ordered_port_connection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2244)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2241)
				p.Attribute_instance()
			}

		}
		p.SetState(2246)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 237, p.GetParserRuleContext())
	}
	p.SetState(2248)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__15 || _la == VerilogParserT__18 || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
		{
			p.SetState(2247)
			p.Expression()
		}

	}

	return localctx
}

// INamed_port_connectionContext is an interface to support dynamic dispatch.
type INamed_port_connectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamed_port_connectionContext differentiates from other interfaces.
	IsNamed_port_connectionContext()
}

type Named_port_connectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_port_connectionContext() *Named_port_connectionContext {
	var p = new(Named_port_connectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_named_port_connection
	return p
}

func (*Named_port_connectionContext) IsNamed_port_connectionContext() {}

func NewNamed_port_connectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_port_connectionContext {
	var p = new(Named_port_connectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_named_port_connection

	return p
}

func (s *Named_port_connectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_port_connectionContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Named_port_connectionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Named_port_connectionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Named_port_connectionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Named_port_connectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_port_connectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_port_connectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNamed_port_connection(s)
	}
}

func (s *Named_port_connectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNamed_port_connection(s)
	}
}

func (p *VerilogParser) Named_port_connection() (localctx INamed_port_connectionContext) {
	localctx = NewNamed_port_connectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, VerilogParserRULE_named_port_connection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2253)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__15 {
		{
			p.SetState(2250)
			p.Attribute_instance()
		}

		p.SetState(2255)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2256)
		p.Match(VerilogParserT__4)
	}
	{
		p.SetState(2257)
		p.Port_identifier()
	}
	{
		p.SetState(2258)
		p.Match(VerilogParserT__15)
	}
	p.SetState(2260)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__15 || _la == VerilogParserT__18 || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
		{
			p.SetState(2259)
			p.Expression()
		}

	}
	{
		p.SetState(2262)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IGenerated_instantiationContext is an interface to support dynamic dispatch.
type IGenerated_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerated_instantiationContext differentiates from other interfaces.
	IsGenerated_instantiationContext()
}

type Generated_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerated_instantiationContext() *Generated_instantiationContext {
	var p = new(Generated_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generated_instantiation
	return p
}

func (*Generated_instantiationContext) IsGenerated_instantiationContext() {}

func NewGenerated_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generated_instantiationContext {
	var p = new(Generated_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generated_instantiation

	return p
}

func (s *Generated_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Generated_instantiationContext) AllGenerate_item() []IGenerate_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem())
	var tst = make([]IGenerate_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_itemContext)
		}
	}

	return tst
}

func (s *Generated_instantiationContext) Generate_item(i int) IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generated_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generated_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generated_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenerated_instantiation(s)
	}
}

func (s *Generated_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenerated_instantiation(s)
	}
}

func (p *VerilogParser) Generated_instantiation() (localctx IGenerated_instantiationContext) {
	localctx = NewGenerated_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, VerilogParserRULE_generated_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2264)
		p.Match(VerilogParserT__96)
	}
	p.SetState(2268)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-16)&-(0x1f+1)) == 0 && ((1<<uint((_la-16)))&((1<<(VerilogParserT__15-16))|(1<<(VerilogParserT__22-16))|(1<<(VerilogParserT__25-16))|(1<<(VerilogParserT__26-16))|(1<<(VerilogParserT__27-16))|(1<<(VerilogParserT__28-16))|(1<<(VerilogParserT__34-16))|(1<<(VerilogParserT__35-16))|(1<<(VerilogParserT__36-16))|(1<<(VerilogParserT__37-16))|(1<<(VerilogParserT__40-16))|(1<<(VerilogParserT__41-16))|(1<<(VerilogParserT__42-16))|(1<<(VerilogParserT__43-16))|(1<<(VerilogParserT__44-16))|(1<<(VerilogParserT__45-16))|(1<<(VerilogParserT__46-16)))) != 0) || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(VerilogParserT__47-48))|(1<<(VerilogParserT__48-48))|(1<<(VerilogParserT__49-48))|(1<<(VerilogParserT__65-48))|(1<<(VerilogParserT__68-48))|(1<<(VerilogParserT__70-48))|(1<<(VerilogParserT__71-48))|(1<<(VerilogParserT__72-48))|(1<<(VerilogParserT__73-48))|(1<<(VerilogParserT__74-48))|(1<<(VerilogParserT__75-48))|(1<<(VerilogParserT__76-48))|(1<<(VerilogParserT__77-48))|(1<<(VerilogParserT__78-48)))) != 0) || (((_la-80)&-(0x1f+1)) == 0 && ((1<<uint((_la-80)))&((1<<(VerilogParserT__79-80))|(1<<(VerilogParserT__80-80))|(1<<(VerilogParserT__81-80))|(1<<(VerilogParserT__82-80))|(1<<(VerilogParserT__83-80))|(1<<(VerilogParserT__84-80))|(1<<(VerilogParserT__85-80))|(1<<(VerilogParserT__86-80))|(1<<(VerilogParserT__87-80))|(1<<(VerilogParserT__88-80))|(1<<(VerilogParserT__89-80))|(1<<(VerilogParserT__90-80))|(1<<(VerilogParserT__91-80))|(1<<(VerilogParserT__92-80))|(1<<(VerilogParserT__93-80))|(1<<(VerilogParserT__94-80))|(1<<(VerilogParserT__95-80))|(1<<(VerilogParserT__98-80))|(1<<(VerilogParserT__100-80))|(1<<(VerilogParserT__102-80))|(1<<(VerilogParserT__103-80))|(1<<(VerilogParserT__105-80))|(1<<(VerilogParserT__106-80))|(1<<(VerilogParserT__107-80)))) != 0) || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2265)
			p.Generate_item()
		}

		p.SetState(2270)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2271)
		p.Match(VerilogParserT__97)
	}

	return localctx
}

// IGenerate_item_or_nullContext is an interface to support dynamic dispatch.
type IGenerate_item_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_item_or_nullContext differentiates from other interfaces.
	IsGenerate_item_or_nullContext()
}

type Generate_item_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_item_or_nullContext() *Generate_item_or_nullContext {
	var p = new(Generate_item_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_item_or_null
	return p
}

func (*Generate_item_or_nullContext) IsGenerate_item_or_nullContext() {}

func NewGenerate_item_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_item_or_nullContext {
	var p = new(Generate_item_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_item_or_null

	return p
}

func (s *Generate_item_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_item_or_nullContext) Generate_item() IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_item_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_item_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_item_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenerate_item_or_null(s)
	}
}

func (s *Generate_item_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenerate_item_or_null(s)
	}
}

func (p *VerilogParser) Generate_item_or_null() (localctx IGenerate_item_or_nullContext) {
	localctx = NewGenerate_item_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, VerilogParserRULE_generate_item_or_null)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2275)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__15, VerilogParserT__22, VerilogParserT__25, VerilogParserT__26, VerilogParserT__27, VerilogParserT__28, VerilogParserT__34, VerilogParserT__35, VerilogParserT__36, VerilogParserT__37, VerilogParserT__40, VerilogParserT__41, VerilogParserT__42, VerilogParserT__43, VerilogParserT__44, VerilogParserT__45, VerilogParserT__46, VerilogParserT__47, VerilogParserT__48, VerilogParserT__49, VerilogParserT__65, VerilogParserT__68, VerilogParserT__70, VerilogParserT__71, VerilogParserT__72, VerilogParserT__73, VerilogParserT__74, VerilogParserT__75, VerilogParserT__76, VerilogParserT__77, VerilogParserT__78, VerilogParserT__79, VerilogParserT__80, VerilogParserT__81, VerilogParserT__82, VerilogParserT__83, VerilogParserT__84, VerilogParserT__85, VerilogParserT__86, VerilogParserT__87, VerilogParserT__88, VerilogParserT__89, VerilogParserT__90, VerilogParserT__91, VerilogParserT__92, VerilogParserT__93, VerilogParserT__94, VerilogParserT__95, VerilogParserT__98, VerilogParserT__100, VerilogParserT__102, VerilogParserT__103, VerilogParserT__105, VerilogParserT__106, VerilogParserT__107, VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2273)
			p.Generate_item()
		}

	case VerilogParserT__1:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2274)
			p.Match(VerilogParserT__1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGenerate_itemContext is an interface to support dynamic dispatch.
type IGenerate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_itemContext differentiates from other interfaces.
	IsGenerate_itemContext()
}

type Generate_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_itemContext() *Generate_itemContext {
	var p = new(Generate_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_item
	return p
}

func (*Generate_itemContext) IsGenerate_itemContext() {}

func NewGenerate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_itemContext {
	var p = new(Generate_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_item

	return p
}

func (s *Generate_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_itemContext) Generate_conditional_statement() IGenerate_conditional_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_conditional_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_conditional_statementContext)
}

func (s *Generate_itemContext) Generate_case_statement() IGenerate_case_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_case_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_case_statementContext)
}

func (s *Generate_itemContext) Generate_loop_statement() IGenerate_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_loop_statementContext)
}

func (s *Generate_itemContext) Generate_block() IGenerate_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_blockContext)
}

func (s *Generate_itemContext) Module_or_generate_item() IModule_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_itemContext)
}

func (s *Generate_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenerate_item(s)
	}
}

func (s *Generate_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenerate_item(s)
	}
}

func (p *VerilogParser) Generate_item() (localctx IGenerate_itemContext) {
	localctx = NewGenerate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, VerilogParserRULE_generate_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2282)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__98:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2277)
			p.Generate_conditional_statement()
		}

	case VerilogParserT__100:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2278)
			p.Generate_case_statement()
		}

	case VerilogParserT__102:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2279)
			p.Generate_loop_statement()
		}

	case VerilogParserT__103:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2280)
			p.Generate_block()
		}

	case VerilogParserT__15, VerilogParserT__22, VerilogParserT__25, VerilogParserT__26, VerilogParserT__27, VerilogParserT__28, VerilogParserT__34, VerilogParserT__35, VerilogParserT__36, VerilogParserT__37, VerilogParserT__40, VerilogParserT__41, VerilogParserT__42, VerilogParserT__43, VerilogParserT__44, VerilogParserT__45, VerilogParserT__46, VerilogParserT__47, VerilogParserT__48, VerilogParserT__49, VerilogParserT__65, VerilogParserT__68, VerilogParserT__70, VerilogParserT__71, VerilogParserT__72, VerilogParserT__73, VerilogParserT__74, VerilogParserT__75, VerilogParserT__76, VerilogParserT__77, VerilogParserT__78, VerilogParserT__79, VerilogParserT__80, VerilogParserT__81, VerilogParserT__82, VerilogParserT__83, VerilogParserT__84, VerilogParserT__85, VerilogParserT__86, VerilogParserT__87, VerilogParserT__88, VerilogParserT__89, VerilogParserT__90, VerilogParserT__91, VerilogParserT__92, VerilogParserT__93, VerilogParserT__94, VerilogParserT__95, VerilogParserT__105, VerilogParserT__106, VerilogParserT__107, VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2281)
			p.Module_or_generate_item()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGenerate_conditional_statementContext is an interface to support dynamic dispatch.
type IGenerate_conditional_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_conditional_statementContext differentiates from other interfaces.
	IsGenerate_conditional_statementContext()
}

type Generate_conditional_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_conditional_statementContext() *Generate_conditional_statementContext {
	var p = new(Generate_conditional_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_conditional_statement
	return p
}

func (*Generate_conditional_statementContext) IsGenerate_conditional_statementContext() {}

func NewGenerate_conditional_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_conditional_statementContext {
	var p = new(Generate_conditional_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_conditional_statement

	return p
}

func (s *Generate_conditional_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_conditional_statementContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Generate_conditional_statementContext) AllGenerate_item_or_null() []IGenerate_item_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_item_or_nullContext)(nil)).Elem())
	var tst = make([]IGenerate_item_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_item_or_nullContext)
		}
	}

	return tst
}

func (s *Generate_conditional_statementContext) Generate_item_or_null(i int) IGenerate_item_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_item_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_item_or_nullContext)
}

func (s *Generate_conditional_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_conditional_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_conditional_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenerate_conditional_statement(s)
	}
}

func (s *Generate_conditional_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenerate_conditional_statement(s)
	}
}

func (p *VerilogParser) Generate_conditional_statement() (localctx IGenerate_conditional_statementContext) {
	localctx = NewGenerate_conditional_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, VerilogParserRULE_generate_conditional_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2284)
		p.Match(VerilogParserT__98)
	}
	{
		p.SetState(2285)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2286)
		p.Constant_expression()
	}
	{
		p.SetState(2287)
		p.Match(VerilogParserT__17)
	}
	{
		p.SetState(2288)
		p.Generate_item_or_null()
	}
	p.SetState(2291)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 244, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2289)
			p.Match(VerilogParserT__99)
		}
		{
			p.SetState(2290)
			p.Generate_item_or_null()
		}

	}

	return localctx
}

// IGenerate_case_statementContext is an interface to support dynamic dispatch.
type IGenerate_case_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_case_statementContext differentiates from other interfaces.
	IsGenerate_case_statementContext()
}

type Generate_case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_case_statementContext() *Generate_case_statementContext {
	var p = new(Generate_case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_case_statement
	return p
}

func (*Generate_case_statementContext) IsGenerate_case_statementContext() {}

func NewGenerate_case_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_case_statementContext {
	var p = new(Generate_case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_case_statement

	return p
}

func (s *Generate_case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_case_statementContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Generate_case_statementContext) AllGenvar_case_item() []IGenvar_case_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenvar_case_itemContext)(nil)).Elem())
	var tst = make([]IGenvar_case_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenvar_case_itemContext)
		}
	}

	return tst
}

func (s *Generate_case_statementContext) Genvar_case_item(i int) IGenvar_case_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_case_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenvar_case_itemContext)
}

func (s *Generate_case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenerate_case_statement(s)
	}
}

func (s *Generate_case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenerate_case_statement(s)
	}
}

func (p *VerilogParser) Generate_case_statement() (localctx IGenerate_case_statementContext) {
	localctx = NewGenerate_case_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, VerilogParserRULE_generate_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2293)
		p.Match(VerilogParserT__100)
	}
	{
		p.SetState(2294)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2295)
		p.Constant_expression()
	}
	{
		p.SetState(2296)
		p.Match(VerilogParserT__17)
	}
	{
		p.SetState(2297)
		p.Genvar_case_item()
	}
	p.SetState(2301)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__5)|(1<<VerilogParserT__15)|(1<<VerilogParserT__18))) != 0) || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
		{
			p.SetState(2298)
			p.Genvar_case_item()
		}

		p.SetState(2303)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2304)
		p.Match(VerilogParserT__101)
	}

	return localctx
}

// IGenvar_case_itemContext is an interface to support dynamic dispatch.
type IGenvar_case_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_case_itemContext differentiates from other interfaces.
	IsGenvar_case_itemContext()
}

type Genvar_case_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_case_itemContext() *Genvar_case_itemContext {
	var p = new(Genvar_case_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_case_item
	return p
}

func (*Genvar_case_itemContext) IsGenvar_case_itemContext() {}

func NewGenvar_case_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_case_itemContext {
	var p = new(Genvar_case_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_case_item

	return p
}

func (s *Genvar_case_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_case_itemContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Genvar_case_itemContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Genvar_case_itemContext) Generate_item_or_null() IGenerate_item_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_item_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_item_or_nullContext)
}

func (s *Genvar_case_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_case_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_case_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenvar_case_item(s)
	}
}

func (s *Genvar_case_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenvar_case_item(s)
	}
}

func (p *VerilogParser) Genvar_case_item() (localctx IGenvar_case_itemContext) {
	localctx = NewGenvar_case_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, VerilogParserRULE_genvar_case_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2322)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__15, VerilogParserT__18, VerilogParserT__135, VerilogParserT__136, VerilogParserT__140, VerilogParserT__141, VerilogParserT__142, VerilogParserT__143, VerilogParserT__144, VerilogParserT__145, VerilogParserT__146, VerilogParserT__147, VerilogParserT__148, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserStrings, VerilogParserEscaped_identifier, VerilogParserSimple_identifier, VerilogParserDollar_Identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2306)
			p.Constant_expression()
		}
		p.SetState(2311)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(2307)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(2308)
				p.Constant_expression()
			}

			p.SetState(2313)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2314)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(2315)
			p.Generate_item_or_null()
		}

	case VerilogParserT__5:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2317)
			p.Match(VerilogParserT__5)
		}
		p.SetState(2319)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__64 {
			{
				p.SetState(2318)
				p.Match(VerilogParserT__64)
			}

		}
		{
			p.SetState(2321)
			p.Generate_item_or_null()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGenerate_loop_statementContext is an interface to support dynamic dispatch.
type IGenerate_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_loop_statementContext differentiates from other interfaces.
	IsGenerate_loop_statementContext()
}

type Generate_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_loop_statementContext() *Generate_loop_statementContext {
	var p = new(Generate_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_loop_statement
	return p
}

func (*Generate_loop_statementContext) IsGenerate_loop_statementContext() {}

func NewGenerate_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_loop_statementContext {
	var p = new(Generate_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_loop_statement

	return p
}

func (s *Generate_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_loop_statementContext) AllGenvar_assignment() []IGenvar_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenvar_assignmentContext)(nil)).Elem())
	var tst = make([]IGenvar_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenvar_assignmentContext)
		}
	}

	return tst
}

func (s *Generate_loop_statementContext) Genvar_assignment(i int) IGenvar_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenvar_assignmentContext)
}

func (s *Generate_loop_statementContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Generate_loop_statementContext) Generate_block() IGenerate_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_blockContext)
}

func (s *Generate_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenerate_loop_statement(s)
	}
}

func (s *Generate_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenerate_loop_statement(s)
	}
}

func (p *VerilogParser) Generate_loop_statement() (localctx IGenerate_loop_statementContext) {
	localctx = NewGenerate_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, VerilogParserRULE_generate_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2324)
		p.Match(VerilogParserT__102)
	}
	{
		p.SetState(2325)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2326)
		p.Genvar_assignment()
	}
	{
		p.SetState(2327)
		p.Match(VerilogParserT__1)
	}
	{
		p.SetState(2328)
		p.Constant_expression()
	}
	{
		p.SetState(2329)
		p.Match(VerilogParserT__1)
	}
	{
		p.SetState(2330)
		p.Genvar_assignment()
	}
	{
		p.SetState(2331)
		p.Match(VerilogParserT__17)
	}
	{
		p.SetState(2332)
		p.Generate_block()
	}

	return localctx
}

// IGenvar_assignmentContext is an interface to support dynamic dispatch.
type IGenvar_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_assignmentContext differentiates from other interfaces.
	IsGenvar_assignmentContext()
}

type Genvar_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_assignmentContext() *Genvar_assignmentContext {
	var p = new(Genvar_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_assignment
	return p
}

func (*Genvar_assignmentContext) IsGenvar_assignmentContext() {}

func NewGenvar_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_assignmentContext {
	var p = new(Genvar_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_assignment

	return p
}

func (s *Genvar_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_assignmentContext) Genvar_identifier() IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *Genvar_assignmentContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Genvar_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenvar_assignment(s)
	}
}

func (s *Genvar_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenvar_assignment(s)
	}
}

func (p *VerilogParser) Genvar_assignment() (localctx IGenvar_assignmentContext) {
	localctx = NewGenvar_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, VerilogParserRULE_genvar_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2334)
		p.Genvar_identifier()
	}
	{
		p.SetState(2335)
		p.Match(VerilogParserT__50)
	}
	{
		p.SetState(2336)
		p.Constant_expression()
	}

	return localctx
}

// IGenerate_blockContext is an interface to support dynamic dispatch.
type IGenerate_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_blockContext differentiates from other interfaces.
	IsGenerate_blockContext()
}

type Generate_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_blockContext() *Generate_blockContext {
	var p = new(Generate_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_block
	return p
}

func (*Generate_blockContext) IsGenerate_blockContext() {}

func NewGenerate_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_blockContext {
	var p = new(Generate_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_block

	return p
}

func (s *Generate_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_blockContext) Generate_block_identifier() IGenerate_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_block_identifierContext)
}

func (s *Generate_blockContext) AllGenerate_item() []IGenerate_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem())
	var tst = make([]IGenerate_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_itemContext)
		}
	}

	return tst
}

func (s *Generate_blockContext) Generate_item(i int) IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenerate_block(s)
	}
}

func (s *Generate_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenerate_block(s)
	}
}

func (p *VerilogParser) Generate_block() (localctx IGenerate_blockContext) {
	localctx = NewGenerate_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, VerilogParserRULE_generate_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2338)
		p.Match(VerilogParserT__103)
	}
	p.SetState(2341)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__64 {
		{
			p.SetState(2339)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(2340)
			p.Generate_block_identifier()
		}

	}
	p.SetState(2346)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-16)&-(0x1f+1)) == 0 && ((1<<uint((_la-16)))&((1<<(VerilogParserT__15-16))|(1<<(VerilogParserT__22-16))|(1<<(VerilogParserT__25-16))|(1<<(VerilogParserT__26-16))|(1<<(VerilogParserT__27-16))|(1<<(VerilogParserT__28-16))|(1<<(VerilogParserT__34-16))|(1<<(VerilogParserT__35-16))|(1<<(VerilogParserT__36-16))|(1<<(VerilogParserT__37-16))|(1<<(VerilogParserT__40-16))|(1<<(VerilogParserT__41-16))|(1<<(VerilogParserT__42-16))|(1<<(VerilogParserT__43-16))|(1<<(VerilogParserT__44-16))|(1<<(VerilogParserT__45-16))|(1<<(VerilogParserT__46-16)))) != 0) || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(VerilogParserT__47-48))|(1<<(VerilogParserT__48-48))|(1<<(VerilogParserT__49-48))|(1<<(VerilogParserT__65-48))|(1<<(VerilogParserT__68-48))|(1<<(VerilogParserT__70-48))|(1<<(VerilogParserT__71-48))|(1<<(VerilogParserT__72-48))|(1<<(VerilogParserT__73-48))|(1<<(VerilogParserT__74-48))|(1<<(VerilogParserT__75-48))|(1<<(VerilogParserT__76-48))|(1<<(VerilogParserT__77-48))|(1<<(VerilogParserT__78-48)))) != 0) || (((_la-80)&-(0x1f+1)) == 0 && ((1<<uint((_la-80)))&((1<<(VerilogParserT__79-80))|(1<<(VerilogParserT__80-80))|(1<<(VerilogParserT__81-80))|(1<<(VerilogParserT__82-80))|(1<<(VerilogParserT__83-80))|(1<<(VerilogParserT__84-80))|(1<<(VerilogParserT__85-80))|(1<<(VerilogParserT__86-80))|(1<<(VerilogParserT__87-80))|(1<<(VerilogParserT__88-80))|(1<<(VerilogParserT__89-80))|(1<<(VerilogParserT__90-80))|(1<<(VerilogParserT__91-80))|(1<<(VerilogParserT__92-80))|(1<<(VerilogParserT__93-80))|(1<<(VerilogParserT__94-80))|(1<<(VerilogParserT__95-80))|(1<<(VerilogParserT__98-80))|(1<<(VerilogParserT__100-80))|(1<<(VerilogParserT__102-80))|(1<<(VerilogParserT__103-80))|(1<<(VerilogParserT__105-80))|(1<<(VerilogParserT__106-80))|(1<<(VerilogParserT__107-80)))) != 0) || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2343)
			p.Generate_item()
		}

		p.SetState(2348)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2349)
		p.Match(VerilogParserT__104)
	}

	return localctx
}

// IContinuous_assignContext is an interface to support dynamic dispatch.
type IContinuous_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinuous_assignContext differentiates from other interfaces.
	IsContinuous_assignContext()
}

type Continuous_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinuous_assignContext() *Continuous_assignContext {
	var p = new(Continuous_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_continuous_assign
	return p
}

func (*Continuous_assignContext) IsContinuous_assignContext() {}

func NewContinuous_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continuous_assignContext {
	var p = new(Continuous_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_continuous_assign

	return p
}

func (s *Continuous_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Continuous_assignContext) List_of_net_assignments() IList_of_net_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_net_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_net_assignmentsContext)
}

func (s *Continuous_assignContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Continuous_assignContext) Delay3() IDelay3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay3Context)
}

func (s *Continuous_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continuous_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Continuous_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterContinuous_assign(s)
	}
}

func (s *Continuous_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitContinuous_assign(s)
	}
}

func (p *VerilogParser) Continuous_assign() (localctx IContinuous_assignContext) {
	localctx = NewContinuous_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, VerilogParserRULE_continuous_assign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2351)
		p.Match(VerilogParserT__105)
	}
	p.SetState(2353)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__15 {
		{
			p.SetState(2352)
			p.Drive_strength()
		}

	}
	p.SetState(2356)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__14 {
		{
			p.SetState(2355)
			p.Delay3()
		}

	}
	{
		p.SetState(2358)
		p.List_of_net_assignments()
	}
	{
		p.SetState(2359)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// IList_of_net_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_net_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_net_assignmentsContext differentiates from other interfaces.
	IsList_of_net_assignmentsContext()
}

type List_of_net_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_net_assignmentsContext() *List_of_net_assignmentsContext {
	var p = new(List_of_net_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_net_assignments
	return p
}

func (*List_of_net_assignmentsContext) IsList_of_net_assignmentsContext() {}

func NewList_of_net_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_net_assignmentsContext {
	var p = new(List_of_net_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_net_assignments

	return p
}

func (s *List_of_net_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_net_assignmentsContext) AllNet_assignment() []INet_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_assignmentContext)(nil)).Elem())
	var tst = make([]INet_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_net_assignmentsContext) Net_assignment(i int) INet_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_assignmentContext)
}

func (s *List_of_net_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_net_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_net_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_net_assignments(s)
	}
}

func (s *List_of_net_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_net_assignments(s)
	}
}

func (p *VerilogParser) List_of_net_assignments() (localctx IList_of_net_assignmentsContext) {
	localctx = NewList_of_net_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, VerilogParserRULE_list_of_net_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2361)
		p.Net_assignment()
	}
	p.SetState(2366)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(2362)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(2363)
			p.Net_assignment()
		}

		p.SetState(2368)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INet_assignmentContext is an interface to support dynamic dispatch.
type INet_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_assignmentContext differentiates from other interfaces.
	IsNet_assignmentContext()
}

type Net_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_assignmentContext() *Net_assignmentContext {
	var p = new(Net_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_assignment
	return p
}

func (*Net_assignmentContext) IsNet_assignmentContext() {}

func NewNet_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_assignmentContext {
	var p = new(Net_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_assignment

	return p
}

func (s *Net_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_assignmentContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Net_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Net_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNet_assignment(s)
	}
}

func (s *Net_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNet_assignment(s)
	}
}

func (p *VerilogParser) Net_assignment() (localctx INet_assignmentContext) {
	localctx = NewNet_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, VerilogParserRULE_net_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2369)
		p.Net_lvalue()
	}
	{
		p.SetState(2370)
		p.Match(VerilogParserT__50)
	}
	{
		p.SetState(2371)
		p.Expression()
	}

	return localctx
}

// IInitial_constructContext is an interface to support dynamic dispatch.
type IInitial_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitial_constructContext differentiates from other interfaces.
	IsInitial_constructContext()
}

type Initial_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitial_constructContext() *Initial_constructContext {
	var p = new(Initial_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_initial_construct
	return p
}

func (*Initial_constructContext) IsInitial_constructContext() {}

func NewInitial_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Initial_constructContext {
	var p = new(Initial_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_initial_construct

	return p
}

func (s *Initial_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Initial_constructContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Initial_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Initial_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Initial_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterInitial_construct(s)
	}
}

func (s *Initial_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitInitial_construct(s)
	}
}

func (p *VerilogParser) Initial_construct() (localctx IInitial_constructContext) {
	localctx = NewInitial_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, VerilogParserRULE_initial_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2373)
		p.Match(VerilogParserT__106)
	}
	{
		p.SetState(2374)
		p.Statement()
	}

	return localctx
}

// IAlways_constructContext is an interface to support dynamic dispatch.
type IAlways_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlways_constructContext differentiates from other interfaces.
	IsAlways_constructContext()
}

type Always_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlways_constructContext() *Always_constructContext {
	var p = new(Always_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_always_construct
	return p
}

func (*Always_constructContext) IsAlways_constructContext() {}

func NewAlways_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Always_constructContext {
	var p = new(Always_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_always_construct

	return p
}

func (s *Always_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Always_constructContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Always_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Always_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Always_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterAlways_construct(s)
	}
}

func (s *Always_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitAlways_construct(s)
	}
}

func (p *VerilogParser) Always_construct() (localctx IAlways_constructContext) {
	localctx = NewAlways_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, VerilogParserRULE_always_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2376)
		p.Match(VerilogParserT__107)
	}
	{
		p.SetState(2377)
		p.Statement()
	}

	return localctx
}

// IBlocking_assignmentContext is an interface to support dynamic dispatch.
type IBlocking_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlocking_assignmentContext differentiates from other interfaces.
	IsBlocking_assignmentContext()
}

type Blocking_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlocking_assignmentContext() *Blocking_assignmentContext {
	var p = new(Blocking_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_blocking_assignment
	return p
}

func (*Blocking_assignmentContext) IsBlocking_assignmentContext() {}

func NewBlocking_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Blocking_assignmentContext {
	var p = new(Blocking_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_blocking_assignment

	return p
}

func (s *Blocking_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Blocking_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Blocking_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Blocking_assignmentContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Blocking_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Blocking_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Blocking_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterBlocking_assignment(s)
	}
}

func (s *Blocking_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitBlocking_assignment(s)
	}
}

func (p *VerilogParser) Blocking_assignment() (localctx IBlocking_assignmentContext) {
	localctx = NewBlocking_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, VerilogParserRULE_blocking_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2379)
		p.Variable_lvalue()
	}
	{
		p.SetState(2380)
		p.Match(VerilogParserT__50)
	}
	p.SetState(2382)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__14 || _la == VerilogParserT__114 || _la == VerilogParserT__116 {
		{
			p.SetState(2381)
			p.Delay_or_event_control()
		}

	}
	{
		p.SetState(2384)
		p.Expression()
	}

	return localctx
}

// INonblocking_assignmentContext is an interface to support dynamic dispatch.
type INonblocking_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonblocking_assignmentContext differentiates from other interfaces.
	IsNonblocking_assignmentContext()
}

type Nonblocking_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonblocking_assignmentContext() *Nonblocking_assignmentContext {
	var p = new(Nonblocking_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_nonblocking_assignment
	return p
}

func (*Nonblocking_assignmentContext) IsNonblocking_assignmentContext() {}

func NewNonblocking_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nonblocking_assignmentContext {
	var p = new(Nonblocking_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_nonblocking_assignment

	return p
}

func (s *Nonblocking_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Nonblocking_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Nonblocking_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Nonblocking_assignmentContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Nonblocking_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonblocking_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nonblocking_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNonblocking_assignment(s)
	}
}

func (s *Nonblocking_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNonblocking_assignment(s)
	}
}

func (p *VerilogParser) Nonblocking_assignment() (localctx INonblocking_assignmentContext) {
	localctx = NewNonblocking_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, VerilogParserRULE_nonblocking_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2386)
		p.Variable_lvalue()
	}
	{
		p.SetState(2387)
		p.Match(VerilogParserT__108)
	}
	p.SetState(2389)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__14 || _la == VerilogParserT__114 || _la == VerilogParserT__116 {
		{
			p.SetState(2388)
			p.Delay_or_event_control()
		}

	}
	{
		p.SetState(2391)
		p.Expression()
	}

	return localctx
}

// IProcedural_continuous_assignmentsContext is an interface to support dynamic dispatch.
type IProcedural_continuous_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_continuous_assignmentsContext differentiates from other interfaces.
	IsProcedural_continuous_assignmentsContext()
}

type Procedural_continuous_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_continuous_assignmentsContext() *Procedural_continuous_assignmentsContext {
	var p = new(Procedural_continuous_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_procedural_continuous_assignments
	return p
}

func (*Procedural_continuous_assignmentsContext) IsProcedural_continuous_assignmentsContext() {}

func NewProcedural_continuous_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_continuous_assignmentsContext {
	var p = new(Procedural_continuous_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_procedural_continuous_assignments

	return p
}

func (s *Procedural_continuous_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_continuous_assignmentsContext) Variable_assignment() IVariable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignmentContext)
}

func (s *Procedural_continuous_assignmentsContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Procedural_continuous_assignmentsContext) Net_assignment() INet_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_assignmentContext)
}

func (s *Procedural_continuous_assignmentsContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Procedural_continuous_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_continuous_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_continuous_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterProcedural_continuous_assignments(s)
	}
}

func (s *Procedural_continuous_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitProcedural_continuous_assignments(s)
	}
}

func (p *VerilogParser) Procedural_continuous_assignments() (localctx IProcedural_continuous_assignmentsContext) {
	localctx = NewProcedural_continuous_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, VerilogParserRULE_procedural_continuous_assignments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2405)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 256, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2393)
			p.Match(VerilogParserT__105)
		}
		{
			p.SetState(2394)
			p.Variable_assignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2395)
			p.Match(VerilogParserT__109)
		}
		{
			p.SetState(2396)
			p.Variable_lvalue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2397)
			p.Match(VerilogParserT__110)
		}
		{
			p.SetState(2398)
			p.Variable_assignment()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2399)
			p.Match(VerilogParserT__110)
		}
		{
			p.SetState(2400)
			p.Net_assignment()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2401)
			p.Match(VerilogParserT__111)
		}
		{
			p.SetState(2402)
			p.Variable_lvalue()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2403)
			p.Match(VerilogParserT__111)
		}
		{
			p.SetState(2404)
			p.Net_lvalue()
		}

	}

	return localctx
}

// IFunction_blocking_assignmentContext is an interface to support dynamic dispatch.
type IFunction_blocking_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_blocking_assignmentContext differentiates from other interfaces.
	IsFunction_blocking_assignmentContext()
}

type Function_blocking_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_blocking_assignmentContext() *Function_blocking_assignmentContext {
	var p = new(Function_blocking_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_blocking_assignment
	return p
}

func (*Function_blocking_assignmentContext) IsFunction_blocking_assignmentContext() {}

func NewFunction_blocking_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_blocking_assignmentContext {
	var p = new(Function_blocking_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_blocking_assignment

	return p
}

func (s *Function_blocking_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_blocking_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Function_blocking_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_blocking_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_blocking_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_blocking_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_blocking_assignment(s)
	}
}

func (s *Function_blocking_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_blocking_assignment(s)
	}
}

func (p *VerilogParser) Function_blocking_assignment() (localctx IFunction_blocking_assignmentContext) {
	localctx = NewFunction_blocking_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, VerilogParserRULE_function_blocking_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2407)
		p.Variable_lvalue()
	}
	{
		p.SetState(2408)
		p.Match(VerilogParserT__50)
	}
	{
		p.SetState(2409)
		p.Expression()
	}

	return localctx
}

// IFunction_statement_or_nullContext is an interface to support dynamic dispatch.
type IFunction_statement_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_statement_or_nullContext differentiates from other interfaces.
	IsFunction_statement_or_nullContext()
}

type Function_statement_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_statement_or_nullContext() *Function_statement_or_nullContext {
	var p = new(Function_statement_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_statement_or_null
	return p
}

func (*Function_statement_or_nullContext) IsFunction_statement_or_nullContext() {}

func NewFunction_statement_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_statement_or_nullContext {
	var p = new(Function_statement_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_statement_or_null

	return p
}

func (s *Function_statement_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_statement_or_nullContext) Function_statement() IFunction_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_statementContext)
}

func (s *Function_statement_or_nullContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Function_statement_or_nullContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Function_statement_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_statement_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_statement_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_statement_or_null(s)
	}
}

func (s *Function_statement_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_statement_or_null(s)
	}
}

func (p *VerilogParser) Function_statement_or_null() (localctx IFunction_statement_or_nullContext) {
	localctx = NewFunction_statement_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, VerilogParserRULE_function_statement_or_null)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2419)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 258, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2411)
			p.Function_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2415)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2412)
				p.Attribute_instance()
			}

			p.SetState(2417)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2418)
			p.Match(VerilogParserT__1)
		}

	}

	return localctx
}

// IFunction_seq_blockContext is an interface to support dynamic dispatch.
type IFunction_seq_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_seq_blockContext differentiates from other interfaces.
	IsFunction_seq_blockContext()
}

type Function_seq_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_seq_blockContext() *Function_seq_blockContext {
	var p = new(Function_seq_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_seq_block
	return p
}

func (*Function_seq_blockContext) IsFunction_seq_blockContext() {}

func NewFunction_seq_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_seq_blockContext {
	var p = new(Function_seq_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_seq_block

	return p
}

func (s *Function_seq_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_seq_blockContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Function_seq_blockContext) AllFunction_statement() []IFunction_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem())
	var tst = make([]IFunction_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_statementContext)
		}
	}

	return tst
}

func (s *Function_seq_blockContext) Function_statement(i int) IFunction_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_statementContext)
}

func (s *Function_seq_blockContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Function_seq_blockContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Function_seq_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_seq_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_seq_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_seq_block(s)
	}
}

func (s *Function_seq_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_seq_block(s)
	}
}

func (p *VerilogParser) Function_seq_block() (localctx IFunction_seq_blockContext) {
	localctx = NewFunction_seq_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, VerilogParserRULE_function_seq_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2421)
		p.Match(VerilogParserT__103)
	}
	p.SetState(2430)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__64 {
		{
			p.SetState(2422)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(2423)
			p.Block_identifier()
		}
		p.SetState(2427)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 259, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2424)
					p.Block_item_declaration()
				}

			}
			p.SetState(2429)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 259, p.GetParserRuleContext())
		}

	}
	p.SetState(2435)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__15 || _la == VerilogParserT__18 || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(VerilogParserT__98-99))|(1<<(VerilogParserT__100-99))|(1<<(VerilogParserT__102-99))|(1<<(VerilogParserT__103-99))|(1<<(VerilogParserT__114-99))|(1<<(VerilogParserT__115-99))|(1<<(VerilogParserT__122-99))|(1<<(VerilogParserT__123-99))|(1<<(VerilogParserT__124-99))|(1<<(VerilogParserT__125-99)))) != 0) || (((_la-176)&-(0x1f+1)) == 0 && ((1<<uint((_la-176)))&((1<<(VerilogParserEscaped_identifier-176))|(1<<(VerilogParserSimple_identifier-176))|(1<<(VerilogParserDollar_Identifier-176)))) != 0) {
		{
			p.SetState(2432)
			p.Function_statement()
		}

		p.SetState(2437)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2438)
		p.Match(VerilogParserT__104)
	}

	return localctx
}

// IVariable_assignmentContext is an interface to support dynamic dispatch.
type IVariable_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_assignmentContext differentiates from other interfaces.
	IsVariable_assignmentContext()
}

type Variable_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_assignmentContext() *Variable_assignmentContext {
	var p = new(Variable_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_assignment
	return p
}

func (*Variable_assignmentContext) IsVariable_assignmentContext() {}

func NewVariable_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_assignmentContext {
	var p = new(Variable_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_assignment

	return p
}

func (s *Variable_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Variable_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterVariable_assignment(s)
	}
}

func (s *Variable_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitVariable_assignment(s)
	}
}

func (p *VerilogParser) Variable_assignment() (localctx IVariable_assignmentContext) {
	localctx = NewVariable_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, VerilogParserRULE_variable_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2440)
		p.Variable_lvalue()
	}
	{
		p.SetState(2441)
		p.Match(VerilogParserT__50)
	}
	{
		p.SetState(2442)
		p.Expression()
	}

	return localctx
}

// IPar_blockContext is an interface to support dynamic dispatch.
type IPar_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPar_blockContext differentiates from other interfaces.
	IsPar_blockContext()
}

type Par_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPar_blockContext() *Par_blockContext {
	var p = new(Par_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_par_block
	return p
}

func (*Par_blockContext) IsPar_blockContext() {}

func NewPar_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Par_blockContext {
	var p = new(Par_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_par_block

	return p
}

func (s *Par_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Par_blockContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Par_blockContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Par_blockContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Par_blockContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Par_blockContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Par_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Par_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Par_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPar_block(s)
	}
}

func (s *Par_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPar_block(s)
	}
}

func (p *VerilogParser) Par_block() (localctx IPar_blockContext) {
	localctx = NewPar_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, VerilogParserRULE_par_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2444)
		p.Match(VerilogParserT__112)
	}
	p.SetState(2453)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__64 {
		{
			p.SetState(2445)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(2446)
			p.Block_identifier()
		}
		p.SetState(2450)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 262, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2447)
					p.Block_item_declaration()
				}

			}
			p.SetState(2452)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 262, p.GetParserRuleContext())
		}

	}
	p.SetState(2458)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__14)|(1<<VerilogParserT__15)|(1<<VerilogParserT__18))) != 0) || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(VerilogParserT__98-99))|(1<<(VerilogParserT__100-99))|(1<<(VerilogParserT__102-99))|(1<<(VerilogParserT__103-99))|(1<<(VerilogParserT__105-99))|(1<<(VerilogParserT__109-99))|(1<<(VerilogParserT__110-99))|(1<<(VerilogParserT__111-99))|(1<<(VerilogParserT__112-99))|(1<<(VerilogParserT__114-99))|(1<<(VerilogParserT__115-99))|(1<<(VerilogParserT__116-99))|(1<<(VerilogParserT__118-99))|(1<<(VerilogParserT__121-99))|(1<<(VerilogParserT__122-99))|(1<<(VerilogParserT__123-99))|(1<<(VerilogParserT__124-99))|(1<<(VerilogParserT__125-99)))) != 0) || (((_la-176)&-(0x1f+1)) == 0 && ((1<<uint((_la-176)))&((1<<(VerilogParserEscaped_identifier-176))|(1<<(VerilogParserSimple_identifier-176))|(1<<(VerilogParserDollar_Identifier-176)))) != 0) {
		{
			p.SetState(2455)
			p.Statement()
		}

		p.SetState(2460)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2461)
		p.Match(VerilogParserT__113)
	}

	return localctx
}

// ISeq_blockContext is an interface to support dynamic dispatch.
type ISeq_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeq_blockContext differentiates from other interfaces.
	IsSeq_blockContext()
}

type Seq_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeq_blockContext() *Seq_blockContext {
	var p = new(Seq_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_seq_block
	return p
}

func (*Seq_blockContext) IsSeq_blockContext() {}

func NewSeq_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seq_blockContext {
	var p = new(Seq_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_seq_block

	return p
}

func (s *Seq_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Seq_blockContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Seq_blockContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Seq_blockContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Seq_blockContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Seq_blockContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Seq_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seq_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seq_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSeq_block(s)
	}
}

func (s *Seq_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSeq_block(s)
	}
}

func (p *VerilogParser) Seq_block() (localctx ISeq_blockContext) {
	localctx = NewSeq_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, VerilogParserRULE_seq_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2463)
		p.Match(VerilogParserT__103)
	}
	p.SetState(2472)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__64 {
		{
			p.SetState(2464)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(2465)
			p.Block_identifier()
		}
		p.SetState(2469)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 265, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2466)
					p.Block_item_declaration()
				}

			}
			p.SetState(2471)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 265, p.GetParserRuleContext())
		}

	}
	p.SetState(2477)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__14)|(1<<VerilogParserT__15)|(1<<VerilogParserT__18))) != 0) || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(VerilogParserT__98-99))|(1<<(VerilogParserT__100-99))|(1<<(VerilogParserT__102-99))|(1<<(VerilogParserT__103-99))|(1<<(VerilogParserT__105-99))|(1<<(VerilogParserT__109-99))|(1<<(VerilogParserT__110-99))|(1<<(VerilogParserT__111-99))|(1<<(VerilogParserT__112-99))|(1<<(VerilogParserT__114-99))|(1<<(VerilogParserT__115-99))|(1<<(VerilogParserT__116-99))|(1<<(VerilogParserT__118-99))|(1<<(VerilogParserT__121-99))|(1<<(VerilogParserT__122-99))|(1<<(VerilogParserT__123-99))|(1<<(VerilogParserT__124-99))|(1<<(VerilogParserT__125-99)))) != 0) || (((_la-176)&-(0x1f+1)) == 0 && ((1<<uint((_la-176)))&((1<<(VerilogParserEscaped_identifier-176))|(1<<(VerilogParserSimple_identifier-176))|(1<<(VerilogParserDollar_Identifier-176)))) != 0) {
		{
			p.SetState(2474)
			p.Statement()
		}

		p.SetState(2479)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2480)
		p.Match(VerilogParserT__104)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Blocking_assignment() IBlocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlocking_assignmentContext)
}

func (s *StatementContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *StatementContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *StatementContext) Case_statement() ICase_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_statementContext)
}

func (s *StatementContext) Conditional_statement() IConditional_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_statementContext)
}

func (s *StatementContext) Disable_statement() IDisable_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisable_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisable_statementContext)
}

func (s *StatementContext) Event_trigger() IEvent_triggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_triggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_triggerContext)
}

func (s *StatementContext) Loop_statement() ILoop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_statementContext)
}

func (s *StatementContext) Nonblocking_assignment() INonblocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonblocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonblocking_assignmentContext)
}

func (s *StatementContext) Par_block() IPar_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPar_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPar_blockContext)
}

func (s *StatementContext) Procedural_continuous_assignments() IProcedural_continuous_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_continuous_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_continuous_assignmentsContext)
}

func (s *StatementContext) Procedural_timing_control_statement() IProcedural_timing_control_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_timing_control_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_timing_control_statementContext)
}

func (s *StatementContext) Seq_block() ISeq_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_blockContext)
}

func (s *StatementContext) System_task_enable() ISystem_task_enableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_task_enableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_task_enableContext)
}

func (s *StatementContext) Task_enable() ITask_enableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_enableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_enableContext)
}

func (s *StatementContext) Wait_statement() IWait_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWait_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWait_statementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *VerilogParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, VerilogParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2586)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 282, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2485)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2482)
				p.Attribute_instance()
			}

			p.SetState(2487)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2488)
			p.Blocking_assignment()
		}
		{
			p.SetState(2489)
			p.Match(VerilogParserT__1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2494)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2491)
				p.Attribute_instance()
			}

			p.SetState(2496)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2497)
			p.Case_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2501)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2498)
				p.Attribute_instance()
			}

			p.SetState(2503)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2504)
			p.Conditional_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(2508)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2505)
				p.Attribute_instance()
			}

			p.SetState(2510)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2511)
			p.Disable_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(2515)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2512)
				p.Attribute_instance()
			}

			p.SetState(2517)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2518)
			p.Event_trigger()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(2522)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2519)
				p.Attribute_instance()
			}

			p.SetState(2524)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2525)
			p.Loop_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(2529)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2526)
				p.Attribute_instance()
			}

			p.SetState(2531)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2532)
			p.Nonblocking_assignment()
		}
		{
			p.SetState(2533)
			p.Match(VerilogParserT__1)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(2538)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2535)
				p.Attribute_instance()
			}

			p.SetState(2540)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2541)
			p.Par_block()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(2545)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2542)
				p.Attribute_instance()
			}

			p.SetState(2547)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2548)
			p.Procedural_continuous_assignments()
		}
		{
			p.SetState(2549)
			p.Match(VerilogParserT__1)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(2554)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2551)
				p.Attribute_instance()
			}

			p.SetState(2556)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2557)
			p.Procedural_timing_control_statement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		p.SetState(2561)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2558)
				p.Attribute_instance()
			}

			p.SetState(2563)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2564)
			p.Seq_block()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		p.SetState(2568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2565)
				p.Attribute_instance()
			}

			p.SetState(2570)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2571)
			p.System_task_enable()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		p.SetState(2575)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2572)
				p.Attribute_instance()
			}

			p.SetState(2577)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2578)
			p.Task_enable()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		p.SetState(2582)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2579)
				p.Attribute_instance()
			}

			p.SetState(2584)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2585)
			p.Wait_statement()
		}

	}

	return localctx
}

// IStatement_or_nullContext is an interface to support dynamic dispatch.
type IStatement_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_or_nullContext differentiates from other interfaces.
	IsStatement_or_nullContext()
}

type Statement_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_or_nullContext() *Statement_or_nullContext {
	var p = new(Statement_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_statement_or_null
	return p
}

func (*Statement_or_nullContext) IsStatement_or_nullContext() {}

func NewStatement_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_or_nullContext {
	var p = new(Statement_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_statement_or_null

	return p
}

func (s *Statement_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_or_nullContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Statement_or_nullContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Statement_or_nullContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Statement_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterStatement_or_null(s)
	}
}

func (s *Statement_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitStatement_or_null(s)
	}
}

func (p *VerilogParser) Statement_or_null() (localctx IStatement_or_nullContext) {
	localctx = NewStatement_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, VerilogParserRULE_statement_or_null)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2596)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 284, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2588)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2592)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2589)
				p.Attribute_instance()
			}

			p.SetState(2594)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2595)
			p.Match(VerilogParserT__1)
		}

	}

	return localctx
}

// IFunction_statementContext is an interface to support dynamic dispatch.
type IFunction_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_statementContext differentiates from other interfaces.
	IsFunction_statementContext()
}

type Function_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_statementContext() *Function_statementContext {
	var p = new(Function_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_statement
	return p
}

func (*Function_statementContext) IsFunction_statementContext() {}

func NewFunction_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_statementContext {
	var p = new(Function_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_statement

	return p
}

func (s *Function_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_statementContext) Function_blocking_assignment() IFunction_blocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_blocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_blocking_assignmentContext)
}

func (s *Function_statementContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Function_statementContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Function_statementContext) Function_case_statement() IFunction_case_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_case_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_case_statementContext)
}

func (s *Function_statementContext) Function_conditional_statement() IFunction_conditional_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_conditional_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_conditional_statementContext)
}

func (s *Function_statementContext) Function_loop_statement() IFunction_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_loop_statementContext)
}

func (s *Function_statementContext) Function_seq_block() IFunction_seq_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_seq_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_seq_blockContext)
}

func (s *Function_statementContext) Disable_statement() IDisable_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisable_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisable_statementContext)
}

func (s *Function_statementContext) System_task_enable() ISystem_task_enableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_task_enableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_task_enableContext)
}

func (s *Function_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_statement(s)
	}
}

func (s *Function_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_statement(s)
	}
}

func (p *VerilogParser) Function_statement() (localctx IFunction_statementContext) {
	localctx = NewFunction_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, VerilogParserRULE_function_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2649)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2601)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2598)
				p.Attribute_instance()
			}

			p.SetState(2603)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2604)
			p.Function_blocking_assignment()
		}
		{
			p.SetState(2605)
			p.Match(VerilogParserT__1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2610)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2607)
				p.Attribute_instance()
			}

			p.SetState(2612)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2613)
			p.Function_case_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2617)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2614)
				p.Attribute_instance()
			}

			p.SetState(2619)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2620)
			p.Function_conditional_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(2624)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2621)
				p.Attribute_instance()
			}

			p.SetState(2626)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2627)
			p.Function_loop_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(2631)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2628)
				p.Attribute_instance()
			}

			p.SetState(2633)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2634)
			p.Function_seq_block()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(2638)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2635)
				p.Attribute_instance()
			}

			p.SetState(2640)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2641)
			p.Disable_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(2645)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__15 {
			{
				p.SetState(2642)
				p.Attribute_instance()
			}

			p.SetState(2647)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2648)
			p.System_task_enable()
		}

	}

	return localctx
}

// IDelay_or_event_controlContext is an interface to support dynamic dispatch.
type IDelay_or_event_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_or_event_controlContext differentiates from other interfaces.
	IsDelay_or_event_controlContext()
}

type Delay_or_event_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_or_event_controlContext() *Delay_or_event_controlContext {
	var p = new(Delay_or_event_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay_or_event_control
	return p
}

func (*Delay_or_event_controlContext) IsDelay_or_event_controlContext() {}

func NewDelay_or_event_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_or_event_controlContext {
	var p = new(Delay_or_event_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay_or_event_control

	return p
}

func (s *Delay_or_event_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_or_event_controlContext) Delay_control() IDelay_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_controlContext)
}

func (s *Delay_or_event_controlContext) Event_control() IEvent_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_controlContext)
}

func (s *Delay_or_event_controlContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Delay_or_event_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_or_event_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_or_event_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDelay_or_event_control(s)
	}
}

func (s *Delay_or_event_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDelay_or_event_control(s)
	}
}

func (p *VerilogParser) Delay_or_event_control() (localctx IDelay_or_event_controlContext) {
	localctx = NewDelay_or_event_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, VerilogParserRULE_delay_or_event_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2659)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__14:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2651)
			p.Delay_control()
		}

	case VerilogParserT__116:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2652)
			p.Event_control()
		}

	case VerilogParserT__114:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2653)
			p.Match(VerilogParserT__114)
		}
		{
			p.SetState(2654)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2655)
			p.Expression()
		}
		{
			p.SetState(2656)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2657)
			p.Event_control()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDelay_controlContext is an interface to support dynamic dispatch.
type IDelay_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_controlContext differentiates from other interfaces.
	IsDelay_controlContext()
}

type Delay_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_controlContext() *Delay_controlContext {
	var p = new(Delay_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay_control
	return p
}

func (*Delay_controlContext) IsDelay_controlContext() {}

func NewDelay_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_controlContext {
	var p = new(Delay_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay_control

	return p
}

func (s *Delay_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_controlContext) Delay_value() IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Delay_controlContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Delay_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDelay_control(s)
	}
}

func (s *Delay_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDelay_control(s)
	}
}

func (p *VerilogParser) Delay_control() (localctx IDelay_controlContext) {
	localctx = NewDelay_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, VerilogParserRULE_delay_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2668)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 294, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2661)
			p.Match(VerilogParserT__14)
		}
		{
			p.SetState(2662)
			p.Delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2663)
			p.Match(VerilogParserT__14)
		}
		{
			p.SetState(2664)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2665)
			p.Mintypmax_expression()
		}
		{
			p.SetState(2666)
			p.Match(VerilogParserT__17)
		}

	}

	return localctx
}

// IDisable_statementContext is an interface to support dynamic dispatch.
type IDisable_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisable_statementContext differentiates from other interfaces.
	IsDisable_statementContext()
}

type Disable_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisable_statementContext() *Disable_statementContext {
	var p = new(Disable_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_disable_statement
	return p
}

func (*Disable_statementContext) IsDisable_statementContext() {}

func NewDisable_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Disable_statementContext {
	var p = new(Disable_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_disable_statement

	return p
}

func (s *Disable_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Disable_statementContext) Hierarchical_task_identifier() IHierarchical_task_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_task_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_task_identifierContext)
}

func (s *Disable_statementContext) Hierarchical_block_identifier() IHierarchical_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_block_identifierContext)
}

func (s *Disable_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Disable_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Disable_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDisable_statement(s)
	}
}

func (s *Disable_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDisable_statement(s)
	}
}

func (p *VerilogParser) Disable_statement() (localctx IDisable_statementContext) {
	localctx = NewDisable_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, VerilogParserRULE_disable_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2678)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 295, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2670)
			p.Match(VerilogParserT__115)
		}
		{
			p.SetState(2671)
			p.Hierarchical_task_identifier()
		}
		{
			p.SetState(2672)
			p.Match(VerilogParserT__1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2674)
			p.Match(VerilogParserT__115)
		}
		{
			p.SetState(2675)
			p.Hierarchical_block_identifier()
		}
		{
			p.SetState(2676)
			p.Match(VerilogParserT__1)
		}

	}

	return localctx
}

// IEvent_controlContext is an interface to support dynamic dispatch.
type IEvent_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_controlContext differentiates from other interfaces.
	IsEvent_controlContext()
}

type Event_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_controlContext() *Event_controlContext {
	var p = new(Event_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_control
	return p
}

func (*Event_controlContext) IsEvent_controlContext() {}

func NewEvent_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_controlContext {
	var p = new(Event_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_control

	return p
}

func (s *Event_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_controlContext) Event_identifier() IEvent_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_identifierContext)
}

func (s *Event_controlContext) Event_expression() IEvent_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_expressionContext)
}

func (s *Event_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEvent_control(s)
	}
}

func (s *Event_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEvent_control(s)
	}
}

func (p *VerilogParser) Event_control() (localctx IEvent_controlContext) {
	localctx = NewEvent_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, VerilogParserRULE_event_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2693)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 296, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2680)
			p.Match(VerilogParserT__116)
		}
		{
			p.SetState(2681)
			p.Event_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2682)
			p.Match(VerilogParserT__116)
		}
		{
			p.SetState(2683)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2684)
			p.Event_expression()
		}
		{
			p.SetState(2685)
			p.Match(VerilogParserT__17)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2687)
			p.Match(VerilogParserT__116)
		}
		{
			p.SetState(2688)
			p.Match(VerilogParserT__117)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2689)
			p.Match(VerilogParserT__116)
		}
		{
			p.SetState(2690)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2691)
			p.Match(VerilogParserT__117)
		}
		{
			p.SetState(2692)
			p.Match(VerilogParserT__17)
		}

	}

	return localctx
}

// IEvent_triggerContext is an interface to support dynamic dispatch.
type IEvent_triggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_triggerContext differentiates from other interfaces.
	IsEvent_triggerContext()
}

type Event_triggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_triggerContext() *Event_triggerContext {
	var p = new(Event_triggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_trigger
	return p
}

func (*Event_triggerContext) IsEvent_triggerContext() {}

func NewEvent_triggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_triggerContext {
	var p = new(Event_triggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_trigger

	return p
}

func (s *Event_triggerContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_triggerContext) Hierarchical_event_identifier() IHierarchical_event_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_event_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_event_identifierContext)
}

func (s *Event_triggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_triggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_triggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEvent_trigger(s)
	}
}

func (s *Event_triggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEvent_trigger(s)
	}
}

func (p *VerilogParser) Event_trigger() (localctx IEvent_triggerContext) {
	localctx = NewEvent_triggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, VerilogParserRULE_event_trigger)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2695)
		p.Match(VerilogParserT__118)
	}
	{
		p.SetState(2696)
		p.Hierarchical_event_identifier()
	}
	{
		p.SetState(2697)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// IEvent_expressionContext is an interface to support dynamic dispatch.
type IEvent_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_expressionContext differentiates from other interfaces.
	IsEvent_expressionContext()
}

type Event_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_expressionContext() *Event_expressionContext {
	var p = new(Event_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_expression
	return p
}

func (*Event_expressionContext) IsEvent_expressionContext() {}

func NewEvent_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_expressionContext {
	var p = new(Event_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_expression

	return p
}

func (s *Event_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_expressionContext) AllEvent_primary() []IEvent_primaryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvent_primaryContext)(nil)).Elem())
	var tst = make([]IEvent_primaryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvent_primaryContext)
		}
	}

	return tst
}

func (s *Event_expressionContext) Event_primary(i int) IEvent_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_primaryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvent_primaryContext)
}

func (s *Event_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEvent_expression(s)
	}
}

func (s *Event_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEvent_expression(s)
	}
}

func (p *VerilogParser) Event_expression() (localctx IEvent_expressionContext) {
	localctx = NewEvent_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, VerilogParserRULE_event_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2699)
		p.Event_primary()
	}
	p.SetState(2706)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 || _la == VerilogParserT__84 {
		p.SetState(2704)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case VerilogParserT__84:
			{
				p.SetState(2700)
				p.Match(VerilogParserT__84)
			}
			{
				p.SetState(2701)
				p.Event_primary()
			}

		case VerilogParserT__16:
			{
				p.SetState(2702)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(2703)
				p.Event_primary()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2708)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEvent_primaryContext is an interface to support dynamic dispatch.
type IEvent_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_primaryContext differentiates from other interfaces.
	IsEvent_primaryContext()
}

type Event_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_primaryContext() *Event_primaryContext {
	var p = new(Event_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_primary
	return p
}

func (*Event_primaryContext) IsEvent_primaryContext() {}

func NewEvent_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_primaryContext {
	var p = new(Event_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_primary

	return p
}

func (s *Event_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_primaryContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Event_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEvent_primary(s)
	}
}

func (s *Event_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEvent_primary(s)
	}
}

func (p *VerilogParser) Event_primary() (localctx IEvent_primaryContext) {
	localctx = NewEvent_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, VerilogParserRULE_event_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2714)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__15, VerilogParserT__18, VerilogParserT__135, VerilogParserT__136, VerilogParserT__140, VerilogParserT__141, VerilogParserT__142, VerilogParserT__143, VerilogParserT__144, VerilogParserT__145, VerilogParserT__146, VerilogParserT__147, VerilogParserT__148, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserStrings, VerilogParserEscaped_identifier, VerilogParserSimple_identifier, VerilogParserDollar_Identifier:
		{
			p.SetState(2709)
			p.Expression()
		}

	case VerilogParserT__119:
		{
			p.SetState(2710)
			p.Match(VerilogParserT__119)
		}
		{
			p.SetState(2711)
			p.Expression()
		}

	case VerilogParserT__120:
		{
			p.SetState(2712)
			p.Match(VerilogParserT__120)
		}
		{
			p.SetState(2713)
			p.Expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedural_timing_control_statementContext is an interface to support dynamic dispatch.
type IProcedural_timing_control_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_timing_control_statementContext differentiates from other interfaces.
	IsProcedural_timing_control_statementContext()
}

type Procedural_timing_control_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_timing_control_statementContext() *Procedural_timing_control_statementContext {
	var p = new(Procedural_timing_control_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_procedural_timing_control_statement
	return p
}

func (*Procedural_timing_control_statementContext) IsProcedural_timing_control_statementContext() {}

func NewProcedural_timing_control_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_timing_control_statementContext {
	var p = new(Procedural_timing_control_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_procedural_timing_control_statement

	return p
}

func (s *Procedural_timing_control_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_timing_control_statementContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Procedural_timing_control_statementContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Procedural_timing_control_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_timing_control_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_timing_control_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterProcedural_timing_control_statement(s)
	}
}

func (s *Procedural_timing_control_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitProcedural_timing_control_statement(s)
	}
}

func (p *VerilogParser) Procedural_timing_control_statement() (localctx IProcedural_timing_control_statementContext) {
	localctx = NewProcedural_timing_control_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, VerilogParserRULE_procedural_timing_control_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2716)
		p.Delay_or_event_control()
	}
	{
		p.SetState(2717)
		p.Statement_or_null()
	}

	return localctx
}

// IWait_statementContext is an interface to support dynamic dispatch.
type IWait_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWait_statementContext differentiates from other interfaces.
	IsWait_statementContext()
}

type Wait_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWait_statementContext() *Wait_statementContext {
	var p = new(Wait_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_wait_statement
	return p
}

func (*Wait_statementContext) IsWait_statementContext() {}

func NewWait_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Wait_statementContext {
	var p = new(Wait_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_wait_statement

	return p
}

func (s *Wait_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Wait_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Wait_statementContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Wait_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wait_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Wait_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterWait_statement(s)
	}
}

func (s *Wait_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitWait_statement(s)
	}
}

func (p *VerilogParser) Wait_statement() (localctx IWait_statementContext) {
	localctx = NewWait_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, VerilogParserRULE_wait_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2719)
		p.Match(VerilogParserT__121)
	}
	{
		p.SetState(2720)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2721)
		p.Expression()
	}
	{
		p.SetState(2722)
		p.Match(VerilogParserT__17)
	}
	{
		p.SetState(2723)
		p.Statement_or_null()
	}

	return localctx
}

// IConditional_statementContext is an interface to support dynamic dispatch.
type IConditional_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_statementContext differentiates from other interfaces.
	IsConditional_statementContext()
}

type Conditional_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_statementContext() *Conditional_statementContext {
	var p = new(Conditional_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_conditional_statement
	return p
}

func (*Conditional_statementContext) IsConditional_statementContext() {}

func NewConditional_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_statementContext {
	var p = new(Conditional_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_conditional_statement

	return p
}

func (s *Conditional_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Conditional_statementContext) AllStatement_or_null() []IStatement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem())
	var tst = make([]IStatement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_or_nullContext)
		}
	}

	return tst
}

func (s *Conditional_statementContext) Statement_or_null(i int) IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Conditional_statementContext) Else_statement() IElse_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_statementContext)
}

func (s *Conditional_statementContext) If_else_if_statement() IIf_else_if_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_else_if_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_else_if_statementContext)
}

func (s *Conditional_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterConditional_statement(s)
	}
}

func (s *Conditional_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitConditional_statement(s)
	}
}

func (p *VerilogParser) Conditional_statement() (localctx IConditional_statementContext) {
	localctx = NewConditional_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, VerilogParserRULE_conditional_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2736)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 301, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2725)
			p.Match(VerilogParserT__98)
		}
		{
			p.SetState(2726)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2727)
			p.Expression()
		}
		{
			p.SetState(2728)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2729)
			p.Statement_or_null()
		}
		p.SetState(2733)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 300, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2730)
				p.Else_statement()
			}
			{
				p.SetState(2731)
				p.Statement_or_null()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2735)
			p.If_else_if_statement()
		}

	}

	return localctx
}

// IIf_else_if_statementContext is an interface to support dynamic dispatch.
type IIf_else_if_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_else_if_statementContext differentiates from other interfaces.
	IsIf_else_if_statementContext()
}

type If_else_if_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_else_if_statementContext() *If_else_if_statementContext {
	var p = new(If_else_if_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_if_else_if_statement
	return p
}

func (*If_else_if_statementContext) IsIf_else_if_statementContext() {}

func NewIf_else_if_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_else_if_statementContext {
	var p = new(If_else_if_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_if_else_if_statement

	return p
}

func (s *If_else_if_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_else_if_statementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *If_else_if_statementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *If_else_if_statementContext) AllStatement_or_null() []IStatement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem())
	var tst = make([]IStatement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_or_nullContext)
		}
	}

	return tst
}

func (s *If_else_if_statementContext) Statement_or_null(i int) IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *If_else_if_statementContext) AllElse_statement() []IElse_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElse_statementContext)(nil)).Elem())
	var tst = make([]IElse_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElse_statementContext)
		}
	}

	return tst
}

func (s *If_else_if_statementContext) Else_statement(i int) IElse_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElse_statementContext)
}

func (s *If_else_if_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_else_if_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_else_if_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterIf_else_if_statement(s)
	}
}

func (s *If_else_if_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitIf_else_if_statement(s)
	}
}

func (p *VerilogParser) If_else_if_statement() (localctx IIf_else_if_statementContext) {
	localctx = NewIf_else_if_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, VerilogParserRULE_if_else_if_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2738)
		p.Match(VerilogParserT__98)
	}
	{
		p.SetState(2739)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2740)
		p.Expression()
	}
	{
		p.SetState(2741)
		p.Match(VerilogParserT__17)
	}
	{
		p.SetState(2742)
		p.Statement_or_null()
	}
	p.SetState(2752)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 302, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2743)
				p.Else_statement()
			}
			{
				p.SetState(2744)
				p.Match(VerilogParserT__98)
			}
			{
				p.SetState(2745)
				p.Match(VerilogParserT__15)
			}
			{
				p.SetState(2746)
				p.Expression()
			}
			{
				p.SetState(2747)
				p.Match(VerilogParserT__17)
			}
			{
				p.SetState(2748)
				p.Statement_or_null()
			}

		}
		p.SetState(2754)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 302, p.GetParserRuleContext())
	}
	p.SetState(2758)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 303, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2755)
			p.Else_statement()
		}
		{
			p.SetState(2756)
			p.Statement_or_null()
		}

	}

	return localctx
}

// IElse_statementContext is an interface to support dynamic dispatch.
type IElse_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElse_statementContext differentiates from other interfaces.
	IsElse_statementContext()
}

type Else_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_statementContext() *Else_statementContext {
	var p = new(Else_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_else_statement
	return p
}

func (*Else_statementContext) IsElse_statementContext() {}

func NewElse_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_statementContext {
	var p = new(Else_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_else_statement

	return p
}

func (s *Else_statementContext) GetParser() antlr.Parser { return s.parser }
func (s *Else_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterElse_statement(s)
	}
}

func (s *Else_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitElse_statement(s)
	}
}

func (p *VerilogParser) Else_statement() (localctx IElse_statementContext) {
	localctx = NewElse_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, VerilogParserRULE_else_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2760)
		p.Match(VerilogParserT__99)
	}

	return localctx
}

// IFunction_conditional_statementContext is an interface to support dynamic dispatch.
type IFunction_conditional_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_conditional_statementContext differentiates from other interfaces.
	IsFunction_conditional_statementContext()
}

type Function_conditional_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_conditional_statementContext() *Function_conditional_statementContext {
	var p = new(Function_conditional_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_conditional_statement
	return p
}

func (*Function_conditional_statementContext) IsFunction_conditional_statementContext() {}

func NewFunction_conditional_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_conditional_statementContext {
	var p = new(Function_conditional_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_conditional_statement

	return p
}

func (s *Function_conditional_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_conditional_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_conditional_statementContext) AllFunction_statement_or_null() []IFunction_statement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem())
	var tst = make([]IFunction_statement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_statement_or_nullContext)
		}
	}

	return tst
}

func (s *Function_conditional_statementContext) Function_statement_or_null(i int) IFunction_statement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_statement_or_nullContext)
}

func (s *Function_conditional_statementContext) Else_statement() IElse_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_statementContext)
}

func (s *Function_conditional_statementContext) Function_if_else_if_statement() IFunction_if_else_if_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_if_else_if_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_if_else_if_statementContext)
}

func (s *Function_conditional_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_conditional_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_conditional_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_conditional_statement(s)
	}
}

func (s *Function_conditional_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_conditional_statement(s)
	}
}

func (p *VerilogParser) Function_conditional_statement() (localctx IFunction_conditional_statementContext) {
	localctx = NewFunction_conditional_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, VerilogParserRULE_function_conditional_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2773)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 305, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2762)
			p.Match(VerilogParserT__98)
		}
		{
			p.SetState(2763)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2764)
			p.Expression()
		}
		{
			p.SetState(2765)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2766)
			p.Function_statement_or_null()
		}
		p.SetState(2770)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 304, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2767)
				p.Else_statement()
			}
			{
				p.SetState(2768)
				p.Function_statement_or_null()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2772)
			p.Function_if_else_if_statement()
		}

	}

	return localctx
}

// IFunction_if_else_if_statementContext is an interface to support dynamic dispatch.
type IFunction_if_else_if_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_if_else_if_statementContext differentiates from other interfaces.
	IsFunction_if_else_if_statementContext()
}

type Function_if_else_if_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_if_else_if_statementContext() *Function_if_else_if_statementContext {
	var p = new(Function_if_else_if_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_if_else_if_statement
	return p
}

func (*Function_if_else_if_statementContext) IsFunction_if_else_if_statementContext() {}

func NewFunction_if_else_if_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_if_else_if_statementContext {
	var p = new(Function_if_else_if_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_if_else_if_statement

	return p
}

func (s *Function_if_else_if_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_if_else_if_statementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Function_if_else_if_statementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_if_else_if_statementContext) AllFunction_statement_or_null() []IFunction_statement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem())
	var tst = make([]IFunction_statement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_statement_or_nullContext)
		}
	}

	return tst
}

func (s *Function_if_else_if_statementContext) Function_statement_or_null(i int) IFunction_statement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_statement_or_nullContext)
}

func (s *Function_if_else_if_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_if_else_if_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_if_else_if_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_if_else_if_statement(s)
	}
}

func (s *Function_if_else_if_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_if_else_if_statement(s)
	}
}

func (p *VerilogParser) Function_if_else_if_statement() (localctx IFunction_if_else_if_statementContext) {
	localctx = NewFunction_if_else_if_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, VerilogParserRULE_function_if_else_if_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2775)
		p.Match(VerilogParserT__98)
	}
	{
		p.SetState(2776)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(2777)
		p.Expression()
	}
	{
		p.SetState(2778)
		p.Match(VerilogParserT__17)
	}
	{
		p.SetState(2779)
		p.Function_statement_or_null()
	}
	p.SetState(2789)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 306, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2780)
				p.Match(VerilogParserT__99)
			}
			{
				p.SetState(2781)
				p.Match(VerilogParserT__98)
			}
			{
				p.SetState(2782)
				p.Match(VerilogParserT__15)
			}
			{
				p.SetState(2783)
				p.Expression()
			}
			{
				p.SetState(2784)
				p.Match(VerilogParserT__17)
			}
			{
				p.SetState(2785)
				p.Function_statement_or_null()
			}

		}
		p.SetState(2791)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 306, p.GetParserRuleContext())
	}
	p.SetState(2794)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 307, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2792)
			p.Match(VerilogParserT__99)
		}
		{
			p.SetState(2793)
			p.Function_statement_or_null()
		}

	}

	return localctx
}

// ICase_statementContext is an interface to support dynamic dispatch.
type ICase_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_statementContext differentiates from other interfaces.
	IsCase_statementContext()
}

type Case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_statementContext() *Case_statementContext {
	var p = new(Case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_case_statement
	return p
}

func (*Case_statementContext) IsCase_statementContext() {}

func NewCase_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_statementContext {
	var p = new(Case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_case_statement

	return p
}

func (s *Case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_statementContext) AllCase_item() []ICase_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_itemContext)(nil)).Elem())
	var tst = make([]ICase_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_itemContext)
		}
	}

	return tst
}

func (s *Case_statementContext) Case_item(i int) ICase_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_itemContext)
}

func (s *Case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterCase_statement(s)
	}
}

func (s *Case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitCase_statement(s)
	}
}

func (p *VerilogParser) Case_statement() (localctx ICase_statementContext) {
	localctx = NewCase_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, VerilogParserRULE_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2835)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__100:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2796)
			p.Match(VerilogParserT__100)
		}
		{
			p.SetState(2797)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2798)
			p.Expression()
		}
		{
			p.SetState(2799)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2800)
			p.Case_item()
		}
		p.SetState(2804)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__5)|(1<<VerilogParserT__15)|(1<<VerilogParserT__18))) != 0) || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
			{
				p.SetState(2801)
				p.Case_item()
			}

			p.SetState(2806)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2807)
			p.Match(VerilogParserT__101)
		}

	case VerilogParserT__122:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2809)
			p.Match(VerilogParserT__122)
		}
		{
			p.SetState(2810)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2811)
			p.Expression()
		}
		{
			p.SetState(2812)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2813)
			p.Case_item()
		}
		p.SetState(2817)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__5)|(1<<VerilogParserT__15)|(1<<VerilogParserT__18))) != 0) || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
			{
				p.SetState(2814)
				p.Case_item()
			}

			p.SetState(2819)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2820)
			p.Match(VerilogParserT__101)
		}

	case VerilogParserT__123:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2822)
			p.Match(VerilogParserT__123)
		}
		{
			p.SetState(2823)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2824)
			p.Expression()
		}
		{
			p.SetState(2825)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2826)
			p.Case_item()
		}
		p.SetState(2830)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__5)|(1<<VerilogParserT__15)|(1<<VerilogParserT__18))) != 0) || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
			{
				p.SetState(2827)
				p.Case_item()
			}

			p.SetState(2832)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2833)
			p.Match(VerilogParserT__101)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICase_itemContext is an interface to support dynamic dispatch.
type ICase_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_itemContext differentiates from other interfaces.
	IsCase_itemContext()
}

type Case_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_itemContext() *Case_itemContext {
	var p = new(Case_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_case_item
	return p
}

func (*Case_itemContext) IsCase_itemContext() {}

func NewCase_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_itemContext {
	var p = new(Case_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_case_item

	return p
}

func (s *Case_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_itemContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Case_itemContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_itemContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Case_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterCase_item(s)
	}
}

func (s *Case_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitCase_item(s)
	}
}

func (p *VerilogParser) Case_item() (localctx ICase_itemContext) {
	localctx = NewCase_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, VerilogParserRULE_case_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2853)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__15, VerilogParserT__18, VerilogParserT__135, VerilogParserT__136, VerilogParserT__140, VerilogParserT__141, VerilogParserT__142, VerilogParserT__143, VerilogParserT__144, VerilogParserT__145, VerilogParserT__146, VerilogParserT__147, VerilogParserT__148, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserStrings, VerilogParserEscaped_identifier, VerilogParserSimple_identifier, VerilogParserDollar_Identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2837)
			p.Expression()
		}
		p.SetState(2842)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(2838)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(2839)
				p.Expression()
			}

			p.SetState(2844)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2845)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(2846)
			p.Statement_or_null()
		}

	case VerilogParserT__5:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2848)
			p.Match(VerilogParserT__5)
		}
		p.SetState(2850)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__64 {
			{
				p.SetState(2849)
				p.Match(VerilogParserT__64)
			}

		}
		{
			p.SetState(2852)
			p.Statement_or_null()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_case_statementContext is an interface to support dynamic dispatch.
type IFunction_case_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_case_statementContext differentiates from other interfaces.
	IsFunction_case_statementContext()
}

type Function_case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_case_statementContext() *Function_case_statementContext {
	var p = new(Function_case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_case_statement
	return p
}

func (*Function_case_statementContext) IsFunction_case_statementContext() {}

func NewFunction_case_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_case_statementContext {
	var p = new(Function_case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_case_statement

	return p
}

func (s *Function_case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_case_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_case_statementContext) AllFunction_case_item() []IFunction_case_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_case_itemContext)(nil)).Elem())
	var tst = make([]IFunction_case_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_case_itemContext)
		}
	}

	return tst
}

func (s *Function_case_statementContext) Function_case_item(i int) IFunction_case_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_case_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_case_itemContext)
}

func (s *Function_case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_case_statement(s)
	}
}

func (s *Function_case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_case_statement(s)
	}
}

func (p *VerilogParser) Function_case_statement() (localctx IFunction_case_statementContext) {
	localctx = NewFunction_case_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, VerilogParserRULE_function_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2894)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__100:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2855)
			p.Match(VerilogParserT__100)
		}
		{
			p.SetState(2856)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2857)
			p.Expression()
		}
		{
			p.SetState(2858)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2859)
			p.Function_case_item()
		}
		p.SetState(2863)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__5)|(1<<VerilogParserT__15)|(1<<VerilogParserT__18))) != 0) || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
			{
				p.SetState(2860)
				p.Function_case_item()
			}

			p.SetState(2865)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2866)
			p.Match(VerilogParserT__101)
		}

	case VerilogParserT__122:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2868)
			p.Match(VerilogParserT__122)
		}
		{
			p.SetState(2869)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2870)
			p.Expression()
		}
		{
			p.SetState(2871)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2872)
			p.Function_case_item()
		}
		p.SetState(2876)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__5)|(1<<VerilogParserT__15)|(1<<VerilogParserT__18))) != 0) || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
			{
				p.SetState(2873)
				p.Function_case_item()
			}

			p.SetState(2878)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2879)
			p.Match(VerilogParserT__101)
		}

	case VerilogParserT__123:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2881)
			p.Match(VerilogParserT__123)
		}
		{
			p.SetState(2882)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2883)
			p.Expression()
		}
		{
			p.SetState(2884)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2885)
			p.Function_case_item()
		}
		p.SetState(2889)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserT__5)|(1<<VerilogParserT__15)|(1<<VerilogParserT__18))) != 0) || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
			{
				p.SetState(2886)
				p.Function_case_item()
			}

			p.SetState(2891)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2892)
			p.Match(VerilogParserT__101)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_case_itemContext is an interface to support dynamic dispatch.
type IFunction_case_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_case_itemContext differentiates from other interfaces.
	IsFunction_case_itemContext()
}

type Function_case_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_case_itemContext() *Function_case_itemContext {
	var p = new(Function_case_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_case_item
	return p
}

func (*Function_case_itemContext) IsFunction_case_itemContext() {}

func NewFunction_case_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_case_itemContext {
	var p = new(Function_case_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_case_item

	return p
}

func (s *Function_case_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_case_itemContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Function_case_itemContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_case_itemContext) Function_statement_or_null() IFunction_statement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_statement_or_nullContext)
}

func (s *Function_case_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_case_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_case_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_case_item(s)
	}
}

func (s *Function_case_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_case_item(s)
	}
}

func (p *VerilogParser) Function_case_item() (localctx IFunction_case_itemContext) {
	localctx = NewFunction_case_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, VerilogParserRULE_function_case_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2912)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__15, VerilogParserT__18, VerilogParserT__135, VerilogParserT__136, VerilogParserT__140, VerilogParserT__141, VerilogParserT__142, VerilogParserT__143, VerilogParserT__144, VerilogParserT__145, VerilogParserT__146, VerilogParserT__147, VerilogParserT__148, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserStrings, VerilogParserEscaped_identifier, VerilogParserSimple_identifier, VerilogParserDollar_Identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2896)
			p.Expression()
		}
		p.SetState(2901)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(2897)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(2898)
				p.Expression()
			}

			p.SetState(2903)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2904)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(2905)
			p.Function_statement_or_null()
		}

	case VerilogParserT__5:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2907)
			p.Match(VerilogParserT__5)
		}
		p.SetState(2909)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__64 {
			{
				p.SetState(2908)
				p.Match(VerilogParserT__64)
			}

		}
		{
			p.SetState(2911)
			p.Function_statement_or_null()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_loop_statementContext is an interface to support dynamic dispatch.
type IFunction_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_loop_statementContext differentiates from other interfaces.
	IsFunction_loop_statementContext()
}

type Function_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_loop_statementContext() *Function_loop_statementContext {
	var p = new(Function_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_loop_statement
	return p
}

func (*Function_loop_statementContext) IsFunction_loop_statementContext() {}

func NewFunction_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_loop_statementContext {
	var p = new(Function_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_loop_statement

	return p
}

func (s *Function_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_loop_statementContext) Function_statement() IFunction_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_statementContext)
}

func (s *Function_loop_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_loop_statementContext) AllVariable_assignment() []IVariable_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem())
	var tst = make([]IVariable_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_assignmentContext)
		}
	}

	return tst
}

func (s *Function_loop_statementContext) Variable_assignment(i int) IVariable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignmentContext)
}

func (s *Function_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_loop_statement(s)
	}
}

func (s *Function_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_loop_statement(s)
	}
}

func (p *VerilogParser) Function_loop_statement() (localctx IFunction_loop_statementContext) {
	localctx = NewFunction_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, VerilogParserRULE_function_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2938)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__124:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2914)
			p.Match(VerilogParserT__124)
		}
		{
			p.SetState(2915)
			p.Function_statement()
		}

	case VerilogParserT__114:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2916)
			p.Match(VerilogParserT__114)
		}
		{
			p.SetState(2917)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2918)
			p.Expression()
		}
		{
			p.SetState(2919)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2920)
			p.Function_statement()
		}

	case VerilogParserT__125:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2922)
			p.Match(VerilogParserT__125)
		}
		{
			p.SetState(2923)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2924)
			p.Expression()
		}
		{
			p.SetState(2925)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2926)
			p.Function_statement()
		}

	case VerilogParserT__102:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2928)
			p.Match(VerilogParserT__102)
		}
		{
			p.SetState(2929)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2930)
			p.Variable_assignment()
		}
		{
			p.SetState(2931)
			p.Match(VerilogParserT__1)
		}
		{
			p.SetState(2932)
			p.Expression()
		}
		{
			p.SetState(2933)
			p.Match(VerilogParserT__1)
		}
		{
			p.SetState(2934)
			p.Variable_assignment()
		}
		{
			p.SetState(2935)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2936)
			p.Function_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILoop_statementContext is an interface to support dynamic dispatch.
type ILoop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_statementContext differentiates from other interfaces.
	IsLoop_statementContext()
}

type Loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_statementContext() *Loop_statementContext {
	var p = new(Loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_loop_statement
	return p
}

func (*Loop_statementContext) IsLoop_statementContext() {}

func NewLoop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_statementContext {
	var p = new(Loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_loop_statement

	return p
}

func (s *Loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Loop_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Loop_statementContext) AllVariable_assignment() []IVariable_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem())
	var tst = make([]IVariable_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_assignmentContext)
		}
	}

	return tst
}

func (s *Loop_statementContext) Variable_assignment(i int) IVariable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignmentContext)
}

func (s *Loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterLoop_statement(s)
	}
}

func (s *Loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitLoop_statement(s)
	}
}

func (p *VerilogParser) Loop_statement() (localctx ILoop_statementContext) {
	localctx = NewLoop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, VerilogParserRULE_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2964)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__124:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2940)
			p.Match(VerilogParserT__124)
		}
		{
			p.SetState(2941)
			p.Statement()
		}

	case VerilogParserT__114:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2942)
			p.Match(VerilogParserT__114)
		}
		{
			p.SetState(2943)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2944)
			p.Expression()
		}
		{
			p.SetState(2945)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2946)
			p.Statement()
		}

	case VerilogParserT__125:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2948)
			p.Match(VerilogParserT__125)
		}
		{
			p.SetState(2949)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2950)
			p.Expression()
		}
		{
			p.SetState(2951)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2952)
			p.Statement()
		}

	case VerilogParserT__102:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2954)
			p.Match(VerilogParserT__102)
		}
		{
			p.SetState(2955)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(2956)
			p.Variable_assignment()
		}
		{
			p.SetState(2957)
			p.Match(VerilogParserT__1)
		}
		{
			p.SetState(2958)
			p.Expression()
		}
		{
			p.SetState(2959)
			p.Match(VerilogParserT__1)
		}
		{
			p.SetState(2960)
			p.Variable_assignment()
		}
		{
			p.SetState(2961)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(2962)
			p.Statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISystem_task_enableContext is an interface to support dynamic dispatch.
type ISystem_task_enableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_task_enableContext differentiates from other interfaces.
	IsSystem_task_enableContext()
}

type System_task_enableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_task_enableContext() *System_task_enableContext {
	var p = new(System_task_enableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_system_task_enable
	return p
}

func (*System_task_enableContext) IsSystem_task_enableContext() {}

func NewSystem_task_enableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_task_enableContext {
	var p = new(System_task_enableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_system_task_enable

	return p
}

func (s *System_task_enableContext) GetParser() antlr.Parser { return s.parser }

func (s *System_task_enableContext) System_task_identifier() ISystem_task_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_task_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_task_identifierContext)
}

func (s *System_task_enableContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *System_task_enableContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *System_task_enableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_task_enableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_task_enableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSystem_task_enable(s)
	}
}

func (s *System_task_enableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSystem_task_enable(s)
	}
}

func (p *VerilogParser) System_task_enable() (localctx ISystem_task_enableContext) {
	localctx = NewSystem_task_enableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, VerilogParserRULE_system_task_enable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2966)
		p.System_task_identifier()
	}
	p.SetState(2979)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__15 {
		{
			p.SetState(2967)
			p.Match(VerilogParserT__15)
		}
		p.SetState(2976)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__15 || _la == VerilogParserT__18 || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
			{
				p.SetState(2968)
				p.Expression()
			}
			p.SetState(2973)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == VerilogParserT__16 {
				{
					p.SetState(2969)
					p.Match(VerilogParserT__16)
				}
				{
					p.SetState(2970)
					p.Expression()
				}

				p.SetState(2975)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(2978)
			p.Match(VerilogParserT__17)
		}

	}
	{
		p.SetState(2981)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// ITask_enableContext is an interface to support dynamic dispatch.
type ITask_enableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_enableContext differentiates from other interfaces.
	IsTask_enableContext()
}

type Task_enableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_enableContext() *Task_enableContext {
	var p = new(Task_enableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_enable
	return p
}

func (*Task_enableContext) IsTask_enableContext() {}

func NewTask_enableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_enableContext {
	var p = new(Task_enableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_enable

	return p
}

func (s *Task_enableContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_enableContext) Hierarchical_task_identifier() IHierarchical_task_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_task_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_task_identifierContext)
}

func (s *Task_enableContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Task_enableContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Task_enableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_enableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_enableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTask_enable(s)
	}
}

func (s *Task_enableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTask_enable(s)
	}
}

func (p *VerilogParser) Task_enable() (localctx ITask_enableContext) {
	localctx = NewTask_enableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, VerilogParserRULE_task_enable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2983)
		p.Hierarchical_task_identifier()
	}
	p.SetState(2996)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__15 {
		{
			p.SetState(2984)
			p.Match(VerilogParserT__15)
		}
		p.SetState(2993)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserT__15 || _la == VerilogParserT__18 || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
			{
				p.SetState(2985)
				p.Expression()
			}
			p.SetState(2990)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == VerilogParserT__16 {
				{
					p.SetState(2986)
					p.Match(VerilogParserT__16)
				}
				{
					p.SetState(2987)
					p.Expression()
				}

				p.SetState(2992)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(2995)
			p.Match(VerilogParserT__17)
		}

	}
	{
		p.SetState(2998)
		p.Match(VerilogParserT__1)
	}

	return localctx
}

// ISpecify_blockContext is an interface to support dynamic dispatch.
type ISpecify_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_blockContext differentiates from other interfaces.
	IsSpecify_blockContext()
}

type Specify_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_blockContext() *Specify_blockContext {
	var p = new(Specify_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specify_block
	return p
}

func (*Specify_blockContext) IsSpecify_blockContext() {}

func NewSpecify_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_blockContext {
	var p = new(Specify_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specify_block

	return p
}

func (s *Specify_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_blockContext) AllSpecify_item() []ISpecify_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecify_itemContext)(nil)).Elem())
	var tst = make([]ISpecify_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecify_itemContext)
		}
	}

	return tst
}

func (s *Specify_blockContext) Specify_item(i int) ISpecify_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecify_itemContext)
}

func (s *Specify_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSpecify_block(s)
	}
}

func (s *Specify_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSpecify_block(s)
	}
}

func (p *VerilogParser) Specify_block() (localctx ISpecify_blockContext) {
	localctx = NewSpecify_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, VerilogParserRULE_specify_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3000)
		p.Match(VerilogParserT__126)
	}
	p.SetState(3004)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__15 || _la == VerilogParserT__30 || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(VerilogParserT__98-99))|(1<<(VerilogParserT__128-99))|(1<<(VerilogParserT__129-99)))) != 0) || (((_la-131)&-(0x1f+1)) == 0 && ((1<<uint((_la-131)))&((1<<(VerilogParserT__130-131))|(1<<(VerilogParserT__131-131))|(1<<(VerilogParserT__134-131)))) != 0) || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(3001)
			p.Specify_item()
		}

		p.SetState(3006)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3007)
		p.Match(VerilogParserT__127)
	}

	return localctx
}

// ISpecify_itemContext is an interface to support dynamic dispatch.
type ISpecify_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_itemContext differentiates from other interfaces.
	IsSpecify_itemContext()
}

type Specify_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_itemContext() *Specify_itemContext {
	var p = new(Specify_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specify_item
	return p
}

func (*Specify_itemContext) IsSpecify_itemContext() {}

func NewSpecify_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_itemContext {
	var p = new(Specify_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specify_item

	return p
}

func (s *Specify_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_itemContext) Specparam_declaration() ISpecparam_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_declarationContext)
}

func (s *Specify_itemContext) Pulsestyle_declaration() IPulsestyle_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulsestyle_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulsestyle_declarationContext)
}

func (s *Specify_itemContext) Showcancelled_declaration() IShowcancelled_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShowcancelled_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShowcancelled_declarationContext)
}

func (s *Specify_itemContext) Path_declaration() IPath_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_declarationContext)
}

func (s *Specify_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSpecify_item(s)
	}
}

func (s *Specify_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSpecify_item(s)
	}
}

func (p *VerilogParser) Specify_item() (localctx ISpecify_itemContext) {
	localctx = NewSpecify_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, VerilogParserRULE_specify_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3013)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__30:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3009)
			p.Specparam_declaration()
		}

	case VerilogParserT__128, VerilogParserT__129:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3010)
			p.Pulsestyle_declaration()
		}

	case VerilogParserT__130, VerilogParserT__131:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3011)
			p.Showcancelled_declaration()
		}

	case VerilogParserT__15, VerilogParserT__98, VerilogParserT__134, VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3012)
			p.Path_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPulsestyle_declarationContext is an interface to support dynamic dispatch.
type IPulsestyle_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulsestyle_declarationContext differentiates from other interfaces.
	IsPulsestyle_declarationContext()
}

type Pulsestyle_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulsestyle_declarationContext() *Pulsestyle_declarationContext {
	var p = new(Pulsestyle_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pulsestyle_declaration
	return p
}

func (*Pulsestyle_declarationContext) IsPulsestyle_declarationContext() {}

func NewPulsestyle_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulsestyle_declarationContext {
	var p = new(Pulsestyle_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pulsestyle_declaration

	return p
}

func (s *Pulsestyle_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulsestyle_declarationContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Pulsestyle_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulsestyle_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulsestyle_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPulsestyle_declaration(s)
	}
}

func (s *Pulsestyle_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPulsestyle_declaration(s)
	}
}

func (p *VerilogParser) Pulsestyle_declaration() (localctx IPulsestyle_declarationContext) {
	localctx = NewPulsestyle_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, VerilogParserRULE_pulsestyle_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3023)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__128:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3015)
			p.Match(VerilogParserT__128)
		}
		{
			p.SetState(3016)
			p.List_of_path_outputs()
		}
		{
			p.SetState(3017)
			p.Match(VerilogParserT__1)
		}

	case VerilogParserT__129:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3019)
			p.Match(VerilogParserT__129)
		}
		{
			p.SetState(3020)
			p.List_of_path_outputs()
		}
		{
			p.SetState(3021)
			p.Match(VerilogParserT__1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IShowcancelled_declarationContext is an interface to support dynamic dispatch.
type IShowcancelled_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShowcancelled_declarationContext differentiates from other interfaces.
	IsShowcancelled_declarationContext()
}

type Showcancelled_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowcancelled_declarationContext() *Showcancelled_declarationContext {
	var p = new(Showcancelled_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_showcancelled_declaration
	return p
}

func (*Showcancelled_declarationContext) IsShowcancelled_declarationContext() {}

func NewShowcancelled_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Showcancelled_declarationContext {
	var p = new(Showcancelled_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_showcancelled_declaration

	return p
}

func (s *Showcancelled_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Showcancelled_declarationContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Showcancelled_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Showcancelled_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Showcancelled_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterShowcancelled_declaration(s)
	}
}

func (s *Showcancelled_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitShowcancelled_declaration(s)
	}
}

func (p *VerilogParser) Showcancelled_declaration() (localctx IShowcancelled_declarationContext) {
	localctx = NewShowcancelled_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, VerilogParserRULE_showcancelled_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3033)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__130:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3025)
			p.Match(VerilogParserT__130)
		}
		{
			p.SetState(3026)
			p.List_of_path_outputs()
		}
		{
			p.SetState(3027)
			p.Match(VerilogParserT__1)
		}

	case VerilogParserT__131:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3029)
			p.Match(VerilogParserT__131)
		}
		{
			p.SetState(3030)
			p.List_of_path_outputs()
		}
		{
			p.SetState(3031)
			p.Match(VerilogParserT__1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPath_declarationContext is an interface to support dynamic dispatch.
type IPath_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPath_declarationContext differentiates from other interfaces.
	IsPath_declarationContext()
}

type Path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_declarationContext() *Path_declarationContext {
	var p = new(Path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_path_declaration
	return p
}

func (*Path_declarationContext) IsPath_declarationContext() {}

func NewPath_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_declarationContext {
	var p = new(Path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_path_declaration

	return p
}

func (s *Path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_declarationContext) Simple_path_declaration() ISimple_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_path_declarationContext)
}

func (s *Path_declarationContext) Edge_sensitive_path_declaration() IEdge_sensitive_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_sensitive_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_sensitive_path_declarationContext)
}

func (s *Path_declarationContext) State_dependent_path_declaration() IState_dependent_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_dependent_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_dependent_path_declarationContext)
}

func (s *Path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPath_declaration(s)
	}
}

func (s *Path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPath_declaration(s)
	}
}

func (p *VerilogParser) Path_declaration() (localctx IPath_declarationContext) {
	localctx = NewPath_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, VerilogParserRULE_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3044)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 334, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3035)
			p.Simple_path_declaration()
		}
		{
			p.SetState(3036)
			p.Match(VerilogParserT__1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3038)
			p.Edge_sensitive_path_declaration()
		}
		{
			p.SetState(3039)
			p.Match(VerilogParserT__1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3041)
			p.State_dependent_path_declaration()
		}
		{
			p.SetState(3042)
			p.Match(VerilogParserT__1)
		}

	}

	return localctx
}

// ISimple_path_declarationContext is an interface to support dynamic dispatch.
type ISimple_path_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_path_declarationContext differentiates from other interfaces.
	IsSimple_path_declarationContext()
}

type Simple_path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_path_declarationContext() *Simple_path_declarationContext {
	var p = new(Simple_path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_simple_path_declaration
	return p
}

func (*Simple_path_declarationContext) IsSimple_path_declarationContext() {}

func NewSimple_path_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_path_declarationContext {
	var p = new(Simple_path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_simple_path_declaration

	return p
}

func (s *Simple_path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_path_declarationContext) Parallel_path_description() IParallel_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParallel_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParallel_path_descriptionContext)
}

func (s *Simple_path_declarationContext) Path_delay_value() IPath_delay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_valueContext)
}

func (s *Simple_path_declarationContext) Full_path_description() IFull_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_path_descriptionContext)
}

func (s *Simple_path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSimple_path_declaration(s)
	}
}

func (s *Simple_path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSimple_path_declaration(s)
	}
}

func (p *VerilogParser) Simple_path_declaration() (localctx ISimple_path_declarationContext) {
	localctx = NewSimple_path_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, VerilogParserRULE_simple_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3054)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3046)
			p.Parallel_path_description()
		}
		{
			p.SetState(3047)
			p.Match(VerilogParserT__50)
		}
		{
			p.SetState(3048)
			p.Path_delay_value()
		}

	case VerilogParserT__15:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3050)
			p.Full_path_description()
		}
		{
			p.SetState(3051)
			p.Match(VerilogParserT__50)
		}
		{
			p.SetState(3052)
			p.Path_delay_value()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParallel_path_descriptionContext is an interface to support dynamic dispatch.
type IParallel_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParallel_path_descriptionContext differentiates from other interfaces.
	IsParallel_path_descriptionContext()
}

type Parallel_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParallel_path_descriptionContext() *Parallel_path_descriptionContext {
	var p = new(Parallel_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parallel_path_description
	return p
}

func (*Parallel_path_descriptionContext) IsParallel_path_descriptionContext() {}

func NewParallel_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parallel_path_descriptionContext {
	var p = new(Parallel_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parallel_path_description

	return p
}

func (s *Parallel_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Parallel_path_descriptionContext) Specify_input_terminal_descriptor() ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *Parallel_path_descriptionContext) Specify_output_terminal_descriptor() ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *Parallel_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Parallel_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parallel_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parallel_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterParallel_path_description(s)
	}
}

func (s *Parallel_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitParallel_path_description(s)
	}
}

func (p *VerilogParser) Parallel_path_description() (localctx IParallel_path_descriptionContext) {
	localctx = NewParallel_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, VerilogParserRULE_parallel_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3056)
		p.Specify_input_terminal_descriptor()
	}
	p.SetState(3058)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__135 || _la == VerilogParserT__136 {
		{
			p.SetState(3057)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(3060)
		p.Match(VerilogParserT__132)
	}
	{
		p.SetState(3061)
		p.Specify_output_terminal_descriptor()
	}

	return localctx
}

// IFull_path_descriptionContext is an interface to support dynamic dispatch.
type IFull_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFull_path_descriptionContext differentiates from other interfaces.
	IsFull_path_descriptionContext()
}

type Full_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFull_path_descriptionContext() *Full_path_descriptionContext {
	var p = new(Full_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_full_path_description
	return p
}

func (*Full_path_descriptionContext) IsFull_path_descriptionContext() {}

func NewFull_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Full_path_descriptionContext {
	var p = new(Full_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_full_path_description

	return p
}

func (s *Full_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Full_path_descriptionContext) List_of_path_inputs() IList_of_path_inputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_inputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_inputsContext)
}

func (s *Full_path_descriptionContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Full_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Full_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Full_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Full_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFull_path_description(s)
	}
}

func (s *Full_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFull_path_description(s)
	}
}

func (p *VerilogParser) Full_path_description() (localctx IFull_path_descriptionContext) {
	localctx = NewFull_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, VerilogParserRULE_full_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3063)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(3064)
		p.List_of_path_inputs()
	}
	p.SetState(3066)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__135 || _la == VerilogParserT__136 {
		{
			p.SetState(3065)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(3068)
		p.Match(VerilogParserT__133)
	}
	{
		p.SetState(3069)
		p.List_of_path_outputs()
	}
	{
		p.SetState(3070)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IList_of_path_inputsContext is an interface to support dynamic dispatch.
type IList_of_path_inputsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_path_inputsContext differentiates from other interfaces.
	IsList_of_path_inputsContext()
}

type List_of_path_inputsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_path_inputsContext() *List_of_path_inputsContext {
	var p = new(List_of_path_inputsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_path_inputs
	return p
}

func (*List_of_path_inputsContext) IsList_of_path_inputsContext() {}

func NewList_of_path_inputsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_path_inputsContext {
	var p = new(List_of_path_inputsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_path_inputs

	return p
}

func (s *List_of_path_inputsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_path_inputsContext) AllSpecify_input_terminal_descriptor() []ISpecify_input_terminal_descriptorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem())
	var tst = make([]ISpecify_input_terminal_descriptorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecify_input_terminal_descriptorContext)
		}
	}

	return tst
}

func (s *List_of_path_inputsContext) Specify_input_terminal_descriptor(i int) ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *List_of_path_inputsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_path_inputsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_path_inputsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_path_inputs(s)
	}
}

func (s *List_of_path_inputsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_path_inputs(s)
	}
}

func (p *VerilogParser) List_of_path_inputs() (localctx IList_of_path_inputsContext) {
	localctx = NewList_of_path_inputsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, VerilogParserRULE_list_of_path_inputs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3072)
		p.Specify_input_terminal_descriptor()
	}
	p.SetState(3077)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(3073)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3074)
			p.Specify_input_terminal_descriptor()
		}

		p.SetState(3079)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_path_outputsContext is an interface to support dynamic dispatch.
type IList_of_path_outputsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_path_outputsContext differentiates from other interfaces.
	IsList_of_path_outputsContext()
}

type List_of_path_outputsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_path_outputsContext() *List_of_path_outputsContext {
	var p = new(List_of_path_outputsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_path_outputs
	return p
}

func (*List_of_path_outputsContext) IsList_of_path_outputsContext() {}

func NewList_of_path_outputsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_path_outputsContext {
	var p = new(List_of_path_outputsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_path_outputs

	return p
}

func (s *List_of_path_outputsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_path_outputsContext) AllSpecify_output_terminal_descriptor() []ISpecify_output_terminal_descriptorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem())
	var tst = make([]ISpecify_output_terminal_descriptorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecify_output_terminal_descriptorContext)
		}
	}

	return tst
}

func (s *List_of_path_outputsContext) Specify_output_terminal_descriptor(i int) ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *List_of_path_outputsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_path_outputsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_path_outputsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_path_outputs(s)
	}
}

func (s *List_of_path_outputsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_path_outputs(s)
	}
}

func (p *VerilogParser) List_of_path_outputs() (localctx IList_of_path_outputsContext) {
	localctx = NewList_of_path_outputsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, VerilogParserRULE_list_of_path_outputs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3080)
		p.Specify_output_terminal_descriptor()
	}
	p.SetState(3085)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(3081)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3082)
			p.Specify_output_terminal_descriptor()
		}

		p.SetState(3087)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISpecify_input_terminal_descriptorContext is an interface to support dynamic dispatch.
type ISpecify_input_terminal_descriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_input_terminal_descriptorContext differentiates from other interfaces.
	IsSpecify_input_terminal_descriptorContext()
}

type Specify_input_terminal_descriptorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_input_terminal_descriptorContext() *Specify_input_terminal_descriptorContext {
	var p = new(Specify_input_terminal_descriptorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specify_input_terminal_descriptor
	return p
}

func (*Specify_input_terminal_descriptorContext) IsSpecify_input_terminal_descriptorContext() {}

func NewSpecify_input_terminal_descriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_input_terminal_descriptorContext {
	var p = new(Specify_input_terminal_descriptorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specify_input_terminal_descriptor

	return p
}

func (s *Specify_input_terminal_descriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_input_terminal_descriptorContext) Input_identifier() IInput_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_identifierContext)
}

func (s *Specify_input_terminal_descriptorContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Specify_input_terminal_descriptorContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Specify_input_terminal_descriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_input_terminal_descriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_input_terminal_descriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSpecify_input_terminal_descriptor(s)
	}
}

func (s *Specify_input_terminal_descriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSpecify_input_terminal_descriptor(s)
	}
}

func (p *VerilogParser) Specify_input_terminal_descriptor() (localctx ISpecify_input_terminal_descriptorContext) {
	localctx = NewSpecify_input_terminal_descriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, VerilogParserRULE_specify_input_terminal_descriptor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3099)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 340, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3088)
			p.Input_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3089)
			p.Input_identifier()
		}
		{
			p.SetState(3090)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3091)
			p.Constant_expression()
		}
		{
			p.SetState(3092)
			p.Match(VerilogParserT__21)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3094)
			p.Input_identifier()
		}
		{
			p.SetState(3095)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3096)
			p.Range_expression()
		}
		{
			p.SetState(3097)
			p.Match(VerilogParserT__21)
		}

	}

	return localctx
}

// ISpecify_output_terminal_descriptorContext is an interface to support dynamic dispatch.
type ISpecify_output_terminal_descriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_output_terminal_descriptorContext differentiates from other interfaces.
	IsSpecify_output_terminal_descriptorContext()
}

type Specify_output_terminal_descriptorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_output_terminal_descriptorContext() *Specify_output_terminal_descriptorContext {
	var p = new(Specify_output_terminal_descriptorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specify_output_terminal_descriptor
	return p
}

func (*Specify_output_terminal_descriptorContext) IsSpecify_output_terminal_descriptorContext() {}

func NewSpecify_output_terminal_descriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_output_terminal_descriptorContext {
	var p = new(Specify_output_terminal_descriptorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specify_output_terminal_descriptor

	return p
}

func (s *Specify_output_terminal_descriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_output_terminal_descriptorContext) Output_identifier() IOutput_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_identifierContext)
}

func (s *Specify_output_terminal_descriptorContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Specify_output_terminal_descriptorContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Specify_output_terminal_descriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_output_terminal_descriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_output_terminal_descriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSpecify_output_terminal_descriptor(s)
	}
}

func (s *Specify_output_terminal_descriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSpecify_output_terminal_descriptor(s)
	}
}

func (p *VerilogParser) Specify_output_terminal_descriptor() (localctx ISpecify_output_terminal_descriptorContext) {
	localctx = NewSpecify_output_terminal_descriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, VerilogParserRULE_specify_output_terminal_descriptor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3112)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 341, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3101)
			p.Output_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3102)
			p.Output_identifier()
		}
		{
			p.SetState(3103)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3104)
			p.Constant_expression()
		}
		{
			p.SetState(3105)
			p.Match(VerilogParserT__21)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3107)
			p.Output_identifier()
		}
		{
			p.SetState(3108)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3109)
			p.Range_expression()
		}
		{
			p.SetState(3110)
			p.Match(VerilogParserT__21)
		}

	}

	return localctx
}

// IInput_identifierContext is an interface to support dynamic dispatch.
type IInput_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_identifierContext differentiates from other interfaces.
	IsInput_identifierContext()
}

type Input_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_identifierContext() *Input_identifierContext {
	var p = new(Input_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_input_identifier
	return p
}

func (*Input_identifierContext) IsInput_identifierContext() {}

func NewInput_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_identifierContext {
	var p = new(Input_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_input_identifier

	return p
}

func (s *Input_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_identifierContext) Input_port_identifier() IInput_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_port_identifierContext)
}

func (s *Input_identifierContext) Inout_port_identifier() IInout_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_port_identifierContext)
}

func (s *Input_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterInput_identifier(s)
	}
}

func (s *Input_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitInput_identifier(s)
	}
}

func (p *VerilogParser) Input_identifier() (localctx IInput_identifierContext) {
	localctx = NewInput_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, VerilogParserRULE_input_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3116)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 342, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3114)
			p.Input_port_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3115)
			p.Inout_port_identifier()
		}

	}

	return localctx
}

// IOutput_identifierContext is an interface to support dynamic dispatch.
type IOutput_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_identifierContext differentiates from other interfaces.
	IsOutput_identifierContext()
}

type Output_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_identifierContext() *Output_identifierContext {
	var p = new(Output_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_identifier
	return p
}

func (*Output_identifierContext) IsOutput_identifierContext() {}

func NewOutput_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_identifierContext {
	var p = new(Output_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_identifier

	return p
}

func (s *Output_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_identifierContext) Output_port_identifier() IOutput_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_port_identifierContext)
}

func (s *Output_identifierContext) Inout_port_identifier() IInout_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_port_identifierContext)
}

func (s *Output_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterOutput_identifier(s)
	}
}

func (s *Output_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitOutput_identifier(s)
	}
}

func (p *VerilogParser) Output_identifier() (localctx IOutput_identifierContext) {
	localctx = NewOutput_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, VerilogParserRULE_output_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3120)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 343, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3118)
			p.Output_port_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3119)
			p.Inout_port_identifier()
		}

	}

	return localctx
}

// IPath_delay_valueContext is an interface to support dynamic dispatch.
type IPath_delay_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPath_delay_valueContext differentiates from other interfaces.
	IsPath_delay_valueContext()
}

type Path_delay_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_delay_valueContext() *Path_delay_valueContext {
	var p = new(Path_delay_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_path_delay_value
	return p
}

func (*Path_delay_valueContext) IsPath_delay_valueContext() {}

func NewPath_delay_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_delay_valueContext {
	var p = new(Path_delay_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_path_delay_value

	return p
}

func (s *Path_delay_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_delay_valueContext) List_of_path_delay_expressions() IList_of_path_delay_expressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_delay_expressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_delay_expressionsContext)
}

func (s *Path_delay_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_delay_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Path_delay_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPath_delay_value(s)
	}
}

func (s *Path_delay_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPath_delay_value(s)
	}
}

func (p *VerilogParser) Path_delay_value() (localctx IPath_delay_valueContext) {
	localctx = NewPath_delay_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, VerilogParserRULE_path_delay_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3127)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 344, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3122)
			p.List_of_path_delay_expressions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3123)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(3124)
			p.List_of_path_delay_expressions()
		}
		{
			p.SetState(3125)
			p.Match(VerilogParserT__17)
		}

	}

	return localctx
}

// IList_of_path_delay_expressionsContext is an interface to support dynamic dispatch.
type IList_of_path_delay_expressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_path_delay_expressionsContext differentiates from other interfaces.
	IsList_of_path_delay_expressionsContext()
}

type List_of_path_delay_expressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_path_delay_expressionsContext() *List_of_path_delay_expressionsContext {
	var p = new(List_of_path_delay_expressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_path_delay_expressions
	return p
}

func (*List_of_path_delay_expressionsContext) IsList_of_path_delay_expressionsContext() {}

func NewList_of_path_delay_expressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_path_delay_expressionsContext {
	var p = new(List_of_path_delay_expressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_path_delay_expressions

	return p
}

func (s *List_of_path_delay_expressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_path_delay_expressionsContext) T_path_delay_expression() IT_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Trise_path_delay_expression() ITrise_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrise_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrise_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tfall_path_delay_expression() ITfall_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITfall_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITfall_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tz_path_delay_expression() ITz_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITz_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITz_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T01_path_delay_expression() IT01_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT01_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT01_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T10_path_delay_expression() IT10_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT10_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT10_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T0z_path_delay_expression() IT0z_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT0z_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT0z_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tz1_path_delay_expression() ITz1_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITz1_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITz1_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T1z_path_delay_expression() IT1z_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT1z_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT1z_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tz0_path_delay_expression() ITz0_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITz0_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITz0_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T0x_path_delay_expression() IT0x_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT0x_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT0x_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tx1_path_delay_expression() ITx1_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITx1_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITx1_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T1x_path_delay_expression() IT1x_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT1x_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT1x_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tx0_path_delay_expression() ITx0_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITx0_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITx0_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Txz_path_delay_expression() ITxz_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITxz_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITxz_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tzx_path_delay_expression() ITzx_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITzx_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITzx_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_path_delay_expressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_path_delay_expressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterList_of_path_delay_expressions(s)
	}
}

func (s *List_of_path_delay_expressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitList_of_path_delay_expressions(s)
	}
}

func (p *VerilogParser) List_of_path_delay_expressions() (localctx IList_of_path_delay_expressionsContext) {
	localctx = NewList_of_path_delay_expressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, VerilogParserRULE_list_of_path_delay_expressions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3176)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 345, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3129)
			p.T_path_delay_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3130)
			p.Trise_path_delay_expression()
		}
		{
			p.SetState(3131)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3132)
			p.Tfall_path_delay_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3134)
			p.Trise_path_delay_expression()
		}
		{
			p.SetState(3135)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3136)
			p.Tfall_path_delay_expression()
		}
		{
			p.SetState(3137)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3138)
			p.Tz_path_delay_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3140)
			p.T01_path_delay_expression()
		}
		{
			p.SetState(3141)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3142)
			p.T10_path_delay_expression()
		}
		{
			p.SetState(3143)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3144)
			p.T0z_path_delay_expression()
		}
		{
			p.SetState(3145)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3146)
			p.Tz1_path_delay_expression()
		}
		{
			p.SetState(3147)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3148)
			p.T1z_path_delay_expression()
		}
		{
			p.SetState(3149)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3150)
			p.Tz0_path_delay_expression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3152)
			p.T01_path_delay_expression()
		}
		{
			p.SetState(3153)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3154)
			p.T10_path_delay_expression()
		}
		{
			p.SetState(3155)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3156)
			p.T0z_path_delay_expression()
		}
		{
			p.SetState(3157)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3158)
			p.Tz1_path_delay_expression()
		}
		{
			p.SetState(3159)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3160)
			p.T1z_path_delay_expression()
		}
		{
			p.SetState(3161)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3162)
			p.Tz0_path_delay_expression()
		}
		{
			p.SetState(3163)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3164)
			p.T0x_path_delay_expression()
		}
		{
			p.SetState(3165)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3166)
			p.Tx1_path_delay_expression()
		}
		{
			p.SetState(3167)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3168)
			p.T1x_path_delay_expression()
		}
		{
			p.SetState(3169)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3170)
			p.Tx0_path_delay_expression()
		}
		{
			p.SetState(3171)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3172)
			p.Txz_path_delay_expression()
		}
		{
			p.SetState(3173)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3174)
			p.Tzx_path_delay_expression()
		}

	}

	return localctx
}

// IT_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT_path_delay_expressionContext differentiates from other interfaces.
	IsT_path_delay_expressionContext()
}

type T_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT_path_delay_expressionContext() *T_path_delay_expressionContext {
	var p = new(T_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t_path_delay_expression
	return p
}

func (*T_path_delay_expressionContext) IsT_path_delay_expressionContext() {}

func NewT_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T_path_delay_expressionContext {
	var p = new(T_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t_path_delay_expression

	return p
}

func (s *T_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterT_path_delay_expression(s)
	}
}

func (s *T_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitT_path_delay_expression(s)
	}
}

func (p *VerilogParser) T_path_delay_expression() (localctx IT_path_delay_expressionContext) {
	localctx = NewT_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, VerilogParserRULE_t_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3178)
		p.Path_delay_expression()
	}

	return localctx
}

// ITrise_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITrise_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrise_path_delay_expressionContext differentiates from other interfaces.
	IsTrise_path_delay_expressionContext()
}

type Trise_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrise_path_delay_expressionContext() *Trise_path_delay_expressionContext {
	var p = new(Trise_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_trise_path_delay_expression
	return p
}

func (*Trise_path_delay_expressionContext) IsTrise_path_delay_expressionContext() {}

func NewTrise_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trise_path_delay_expressionContext {
	var p = new(Trise_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_trise_path_delay_expression

	return p
}

func (s *Trise_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Trise_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Trise_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trise_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trise_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTrise_path_delay_expression(s)
	}
}

func (s *Trise_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTrise_path_delay_expression(s)
	}
}

func (p *VerilogParser) Trise_path_delay_expression() (localctx ITrise_path_delay_expressionContext) {
	localctx = NewTrise_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, VerilogParserRULE_trise_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3180)
		p.Path_delay_expression()
	}

	return localctx
}

// ITfall_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITfall_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTfall_path_delay_expressionContext differentiates from other interfaces.
	IsTfall_path_delay_expressionContext()
}

type Tfall_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTfall_path_delay_expressionContext() *Tfall_path_delay_expressionContext {
	var p = new(Tfall_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tfall_path_delay_expression
	return p
}

func (*Tfall_path_delay_expressionContext) IsTfall_path_delay_expressionContext() {}

func NewTfall_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tfall_path_delay_expressionContext {
	var p = new(Tfall_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tfall_path_delay_expression

	return p
}

func (s *Tfall_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tfall_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tfall_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tfall_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tfall_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTfall_path_delay_expression(s)
	}
}

func (s *Tfall_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTfall_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tfall_path_delay_expression() (localctx ITfall_path_delay_expressionContext) {
	localctx = NewTfall_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, VerilogParserRULE_tfall_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3182)
		p.Path_delay_expression()
	}

	return localctx
}

// ITz_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITz_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTz_path_delay_expressionContext differentiates from other interfaces.
	IsTz_path_delay_expressionContext()
}

type Tz_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTz_path_delay_expressionContext() *Tz_path_delay_expressionContext {
	var p = new(Tz_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tz_path_delay_expression
	return p
}

func (*Tz_path_delay_expressionContext) IsTz_path_delay_expressionContext() {}

func NewTz_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tz_path_delay_expressionContext {
	var p = new(Tz_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tz_path_delay_expression

	return p
}

func (s *Tz_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tz_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tz_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tz_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tz_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTz_path_delay_expression(s)
	}
}

func (s *Tz_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTz_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tz_path_delay_expression() (localctx ITz_path_delay_expressionContext) {
	localctx = NewTz_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, VerilogParserRULE_tz_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3184)
		p.Path_delay_expression()
	}

	return localctx
}

// IT01_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT01_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT01_path_delay_expressionContext differentiates from other interfaces.
	IsT01_path_delay_expressionContext()
}

type T01_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT01_path_delay_expressionContext() *T01_path_delay_expressionContext {
	var p = new(T01_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t01_path_delay_expression
	return p
}

func (*T01_path_delay_expressionContext) IsT01_path_delay_expressionContext() {}

func NewT01_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T01_path_delay_expressionContext {
	var p = new(T01_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t01_path_delay_expression

	return p
}

func (s *T01_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T01_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T01_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T01_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T01_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterT01_path_delay_expression(s)
	}
}

func (s *T01_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitT01_path_delay_expression(s)
	}
}

func (p *VerilogParser) T01_path_delay_expression() (localctx IT01_path_delay_expressionContext) {
	localctx = NewT01_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, VerilogParserRULE_t01_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3186)
		p.Path_delay_expression()
	}

	return localctx
}

// IT10_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT10_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT10_path_delay_expressionContext differentiates from other interfaces.
	IsT10_path_delay_expressionContext()
}

type T10_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT10_path_delay_expressionContext() *T10_path_delay_expressionContext {
	var p = new(T10_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t10_path_delay_expression
	return p
}

func (*T10_path_delay_expressionContext) IsT10_path_delay_expressionContext() {}

func NewT10_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T10_path_delay_expressionContext {
	var p = new(T10_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t10_path_delay_expression

	return p
}

func (s *T10_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T10_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T10_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T10_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T10_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterT10_path_delay_expression(s)
	}
}

func (s *T10_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitT10_path_delay_expression(s)
	}
}

func (p *VerilogParser) T10_path_delay_expression() (localctx IT10_path_delay_expressionContext) {
	localctx = NewT10_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, VerilogParserRULE_t10_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3188)
		p.Path_delay_expression()
	}

	return localctx
}

// IT0z_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT0z_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT0z_path_delay_expressionContext differentiates from other interfaces.
	IsT0z_path_delay_expressionContext()
}

type T0z_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT0z_path_delay_expressionContext() *T0z_path_delay_expressionContext {
	var p = new(T0z_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t0z_path_delay_expression
	return p
}

func (*T0z_path_delay_expressionContext) IsT0z_path_delay_expressionContext() {}

func NewT0z_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T0z_path_delay_expressionContext {
	var p = new(T0z_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t0z_path_delay_expression

	return p
}

func (s *T0z_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T0z_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T0z_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T0z_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T0z_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterT0z_path_delay_expression(s)
	}
}

func (s *T0z_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitT0z_path_delay_expression(s)
	}
}

func (p *VerilogParser) T0z_path_delay_expression() (localctx IT0z_path_delay_expressionContext) {
	localctx = NewT0z_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, VerilogParserRULE_t0z_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3190)
		p.Path_delay_expression()
	}

	return localctx
}

// ITz1_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITz1_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTz1_path_delay_expressionContext differentiates from other interfaces.
	IsTz1_path_delay_expressionContext()
}

type Tz1_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTz1_path_delay_expressionContext() *Tz1_path_delay_expressionContext {
	var p = new(Tz1_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tz1_path_delay_expression
	return p
}

func (*Tz1_path_delay_expressionContext) IsTz1_path_delay_expressionContext() {}

func NewTz1_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tz1_path_delay_expressionContext {
	var p = new(Tz1_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tz1_path_delay_expression

	return p
}

func (s *Tz1_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tz1_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tz1_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tz1_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tz1_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTz1_path_delay_expression(s)
	}
}

func (s *Tz1_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTz1_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tz1_path_delay_expression() (localctx ITz1_path_delay_expressionContext) {
	localctx = NewTz1_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, VerilogParserRULE_tz1_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3192)
		p.Path_delay_expression()
	}

	return localctx
}

// IT1z_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT1z_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT1z_path_delay_expressionContext differentiates from other interfaces.
	IsT1z_path_delay_expressionContext()
}

type T1z_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT1z_path_delay_expressionContext() *T1z_path_delay_expressionContext {
	var p = new(T1z_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t1z_path_delay_expression
	return p
}

func (*T1z_path_delay_expressionContext) IsT1z_path_delay_expressionContext() {}

func NewT1z_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T1z_path_delay_expressionContext {
	var p = new(T1z_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t1z_path_delay_expression

	return p
}

func (s *T1z_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T1z_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T1z_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T1z_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T1z_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterT1z_path_delay_expression(s)
	}
}

func (s *T1z_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitT1z_path_delay_expression(s)
	}
}

func (p *VerilogParser) T1z_path_delay_expression() (localctx IT1z_path_delay_expressionContext) {
	localctx = NewT1z_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, VerilogParserRULE_t1z_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3194)
		p.Path_delay_expression()
	}

	return localctx
}

// ITz0_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITz0_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTz0_path_delay_expressionContext differentiates from other interfaces.
	IsTz0_path_delay_expressionContext()
}

type Tz0_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTz0_path_delay_expressionContext() *Tz0_path_delay_expressionContext {
	var p = new(Tz0_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tz0_path_delay_expression
	return p
}

func (*Tz0_path_delay_expressionContext) IsTz0_path_delay_expressionContext() {}

func NewTz0_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tz0_path_delay_expressionContext {
	var p = new(Tz0_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tz0_path_delay_expression

	return p
}

func (s *Tz0_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tz0_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tz0_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tz0_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tz0_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTz0_path_delay_expression(s)
	}
}

func (s *Tz0_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTz0_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tz0_path_delay_expression() (localctx ITz0_path_delay_expressionContext) {
	localctx = NewTz0_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, VerilogParserRULE_tz0_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3196)
		p.Path_delay_expression()
	}

	return localctx
}

// IT0x_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT0x_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT0x_path_delay_expressionContext differentiates from other interfaces.
	IsT0x_path_delay_expressionContext()
}

type T0x_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT0x_path_delay_expressionContext() *T0x_path_delay_expressionContext {
	var p = new(T0x_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t0x_path_delay_expression
	return p
}

func (*T0x_path_delay_expressionContext) IsT0x_path_delay_expressionContext() {}

func NewT0x_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T0x_path_delay_expressionContext {
	var p = new(T0x_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t0x_path_delay_expression

	return p
}

func (s *T0x_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T0x_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T0x_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T0x_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T0x_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterT0x_path_delay_expression(s)
	}
}

func (s *T0x_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitT0x_path_delay_expression(s)
	}
}

func (p *VerilogParser) T0x_path_delay_expression() (localctx IT0x_path_delay_expressionContext) {
	localctx = NewT0x_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, VerilogParserRULE_t0x_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3198)
		p.Path_delay_expression()
	}

	return localctx
}

// ITx1_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITx1_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTx1_path_delay_expressionContext differentiates from other interfaces.
	IsTx1_path_delay_expressionContext()
}

type Tx1_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTx1_path_delay_expressionContext() *Tx1_path_delay_expressionContext {
	var p = new(Tx1_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tx1_path_delay_expression
	return p
}

func (*Tx1_path_delay_expressionContext) IsTx1_path_delay_expressionContext() {}

func NewTx1_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tx1_path_delay_expressionContext {
	var p = new(Tx1_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tx1_path_delay_expression

	return p
}

func (s *Tx1_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tx1_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tx1_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tx1_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tx1_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTx1_path_delay_expression(s)
	}
}

func (s *Tx1_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTx1_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tx1_path_delay_expression() (localctx ITx1_path_delay_expressionContext) {
	localctx = NewTx1_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, VerilogParserRULE_tx1_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3200)
		p.Path_delay_expression()
	}

	return localctx
}

// IT1x_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT1x_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT1x_path_delay_expressionContext differentiates from other interfaces.
	IsT1x_path_delay_expressionContext()
}

type T1x_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT1x_path_delay_expressionContext() *T1x_path_delay_expressionContext {
	var p = new(T1x_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t1x_path_delay_expression
	return p
}

func (*T1x_path_delay_expressionContext) IsT1x_path_delay_expressionContext() {}

func NewT1x_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T1x_path_delay_expressionContext {
	var p = new(T1x_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t1x_path_delay_expression

	return p
}

func (s *T1x_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T1x_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T1x_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T1x_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T1x_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterT1x_path_delay_expression(s)
	}
}

func (s *T1x_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitT1x_path_delay_expression(s)
	}
}

func (p *VerilogParser) T1x_path_delay_expression() (localctx IT1x_path_delay_expressionContext) {
	localctx = NewT1x_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, VerilogParserRULE_t1x_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3202)
		p.Path_delay_expression()
	}

	return localctx
}

// ITx0_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITx0_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTx0_path_delay_expressionContext differentiates from other interfaces.
	IsTx0_path_delay_expressionContext()
}

type Tx0_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTx0_path_delay_expressionContext() *Tx0_path_delay_expressionContext {
	var p = new(Tx0_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tx0_path_delay_expression
	return p
}

func (*Tx0_path_delay_expressionContext) IsTx0_path_delay_expressionContext() {}

func NewTx0_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tx0_path_delay_expressionContext {
	var p = new(Tx0_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tx0_path_delay_expression

	return p
}

func (s *Tx0_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tx0_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tx0_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tx0_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tx0_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTx0_path_delay_expression(s)
	}
}

func (s *Tx0_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTx0_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tx0_path_delay_expression() (localctx ITx0_path_delay_expressionContext) {
	localctx = NewTx0_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, VerilogParserRULE_tx0_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3204)
		p.Path_delay_expression()
	}

	return localctx
}

// ITxz_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITxz_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTxz_path_delay_expressionContext differentiates from other interfaces.
	IsTxz_path_delay_expressionContext()
}

type Txz_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTxz_path_delay_expressionContext() *Txz_path_delay_expressionContext {
	var p = new(Txz_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_txz_path_delay_expression
	return p
}

func (*Txz_path_delay_expressionContext) IsTxz_path_delay_expressionContext() {}

func NewTxz_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Txz_path_delay_expressionContext {
	var p = new(Txz_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_txz_path_delay_expression

	return p
}

func (s *Txz_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Txz_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Txz_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Txz_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Txz_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTxz_path_delay_expression(s)
	}
}

func (s *Txz_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTxz_path_delay_expression(s)
	}
}

func (p *VerilogParser) Txz_path_delay_expression() (localctx ITxz_path_delay_expressionContext) {
	localctx = NewTxz_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, VerilogParserRULE_txz_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3206)
		p.Path_delay_expression()
	}

	return localctx
}

// ITzx_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITzx_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTzx_path_delay_expressionContext differentiates from other interfaces.
	IsTzx_path_delay_expressionContext()
}

type Tzx_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTzx_path_delay_expressionContext() *Tzx_path_delay_expressionContext {
	var p = new(Tzx_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tzx_path_delay_expression
	return p
}

func (*Tzx_path_delay_expressionContext) IsTzx_path_delay_expressionContext() {}

func NewTzx_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tzx_path_delay_expressionContext {
	var p = new(Tzx_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tzx_path_delay_expression

	return p
}

func (s *Tzx_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tzx_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tzx_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tzx_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tzx_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTzx_path_delay_expression(s)
	}
}

func (s *Tzx_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTzx_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tzx_path_delay_expression() (localctx ITzx_path_delay_expressionContext) {
	localctx = NewTzx_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, VerilogParserRULE_tzx_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3208)
		p.Path_delay_expression()
	}

	return localctx
}

// IPath_delay_expressionContext is an interface to support dynamic dispatch.
type IPath_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPath_delay_expressionContext differentiates from other interfaces.
	IsPath_delay_expressionContext()
}

type Path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_delay_expressionContext() *Path_delay_expressionContext {
	var p = new(Path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_path_delay_expression
	return p
}

func (*Path_delay_expressionContext) IsPath_delay_expressionContext() {}

func NewPath_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_delay_expressionContext {
	var p = new(Path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_path_delay_expression

	return p
}

func (s *Path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_delay_expressionContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPath_delay_expression(s)
	}
}

func (s *Path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPath_delay_expression(s)
	}
}

func (p *VerilogParser) Path_delay_expression() (localctx IPath_delay_expressionContext) {
	localctx = NewPath_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, VerilogParserRULE_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3210)
		p.Constant_mintypmax_expression()
	}

	return localctx
}

// IEdge_sensitive_path_declarationContext is an interface to support dynamic dispatch.
type IEdge_sensitive_path_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEdge_sensitive_path_declarationContext differentiates from other interfaces.
	IsEdge_sensitive_path_declarationContext()
}

type Edge_sensitive_path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdge_sensitive_path_declarationContext() *Edge_sensitive_path_declarationContext {
	var p = new(Edge_sensitive_path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_edge_sensitive_path_declaration
	return p
}

func (*Edge_sensitive_path_declarationContext) IsEdge_sensitive_path_declarationContext() {}

func NewEdge_sensitive_path_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Edge_sensitive_path_declarationContext {
	var p = new(Edge_sensitive_path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_edge_sensitive_path_declaration

	return p
}

func (s *Edge_sensitive_path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Edge_sensitive_path_declarationContext) Parallel_edge_sensitive_path_description() IParallel_edge_sensitive_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParallel_edge_sensitive_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParallel_edge_sensitive_path_descriptionContext)
}

func (s *Edge_sensitive_path_declarationContext) Path_delay_value() IPath_delay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_valueContext)
}

func (s *Edge_sensitive_path_declarationContext) Full_edge_sensitive_path_description() IFull_edge_sensitive_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_edge_sensitive_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_edge_sensitive_path_descriptionContext)
}

func (s *Edge_sensitive_path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Edge_sensitive_path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Edge_sensitive_path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEdge_sensitive_path_declaration(s)
	}
}

func (s *Edge_sensitive_path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEdge_sensitive_path_declaration(s)
	}
}

func (p *VerilogParser) Edge_sensitive_path_declaration() (localctx IEdge_sensitive_path_declarationContext) {
	localctx = NewEdge_sensitive_path_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, VerilogParserRULE_edge_sensitive_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3220)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 346, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3212)
			p.Parallel_edge_sensitive_path_description()
		}
		{
			p.SetState(3213)
			p.Match(VerilogParserT__50)
		}
		{
			p.SetState(3214)
			p.Path_delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3216)
			p.Full_edge_sensitive_path_description()
		}
		{
			p.SetState(3217)
			p.Match(VerilogParserT__50)
		}
		{
			p.SetState(3218)
			p.Path_delay_value()
		}

	}

	return localctx
}

// IParallel_edge_sensitive_path_descriptionContext is an interface to support dynamic dispatch.
type IParallel_edge_sensitive_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParallel_edge_sensitive_path_descriptionContext differentiates from other interfaces.
	IsParallel_edge_sensitive_path_descriptionContext()
}

type Parallel_edge_sensitive_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParallel_edge_sensitive_path_descriptionContext() *Parallel_edge_sensitive_path_descriptionContext {
	var p = new(Parallel_edge_sensitive_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parallel_edge_sensitive_path_description
	return p
}

func (*Parallel_edge_sensitive_path_descriptionContext) IsParallel_edge_sensitive_path_descriptionContext() {
}

func NewParallel_edge_sensitive_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parallel_edge_sensitive_path_descriptionContext {
	var p = new(Parallel_edge_sensitive_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parallel_edge_sensitive_path_description

	return p
}

func (s *Parallel_edge_sensitive_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Parallel_edge_sensitive_path_descriptionContext) Specify_input_terminal_descriptor() ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Specify_output_terminal_descriptor() ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Data_source_expression() IData_source_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_source_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_source_expressionContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Edge_identifier() IEdge_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_identifierContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parallel_edge_sensitive_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterParallel_edge_sensitive_path_description(s)
	}
}

func (s *Parallel_edge_sensitive_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitParallel_edge_sensitive_path_description(s)
	}
}

func (p *VerilogParser) Parallel_edge_sensitive_path_description() (localctx IParallel_edge_sensitive_path_descriptionContext) {
	localctx = NewParallel_edge_sensitive_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, VerilogParserRULE_parallel_edge_sensitive_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3222)
		p.Match(VerilogParserT__15)
	}
	p.SetState(3224)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__119 || _la == VerilogParserT__120 {
		{
			p.SetState(3223)
			p.Edge_identifier()
		}

	}
	{
		p.SetState(3226)
		p.Specify_input_terminal_descriptor()
	}
	{
		p.SetState(3227)
		p.Match(VerilogParserT__132)
	}
	{
		p.SetState(3228)
		p.Specify_output_terminal_descriptor()
	}
	p.SetState(3230)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__135 || _la == VerilogParserT__136 {
		{
			p.SetState(3229)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(3232)
		p.Match(VerilogParserT__64)
	}
	{
		p.SetState(3233)
		p.Data_source_expression()
	}
	{
		p.SetState(3234)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IFull_edge_sensitive_path_descriptionContext is an interface to support dynamic dispatch.
type IFull_edge_sensitive_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFull_edge_sensitive_path_descriptionContext differentiates from other interfaces.
	IsFull_edge_sensitive_path_descriptionContext()
}

type Full_edge_sensitive_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFull_edge_sensitive_path_descriptionContext() *Full_edge_sensitive_path_descriptionContext {
	var p = new(Full_edge_sensitive_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_full_edge_sensitive_path_description
	return p
}

func (*Full_edge_sensitive_path_descriptionContext) IsFull_edge_sensitive_path_descriptionContext() {}

func NewFull_edge_sensitive_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Full_edge_sensitive_path_descriptionContext {
	var p = new(Full_edge_sensitive_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_full_edge_sensitive_path_description

	return p
}

func (s *Full_edge_sensitive_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Full_edge_sensitive_path_descriptionContext) List_of_path_inputs() IList_of_path_inputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_inputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_inputsContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) Data_source_expression() IData_source_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_source_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_source_expressionContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) Edge_identifier() IEdge_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_identifierContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Full_edge_sensitive_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Full_edge_sensitive_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFull_edge_sensitive_path_description(s)
	}
}

func (s *Full_edge_sensitive_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFull_edge_sensitive_path_description(s)
	}
}

func (p *VerilogParser) Full_edge_sensitive_path_description() (localctx IFull_edge_sensitive_path_descriptionContext) {
	localctx = NewFull_edge_sensitive_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, VerilogParserRULE_full_edge_sensitive_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3236)
		p.Match(VerilogParserT__15)
	}
	p.SetState(3238)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__119 || _la == VerilogParserT__120 {
		{
			p.SetState(3237)
			p.Edge_identifier()
		}

	}
	{
		p.SetState(3240)
		p.List_of_path_inputs()
	}
	{
		p.SetState(3241)
		p.Match(VerilogParserT__133)
	}
	{
		p.SetState(3242)
		p.List_of_path_outputs()
	}
	p.SetState(3244)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__135 || _la == VerilogParserT__136 {
		{
			p.SetState(3243)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(3246)
		p.Match(VerilogParserT__64)
	}
	{
		p.SetState(3247)
		p.Data_source_expression()
	}
	{
		p.SetState(3248)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IData_source_expressionContext is an interface to support dynamic dispatch.
type IData_source_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsData_source_expressionContext differentiates from other interfaces.
	IsData_source_expressionContext()
}

type Data_source_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_source_expressionContext() *Data_source_expressionContext {
	var p = new(Data_source_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_data_source_expression
	return p
}

func (*Data_source_expressionContext) IsData_source_expressionContext() {}

func NewData_source_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_source_expressionContext {
	var p = new(Data_source_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_data_source_expression

	return p
}

func (s *Data_source_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_source_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Data_source_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_source_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_source_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterData_source_expression(s)
	}
}

func (s *Data_source_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitData_source_expression(s)
	}
}

func (p *VerilogParser) Data_source_expression() (localctx IData_source_expressionContext) {
	localctx = NewData_source_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, VerilogParserRULE_data_source_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3250)
		p.Expression()
	}

	return localctx
}

// IEdge_identifierContext is an interface to support dynamic dispatch.
type IEdge_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEdge_identifierContext differentiates from other interfaces.
	IsEdge_identifierContext()
}

type Edge_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdge_identifierContext() *Edge_identifierContext {
	var p = new(Edge_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_edge_identifier
	return p
}

func (*Edge_identifierContext) IsEdge_identifierContext() {}

func NewEdge_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Edge_identifierContext {
	var p = new(Edge_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_edge_identifier

	return p
}

func (s *Edge_identifierContext) GetParser() antlr.Parser { return s.parser }
func (s *Edge_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Edge_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Edge_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEdge_identifier(s)
	}
}

func (s *Edge_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEdge_identifier(s)
	}
}

func (p *VerilogParser) Edge_identifier() (localctx IEdge_identifierContext) {
	localctx = NewEdge_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, VerilogParserRULE_edge_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3252)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserT__119 || _la == VerilogParserT__120) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IState_dependent_path_declarationContext is an interface to support dynamic dispatch.
type IState_dependent_path_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsState_dependent_path_declarationContext differentiates from other interfaces.
	IsState_dependent_path_declarationContext()
}

type State_dependent_path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyState_dependent_path_declarationContext() *State_dependent_path_declarationContext {
	var p = new(State_dependent_path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_state_dependent_path_declaration
	return p
}

func (*State_dependent_path_declarationContext) IsState_dependent_path_declarationContext() {}

func NewState_dependent_path_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *State_dependent_path_declarationContext {
	var p = new(State_dependent_path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_state_dependent_path_declaration

	return p
}

func (s *State_dependent_path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *State_dependent_path_declarationContext) Module_path_expression() IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *State_dependent_path_declarationContext) Simple_path_declaration() ISimple_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_path_declarationContext)
}

func (s *State_dependent_path_declarationContext) Edge_sensitive_path_declaration() IEdge_sensitive_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_sensitive_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_sensitive_path_declarationContext)
}

func (s *State_dependent_path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *State_dependent_path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *State_dependent_path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterState_dependent_path_declaration(s)
	}
}

func (s *State_dependent_path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitState_dependent_path_declaration(s)
	}
}

func (p *VerilogParser) State_dependent_path_declaration() (localctx IState_dependent_path_declarationContext) {
	localctx = NewState_dependent_path_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, VerilogParserRULE_state_dependent_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3268)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 351, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3254)
			p.Match(VerilogParserT__98)
		}
		{
			p.SetState(3255)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(3256)
			p.Module_path_expression()
		}
		{
			p.SetState(3257)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(3258)
			p.Simple_path_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3260)
			p.Match(VerilogParserT__98)
		}
		{
			p.SetState(3261)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(3262)
			p.Module_path_expression()
		}
		{
			p.SetState(3263)
			p.Match(VerilogParserT__17)
		}
		{
			p.SetState(3264)
			p.Edge_sensitive_path_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3266)
			p.Match(VerilogParserT__134)
		}
		{
			p.SetState(3267)
			p.Simple_path_declaration()
		}

	}

	return localctx
}

// IPolarity_operatorContext is an interface to support dynamic dispatch.
type IPolarity_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPolarity_operatorContext differentiates from other interfaces.
	IsPolarity_operatorContext()
}

type Polarity_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPolarity_operatorContext() *Polarity_operatorContext {
	var p = new(Polarity_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_polarity_operator
	return p
}

func (*Polarity_operatorContext) IsPolarity_operatorContext() {}

func NewPolarity_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Polarity_operatorContext {
	var p = new(Polarity_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_polarity_operator

	return p
}

func (s *Polarity_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Polarity_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Polarity_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Polarity_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPolarity_operator(s)
	}
}

func (s *Polarity_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPolarity_operator(s)
	}
}

func (p *VerilogParser) Polarity_operator() (localctx IPolarity_operatorContext) {
	localctx = NewPolarity_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, VerilogParserRULE_polarity_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3270)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserT__135 || _la == VerilogParserT__136) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IChecktime_conditionContext is an interface to support dynamic dispatch.
type IChecktime_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChecktime_conditionContext differentiates from other interfaces.
	IsChecktime_conditionContext()
}

type Checktime_conditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChecktime_conditionContext() *Checktime_conditionContext {
	var p = new(Checktime_conditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_checktime_condition
	return p
}

func (*Checktime_conditionContext) IsChecktime_conditionContext() {}

func NewChecktime_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Checktime_conditionContext {
	var p = new(Checktime_conditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_checktime_condition

	return p
}

func (s *Checktime_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Checktime_conditionContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Checktime_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Checktime_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Checktime_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterChecktime_condition(s)
	}
}

func (s *Checktime_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitChecktime_condition(s)
	}
}

func (p *VerilogParser) Checktime_condition() (localctx IChecktime_conditionContext) {
	localctx = NewChecktime_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, VerilogParserRULE_checktime_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3272)
		p.Mintypmax_expression()
	}

	return localctx
}

// IDelayed_dataContext is an interface to support dynamic dispatch.
type IDelayed_dataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelayed_dataContext differentiates from other interfaces.
	IsDelayed_dataContext()
}

type Delayed_dataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelayed_dataContext() *Delayed_dataContext {
	var p = new(Delayed_dataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delayed_data
	return p
}

func (*Delayed_dataContext) IsDelayed_dataContext() {}

func NewDelayed_dataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delayed_dataContext {
	var p = new(Delayed_dataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delayed_data

	return p
}

func (s *Delayed_dataContext) GetParser() antlr.Parser { return s.parser }

func (s *Delayed_dataContext) Terminal_identifier() ITerminal_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_identifierContext)
}

func (s *Delayed_dataContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Delayed_dataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delayed_dataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delayed_dataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDelayed_data(s)
	}
}

func (s *Delayed_dataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDelayed_data(s)
	}
}

func (p *VerilogParser) Delayed_data() (localctx IDelayed_dataContext) {
	localctx = NewDelayed_dataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, VerilogParserRULE_delayed_data)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3280)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 352, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3274)
			p.Terminal_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3275)
			p.Terminal_identifier()
		}
		{
			p.SetState(3276)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3277)
			p.Constant_mintypmax_expression()
		}
		{
			p.SetState(3278)
			p.Match(VerilogParserT__21)
		}

	}

	return localctx
}

// IDelayed_referenceContext is an interface to support dynamic dispatch.
type IDelayed_referenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelayed_referenceContext differentiates from other interfaces.
	IsDelayed_referenceContext()
}

type Delayed_referenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelayed_referenceContext() *Delayed_referenceContext {
	var p = new(Delayed_referenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delayed_reference
	return p
}

func (*Delayed_referenceContext) IsDelayed_referenceContext() {}

func NewDelayed_referenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delayed_referenceContext {
	var p = new(Delayed_referenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delayed_reference

	return p
}

func (s *Delayed_referenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Delayed_referenceContext) Terminal_identifier() ITerminal_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_identifierContext)
}

func (s *Delayed_referenceContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Delayed_referenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delayed_referenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delayed_referenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDelayed_reference(s)
	}
}

func (s *Delayed_referenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDelayed_reference(s)
	}
}

func (p *VerilogParser) Delayed_reference() (localctx IDelayed_referenceContext) {
	localctx = NewDelayed_referenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, VerilogParserRULE_delayed_reference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3288)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 353, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3282)
			p.Terminal_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3283)
			p.Terminal_identifier()
		}
		{
			p.SetState(3284)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3285)
			p.Constant_mintypmax_expression()
		}
		{
			p.SetState(3286)
			p.Match(VerilogParserT__21)
		}

	}

	return localctx
}

// IEnd_edge_offsetContext is an interface to support dynamic dispatch.
type IEnd_edge_offsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnd_edge_offsetContext differentiates from other interfaces.
	IsEnd_edge_offsetContext()
}

type End_edge_offsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnd_edge_offsetContext() *End_edge_offsetContext {
	var p = new(End_edge_offsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_end_edge_offset
	return p
}

func (*End_edge_offsetContext) IsEnd_edge_offsetContext() {}

func NewEnd_edge_offsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *End_edge_offsetContext {
	var p = new(End_edge_offsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_end_edge_offset

	return p
}

func (s *End_edge_offsetContext) GetParser() antlr.Parser { return s.parser }

func (s *End_edge_offsetContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *End_edge_offsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *End_edge_offsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *End_edge_offsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEnd_edge_offset(s)
	}
}

func (s *End_edge_offsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEnd_edge_offset(s)
	}
}

func (p *VerilogParser) End_edge_offset() (localctx IEnd_edge_offsetContext) {
	localctx = NewEnd_edge_offsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, VerilogParserRULE_end_edge_offset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3290)
		p.Mintypmax_expression()
	}

	return localctx
}

// IEvent_based_flagContext is an interface to support dynamic dispatch.
type IEvent_based_flagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_based_flagContext differentiates from other interfaces.
	IsEvent_based_flagContext()
}

type Event_based_flagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_based_flagContext() *Event_based_flagContext {
	var p = new(Event_based_flagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_based_flag
	return p
}

func (*Event_based_flagContext) IsEvent_based_flagContext() {}

func NewEvent_based_flagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_based_flagContext {
	var p = new(Event_based_flagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_based_flag

	return p
}

func (s *Event_based_flagContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_based_flagContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Event_based_flagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_based_flagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_based_flagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEvent_based_flag(s)
	}
}

func (s *Event_based_flagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEvent_based_flag(s)
	}
}

func (p *VerilogParser) Event_based_flag() (localctx IEvent_based_flagContext) {
	localctx = NewEvent_based_flagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, VerilogParserRULE_event_based_flag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3292)
		p.Constant_expression()
	}

	return localctx
}

// INotify_regContext is an interface to support dynamic dispatch.
type INotify_regContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotify_regContext differentiates from other interfaces.
	IsNotify_regContext()
}

type Notify_regContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotify_regContext() *Notify_regContext {
	var p = new(Notify_regContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_notify_reg
	return p
}

func (*Notify_regContext) IsNotify_regContext() {}

func NewNotify_regContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Notify_regContext {
	var p = new(Notify_regContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_notify_reg

	return p
}

func (s *Notify_regContext) GetParser() antlr.Parser { return s.parser }

func (s *Notify_regContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Notify_regContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Notify_regContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Notify_regContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNotify_reg(s)
	}
}

func (s *Notify_regContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNotify_reg(s)
	}
}

func (p *VerilogParser) Notify_reg() (localctx INotify_regContext) {
	localctx = NewNotify_regContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, VerilogParserRULE_notify_reg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3294)
		p.Variable_identifier()
	}

	return localctx
}

// IRemain_active_flagContext is an interface to support dynamic dispatch.
type IRemain_active_flagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemain_active_flagContext differentiates from other interfaces.
	IsRemain_active_flagContext()
}

type Remain_active_flagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemain_active_flagContext() *Remain_active_flagContext {
	var p = new(Remain_active_flagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_remain_active_flag
	return p
}

func (*Remain_active_flagContext) IsRemain_active_flagContext() {}

func NewRemain_active_flagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Remain_active_flagContext {
	var p = new(Remain_active_flagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_remain_active_flag

	return p
}

func (s *Remain_active_flagContext) GetParser() antlr.Parser { return s.parser }

func (s *Remain_active_flagContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Remain_active_flagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Remain_active_flagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Remain_active_flagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterRemain_active_flag(s)
	}
}

func (s *Remain_active_flagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitRemain_active_flag(s)
	}
}

func (p *VerilogParser) Remain_active_flag() (localctx IRemain_active_flagContext) {
	localctx = NewRemain_active_flagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, VerilogParserRULE_remain_active_flag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3296)
		p.Constant_mintypmax_expression()
	}

	return localctx
}

// IStamptime_conditionContext is an interface to support dynamic dispatch.
type IStamptime_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStamptime_conditionContext differentiates from other interfaces.
	IsStamptime_conditionContext()
}

type Stamptime_conditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStamptime_conditionContext() *Stamptime_conditionContext {
	var p = new(Stamptime_conditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_stamptime_condition
	return p
}

func (*Stamptime_conditionContext) IsStamptime_conditionContext() {}

func NewStamptime_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stamptime_conditionContext {
	var p = new(Stamptime_conditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_stamptime_condition

	return p
}

func (s *Stamptime_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Stamptime_conditionContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Stamptime_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stamptime_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stamptime_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterStamptime_condition(s)
	}
}

func (s *Stamptime_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitStamptime_condition(s)
	}
}

func (p *VerilogParser) Stamptime_condition() (localctx IStamptime_conditionContext) {
	localctx = NewStamptime_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, VerilogParserRULE_stamptime_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3298)
		p.Mintypmax_expression()
	}

	return localctx
}

// IStart_edge_offsetContext is an interface to support dynamic dispatch.
type IStart_edge_offsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStart_edge_offsetContext differentiates from other interfaces.
	IsStart_edge_offsetContext()
}

type Start_edge_offsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStart_edge_offsetContext() *Start_edge_offsetContext {
	var p = new(Start_edge_offsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_start_edge_offset
	return p
}

func (*Start_edge_offsetContext) IsStart_edge_offsetContext() {}

func NewStart_edge_offsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Start_edge_offsetContext {
	var p = new(Start_edge_offsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_start_edge_offset

	return p
}

func (s *Start_edge_offsetContext) GetParser() antlr.Parser { return s.parser }

func (s *Start_edge_offsetContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Start_edge_offsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Start_edge_offsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Start_edge_offsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterStart_edge_offset(s)
	}
}

func (s *Start_edge_offsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitStart_edge_offset(s)
	}
}

func (p *VerilogParser) Start_edge_offset() (localctx IStart_edge_offsetContext) {
	localctx = NewStart_edge_offsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, VerilogParserRULE_start_edge_offset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3300)
		p.Mintypmax_expression()
	}

	return localctx
}

// IThresholdContext is an interface to support dynamic dispatch.
type IThresholdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThresholdContext differentiates from other interfaces.
	IsThresholdContext()
}

type ThresholdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThresholdContext() *ThresholdContext {
	var p = new(ThresholdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_threshold
	return p
}

func (*ThresholdContext) IsThresholdContext() {}

func NewThresholdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThresholdContext {
	var p = new(ThresholdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_threshold

	return p
}

func (s *ThresholdContext) GetParser() antlr.Parser { return s.parser }

func (s *ThresholdContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *ThresholdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThresholdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThresholdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterThreshold(s)
	}
}

func (s *ThresholdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitThreshold(s)
	}
}

func (p *VerilogParser) Threshold() (localctx IThresholdContext) {
	localctx = NewThresholdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, VerilogParserRULE_threshold)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3302)
		p.Constant_expression()
	}

	return localctx
}

// ITiming_check_limitContext is an interface to support dynamic dispatch.
type ITiming_check_limitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTiming_check_limitContext differentiates from other interfaces.
	IsTiming_check_limitContext()
}

type Timing_check_limitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTiming_check_limitContext() *Timing_check_limitContext {
	var p = new(Timing_check_limitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_timing_check_limit
	return p
}

func (*Timing_check_limitContext) IsTiming_check_limitContext() {}

func NewTiming_check_limitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timing_check_limitContext {
	var p = new(Timing_check_limitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_timing_check_limit

	return p
}

func (s *Timing_check_limitContext) GetParser() antlr.Parser { return s.parser }

func (s *Timing_check_limitContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Timing_check_limitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timing_check_limitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timing_check_limitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTiming_check_limit(s)
	}
}

func (s *Timing_check_limitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTiming_check_limit(s)
	}
}

func (p *VerilogParser) Timing_check_limit() (localctx ITiming_check_limitContext) {
	localctx = NewTiming_check_limitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, VerilogParserRULE_timing_check_limit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3304)
		p.Expression()
	}

	return localctx
}

// IConcatenationContext is an interface to support dynamic dispatch.
type IConcatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcatenationContext differentiates from other interfaces.
	IsConcatenationContext()
}

type ConcatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcatenationContext() *ConcatenationContext {
	var p = new(ConcatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_concatenation
	return p
}

func (*ConcatenationContext) IsConcatenationContext() {}

func NewConcatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_concatenation

	return p
}

func (s *ConcatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConcatenationContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ConcatenationContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

func (p *VerilogParser) Concatenation() (localctx IConcatenationContext) {
	localctx = NewConcatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, VerilogParserRULE_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3306)
		p.Match(VerilogParserT__18)
	}
	{
		p.SetState(3307)
		p.Expression()
	}
	p.SetState(3312)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(3308)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3309)
			p.Expression()
		}

		p.SetState(3314)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3315)
		p.Match(VerilogParserT__19)
	}

	return localctx
}

// IConstant_concatenationContext is an interface to support dynamic dispatch.
type IConstant_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_concatenationContext differentiates from other interfaces.
	IsConstant_concatenationContext()
}

type Constant_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_concatenationContext() *Constant_concatenationContext {
	var p = new(Constant_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_concatenation
	return p
}

func (*Constant_concatenationContext) IsConstant_concatenationContext() {}

func NewConstant_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_concatenationContext {
	var p = new(Constant_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_concatenation

	return p
}

func (s *Constant_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_concatenationContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_concatenationContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterConstant_concatenation(s)
	}
}

func (s *Constant_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitConstant_concatenation(s)
	}
}

func (p *VerilogParser) Constant_concatenation() (localctx IConstant_concatenationContext) {
	localctx = NewConstant_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, VerilogParserRULE_constant_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3317)
		p.Match(VerilogParserT__18)
	}
	{
		p.SetState(3318)
		p.Constant_expression()
	}
	p.SetState(3323)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(3319)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3320)
			p.Constant_expression()
		}

		p.SetState(3325)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3326)
		p.Match(VerilogParserT__19)
	}

	return localctx
}

// IConstant_multiple_concatenationContext is an interface to support dynamic dispatch.
type IConstant_multiple_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_multiple_concatenationContext differentiates from other interfaces.
	IsConstant_multiple_concatenationContext()
}

type Constant_multiple_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_multiple_concatenationContext() *Constant_multiple_concatenationContext {
	var p = new(Constant_multiple_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_multiple_concatenation
	return p
}

func (*Constant_multiple_concatenationContext) IsConstant_multiple_concatenationContext() {}

func NewConstant_multiple_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_multiple_concatenationContext {
	var p = new(Constant_multiple_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_multiple_concatenation

	return p
}

func (s *Constant_multiple_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_multiple_concatenationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_multiple_concatenationContext) Constant_concatenation() IConstant_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_concatenationContext)
}

func (s *Constant_multiple_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_multiple_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_multiple_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterConstant_multiple_concatenation(s)
	}
}

func (s *Constant_multiple_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitConstant_multiple_concatenation(s)
	}
}

func (p *VerilogParser) Constant_multiple_concatenation() (localctx IConstant_multiple_concatenationContext) {
	localctx = NewConstant_multiple_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, VerilogParserRULE_constant_multiple_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3328)
		p.Match(VerilogParserT__18)
	}
	{
		p.SetState(3329)
		p.Constant_expression()
	}
	{
		p.SetState(3330)
		p.Constant_concatenation()
	}
	{
		p.SetState(3331)
		p.Match(VerilogParserT__19)
	}

	return localctx
}

// IModule_path_concatenationContext is an interface to support dynamic dispatch.
type IModule_path_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_concatenationContext differentiates from other interfaces.
	IsModule_path_concatenationContext()
}

type Module_path_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_concatenationContext() *Module_path_concatenationContext {
	var p = new(Module_path_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_concatenation
	return p
}

func (*Module_path_concatenationContext) IsModule_path_concatenationContext() {}

func NewModule_path_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_concatenationContext {
	var p = new(Module_path_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_concatenation

	return p
}

func (s *Module_path_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_concatenationContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_concatenationContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_path_concatenation(s)
	}
}

func (s *Module_path_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_path_concatenation(s)
	}
}

func (p *VerilogParser) Module_path_concatenation() (localctx IModule_path_concatenationContext) {
	localctx = NewModule_path_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, VerilogParserRULE_module_path_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3333)
		p.Match(VerilogParserT__18)
	}
	{
		p.SetState(3334)
		p.Module_path_expression()
	}
	p.SetState(3339)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(3335)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3336)
			p.Module_path_expression()
		}

		p.SetState(3341)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3342)
		p.Match(VerilogParserT__19)
	}

	return localctx
}

// IModule_path_multiple_concatenationContext is an interface to support dynamic dispatch.
type IModule_path_multiple_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_multiple_concatenationContext differentiates from other interfaces.
	IsModule_path_multiple_concatenationContext()
}

type Module_path_multiple_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_multiple_concatenationContext() *Module_path_multiple_concatenationContext {
	var p = new(Module_path_multiple_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_multiple_concatenation
	return p
}

func (*Module_path_multiple_concatenationContext) IsModule_path_multiple_concatenationContext() {}

func NewModule_path_multiple_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_multiple_concatenationContext {
	var p = new(Module_path_multiple_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_multiple_concatenation

	return p
}

func (s *Module_path_multiple_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_multiple_concatenationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Module_path_multiple_concatenationContext) Module_path_concatenation() IModule_path_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_concatenationContext)
}

func (s *Module_path_multiple_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_multiple_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_multiple_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_path_multiple_concatenation(s)
	}
}

func (s *Module_path_multiple_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_path_multiple_concatenation(s)
	}
}

func (p *VerilogParser) Module_path_multiple_concatenation() (localctx IModule_path_multiple_concatenationContext) {
	localctx = NewModule_path_multiple_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, VerilogParserRULE_module_path_multiple_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3344)
		p.Match(VerilogParserT__18)
	}
	{
		p.SetState(3345)
		p.Constant_expression()
	}
	{
		p.SetState(3346)
		p.Module_path_concatenation()
	}
	{
		p.SetState(3347)
		p.Match(VerilogParserT__19)
	}

	return localctx
}

// IMultiple_concatenationContext is an interface to support dynamic dispatch.
type IMultiple_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiple_concatenationContext differentiates from other interfaces.
	IsMultiple_concatenationContext()
}

type Multiple_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiple_concatenationContext() *Multiple_concatenationContext {
	var p = new(Multiple_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_multiple_concatenation
	return p
}

func (*Multiple_concatenationContext) IsMultiple_concatenationContext() {}

func NewMultiple_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiple_concatenationContext {
	var p = new(Multiple_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_multiple_concatenation

	return p
}

func (s *Multiple_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiple_concatenationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Multiple_concatenationContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Multiple_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiple_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multiple_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterMultiple_concatenation(s)
	}
}

func (s *Multiple_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitMultiple_concatenation(s)
	}
}

func (p *VerilogParser) Multiple_concatenation() (localctx IMultiple_concatenationContext) {
	localctx = NewMultiple_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, VerilogParserRULE_multiple_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3349)
		p.Match(VerilogParserT__18)
	}
	{
		p.SetState(3350)
		p.Constant_expression()
	}
	{
		p.SetState(3351)
		p.Concatenation()
	}
	{
		p.SetState(3352)
		p.Match(VerilogParserT__19)
	}

	return localctx
}

// INet_concatenationContext is an interface to support dynamic dispatch.
type INet_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_concatenationContext differentiates from other interfaces.
	IsNet_concatenationContext()
}

type Net_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_concatenationContext() *Net_concatenationContext {
	var p = new(Net_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_concatenation
	return p
}

func (*Net_concatenationContext) IsNet_concatenationContext() {}

func NewNet_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_concatenationContext {
	var p = new(Net_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_concatenation

	return p
}

func (s *Net_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_concatenationContext) AllNet_concatenation_value() []INet_concatenation_valueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_concatenation_valueContext)(nil)).Elem())
	var tst = make([]INet_concatenation_valueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_concatenation_valueContext)
		}
	}

	return tst
}

func (s *Net_concatenationContext) Net_concatenation_value(i int) INet_concatenation_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_concatenation_valueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_concatenation_valueContext)
}

func (s *Net_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNet_concatenation(s)
	}
}

func (s *Net_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNet_concatenation(s)
	}
}

func (p *VerilogParser) Net_concatenation() (localctx INet_concatenationContext) {
	localctx = NewNet_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, VerilogParserRULE_net_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3354)
		p.Match(VerilogParserT__18)
	}
	{
		p.SetState(3355)
		p.Net_concatenation_value()
	}
	p.SetState(3360)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(3356)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3357)
			p.Net_concatenation_value()
		}

		p.SetState(3362)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3363)
		p.Match(VerilogParserT__19)
	}

	return localctx
}

// INet_concatenation_valueContext is an interface to support dynamic dispatch.
type INet_concatenation_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_concatenation_valueContext differentiates from other interfaces.
	IsNet_concatenation_valueContext()
}

type Net_concatenation_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_concatenation_valueContext() *Net_concatenation_valueContext {
	var p = new(Net_concatenation_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_concatenation_value
	return p
}

func (*Net_concatenation_valueContext) IsNet_concatenation_valueContext() {}

func NewNet_concatenation_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_concatenation_valueContext {
	var p = new(Net_concatenation_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_concatenation_value

	return p
}

func (s *Net_concatenation_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_concatenation_valueContext) Hierarchical_net_identifier() IHierarchical_net_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_net_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_net_identifierContext)
}

func (s *Net_concatenation_valueContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Net_concatenation_valueContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Net_concatenation_valueContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Net_concatenation_valueContext) Net_concatenation() INet_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_concatenationContext)
}

func (s *Net_concatenation_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_concatenation_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_concatenation_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNet_concatenation_value(s)
	}
}

func (s *Net_concatenation_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNet_concatenation_value(s)
	}
}

func (p *VerilogParser) Net_concatenation_value() (localctx INet_concatenation_valueContext) {
	localctx = NewNet_concatenation_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, VerilogParserRULE_net_concatenation_value)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3402)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 360, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3365)
			p.Hierarchical_net_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3366)
			p.Hierarchical_net_identifier()
		}
		{
			p.SetState(3367)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3368)
			p.Expression()
		}
		{
			p.SetState(3369)
			p.Match(VerilogParserT__21)
		}
		p.SetState(3376)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__20 {
			{
				p.SetState(3370)
				p.Match(VerilogParserT__20)
			}
			{
				p.SetState(3371)
				p.Expression()
			}
			{
				p.SetState(3372)
				p.Match(VerilogParserT__21)
			}

			p.SetState(3378)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3379)
			p.Hierarchical_net_identifier()
		}
		{
			p.SetState(3380)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3381)
			p.Expression()
		}
		{
			p.SetState(3382)
			p.Match(VerilogParserT__21)
		}
		p.SetState(3389)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 359, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3383)
					p.Match(VerilogParserT__20)
				}
				{
					p.SetState(3384)
					p.Expression()
				}
				{
					p.SetState(3385)
					p.Match(VerilogParserT__21)
				}

			}
			p.SetState(3391)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 359, p.GetParserRuleContext())
		}
		{
			p.SetState(3392)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3393)
			p.Range_expression()
		}
		{
			p.SetState(3394)
			p.Match(VerilogParserT__21)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3396)
			p.Hierarchical_net_identifier()
		}
		{
			p.SetState(3397)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3398)
			p.Range_expression()
		}
		{
			p.SetState(3399)
			p.Match(VerilogParserT__21)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3401)
			p.Net_concatenation()
		}

	}

	return localctx
}

// IVariable_concatenationContext is an interface to support dynamic dispatch.
type IVariable_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_concatenationContext differentiates from other interfaces.
	IsVariable_concatenationContext()
}

type Variable_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_concatenationContext() *Variable_concatenationContext {
	var p = new(Variable_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_concatenation
	return p
}

func (*Variable_concatenationContext) IsVariable_concatenationContext() {}

func NewVariable_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_concatenationContext {
	var p = new(Variable_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_concatenation

	return p
}

func (s *Variable_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_concatenationContext) AllVariable_concatenation_value() []IVariable_concatenation_valueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_concatenation_valueContext)(nil)).Elem())
	var tst = make([]IVariable_concatenation_valueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_concatenation_valueContext)
		}
	}

	return tst
}

func (s *Variable_concatenationContext) Variable_concatenation_value(i int) IVariable_concatenation_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_concatenation_valueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_concatenation_valueContext)
}

func (s *Variable_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterVariable_concatenation(s)
	}
}

func (s *Variable_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitVariable_concatenation(s)
	}
}

func (p *VerilogParser) Variable_concatenation() (localctx IVariable_concatenationContext) {
	localctx = NewVariable_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, VerilogParserRULE_variable_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3404)
		p.Match(VerilogParserT__18)
	}
	{
		p.SetState(3405)
		p.Variable_concatenation_value()
	}
	p.SetState(3410)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(3406)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3407)
			p.Variable_concatenation_value()
		}

		p.SetState(3412)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3413)
		p.Match(VerilogParserT__19)
	}

	return localctx
}

// IVariable_concatenation_valueContext is an interface to support dynamic dispatch.
type IVariable_concatenation_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_concatenation_valueContext differentiates from other interfaces.
	IsVariable_concatenation_valueContext()
}

type Variable_concatenation_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_concatenation_valueContext() *Variable_concatenation_valueContext {
	var p = new(Variable_concatenation_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_concatenation_value
	return p
}

func (*Variable_concatenation_valueContext) IsVariable_concatenation_valueContext() {}

func NewVariable_concatenation_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_concatenation_valueContext {
	var p = new(Variable_concatenation_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_concatenation_value

	return p
}

func (s *Variable_concatenation_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_concatenation_valueContext) Hierarchical_variable_identifier() IHierarchical_variable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_variable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_variable_identifierContext)
}

func (s *Variable_concatenation_valueContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Variable_concatenation_valueContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_concatenation_valueContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Variable_concatenation_valueContext) Variable_concatenation() IVariable_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_concatenationContext)
}

func (s *Variable_concatenation_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_concatenation_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_concatenation_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterVariable_concatenation_value(s)
	}
}

func (s *Variable_concatenation_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitVariable_concatenation_value(s)
	}
}

func (p *VerilogParser) Variable_concatenation_value() (localctx IVariable_concatenation_valueContext) {
	localctx = NewVariable_concatenation_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, VerilogParserRULE_variable_concatenation_value)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3452)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 364, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3415)
			p.Hierarchical_variable_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3416)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(3417)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3418)
			p.Expression()
		}
		{
			p.SetState(3419)
			p.Match(VerilogParserT__21)
		}
		p.SetState(3426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__20 {
			{
				p.SetState(3420)
				p.Match(VerilogParserT__20)
			}
			{
				p.SetState(3421)
				p.Expression()
			}
			{
				p.SetState(3422)
				p.Match(VerilogParserT__21)
			}

			p.SetState(3428)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3429)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(3430)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3431)
			p.Expression()
		}
		{
			p.SetState(3432)
			p.Match(VerilogParserT__21)
		}
		p.SetState(3439)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 363, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3433)
					p.Match(VerilogParserT__20)
				}
				{
					p.SetState(3434)
					p.Expression()
				}
				{
					p.SetState(3435)
					p.Match(VerilogParserT__21)
				}

			}
			p.SetState(3441)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 363, p.GetParserRuleContext())
		}
		{
			p.SetState(3442)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3443)
			p.Range_expression()
		}
		{
			p.SetState(3444)
			p.Match(VerilogParserT__21)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3446)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(3447)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3448)
			p.Range_expression()
		}
		{
			p.SetState(3449)
			p.Match(VerilogParserT__21)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3451)
			p.Variable_concatenation()
		}

	}

	return localctx
}

// IConstant_function_callContext is an interface to support dynamic dispatch.
type IConstant_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_function_callContext differentiates from other interfaces.
	IsConstant_function_callContext()
}

type Constant_function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_function_callContext() *Constant_function_callContext {
	var p = new(Constant_function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_function_call
	return p
}

func (*Constant_function_callContext) IsConstant_function_callContext() {}

func NewConstant_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_function_callContext {
	var p = new(Constant_function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_function_call

	return p
}

func (s *Constant_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_function_callContext) Function_identifier() IFunction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_identifierContext)
}

func (s *Constant_function_callContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Constant_function_callContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Constant_function_callContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_function_callContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterConstant_function_call(s)
	}
}

func (s *Constant_function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitConstant_function_call(s)
	}
}

func (p *VerilogParser) Constant_function_call() (localctx IConstant_function_callContext) {
	localctx = NewConstant_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, VerilogParserRULE_constant_function_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3454)
		p.Function_identifier()
	}
	p.SetState(3458)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 365, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3455)
				p.Attribute_instance()
			}

		}
		p.SetState(3460)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 365, p.GetParserRuleContext())
	}
	{
		p.SetState(3461)
		p.Match(VerilogParserT__15)
	}
	p.SetState(3470)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__15 || _la == VerilogParserT__18 || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
		{
			p.SetState(3462)
			p.Constant_expression()
		}
		p.SetState(3467)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(3463)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(3464)
				p.Constant_expression()
			}

			p.SetState(3469)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3472)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IFunction_callContext is an interface to support dynamic dispatch.
type IFunction_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_callContext differentiates from other interfaces.
	IsFunction_callContext()
}

type Function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_callContext() *Function_callContext {
	var p = new(Function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_call
	return p
}

func (*Function_callContext) IsFunction_callContext() {}

func NewFunction_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_callContext {
	var p = new(Function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_call

	return p
}

func (s *Function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_callContext) Hierarchical_function_identifier() IHierarchical_function_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_function_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_function_identifierContext)
}

func (s *Function_callContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Function_callContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Function_callContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Function_callContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_call(s)
	}
}

func (s *Function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_call(s)
	}
}

func (p *VerilogParser) Function_call() (localctx IFunction_callContext) {
	localctx = NewFunction_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, VerilogParserRULE_function_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3474)
		p.Hierarchical_function_identifier()
	}
	p.SetState(3478)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 368, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3475)
				p.Attribute_instance()
			}

		}
		p.SetState(3480)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 368, p.GetParserRuleContext())
	}
	{
		p.SetState(3481)
		p.Match(VerilogParserT__15)
	}
	p.SetState(3490)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__15 || _la == VerilogParserT__18 || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
		{
			p.SetState(3482)
			p.Expression()
		}
		p.SetState(3487)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(3483)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(3484)
				p.Expression()
			}

			p.SetState(3489)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3492)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// ISystem_function_callContext is an interface to support dynamic dispatch.
type ISystem_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_function_callContext differentiates from other interfaces.
	IsSystem_function_callContext()
}

type System_function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_function_callContext() *System_function_callContext {
	var p = new(System_function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_system_function_call
	return p
}

func (*System_function_callContext) IsSystem_function_callContext() {}

func NewSystem_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_function_callContext {
	var p = new(System_function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_system_function_call

	return p
}

func (s *System_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *System_function_callContext) System_function_identifier() ISystem_function_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_function_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_function_identifierContext)
}

func (s *System_function_callContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *System_function_callContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *System_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSystem_function_call(s)
	}
}

func (s *System_function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSystem_function_call(s)
	}
}

func (p *VerilogParser) System_function_call() (localctx ISystem_function_callContext) {
	localctx = NewSystem_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, VerilogParserRULE_system_function_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3494)
		p.System_function_identifier()
	}
	p.SetState(3503)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 372, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3495)
			p.Expression()
		}
		p.SetState(3500)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 371, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3496)
					p.Match(VerilogParserT__16)
				}
				{
					p.SetState(3497)
					p.Expression()
				}

			}
			p.SetState(3502)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 371, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IGenvar_function_callContext is an interface to support dynamic dispatch.
type IGenvar_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_function_callContext differentiates from other interfaces.
	IsGenvar_function_callContext()
}

type Genvar_function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_function_callContext() *Genvar_function_callContext {
	var p = new(Genvar_function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_function_call
	return p
}

func (*Genvar_function_callContext) IsGenvar_function_callContext() {}

func NewGenvar_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_function_callContext {
	var p = new(Genvar_function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_function_call

	return p
}

func (s *Genvar_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_function_callContext) Genvar_function_identifier() IGenvar_function_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_function_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_function_identifierContext)
}

func (s *Genvar_function_callContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Genvar_function_callContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Genvar_function_callContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Genvar_function_callContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Genvar_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenvar_function_call(s)
	}
}

func (s *Genvar_function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenvar_function_call(s)
	}
}

func (p *VerilogParser) Genvar_function_call() (localctx IGenvar_function_callContext) {
	localctx = NewGenvar_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, VerilogParserRULE_genvar_function_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3505)
		p.Genvar_function_identifier()
	}
	p.SetState(3509)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 373, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3506)
				p.Attribute_instance()
			}

		}
		p.SetState(3511)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 373, p.GetParserRuleContext())
	}
	{
		p.SetState(3512)
		p.Match(VerilogParserT__15)
	}
	p.SetState(3521)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__15 || _la == VerilogParserT__18 || (((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) || (((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168))|(1<<(VerilogParserStrings-168))|(1<<(VerilogParserEscaped_identifier-168))|(1<<(VerilogParserSimple_identifier-168))|(1<<(VerilogParserDollar_Identifier-168)))) != 0) {
		{
			p.SetState(3513)
			p.Constant_expression()
		}
		p.SetState(3518)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__16 {
			{
				p.SetState(3514)
				p.Match(VerilogParserT__16)
			}
			{
				p.SetState(3515)
				p.Constant_expression()
			}

			p.SetState(3520)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3523)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IBase_expressionContext is an interface to support dynamic dispatch.
type IBase_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_expressionContext differentiates from other interfaces.
	IsBase_expressionContext()
}

type Base_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_expressionContext() *Base_expressionContext {
	var p = new(Base_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_base_expression
	return p
}

func (*Base_expressionContext) IsBase_expressionContext() {}

func NewBase_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_expressionContext {
	var p = new(Base_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_base_expression

	return p
}

func (s *Base_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Base_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterBase_expression(s)
	}
}

func (s *Base_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitBase_expression(s)
	}
}

func (p *VerilogParser) Base_expression() (localctx IBase_expressionContext) {
	localctx = NewBase_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, VerilogParserRULE_base_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3525)
		p.Expression()
	}

	return localctx
}

// IConstant_base_expressionContext is an interface to support dynamic dispatch.
type IConstant_base_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_base_expressionContext differentiates from other interfaces.
	IsConstant_base_expressionContext()
}

type Constant_base_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_base_expressionContext() *Constant_base_expressionContext {
	var p = new(Constant_base_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_base_expression
	return p
}

func (*Constant_base_expressionContext) IsConstant_base_expressionContext() {}

func NewConstant_base_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_base_expressionContext {
	var p = new(Constant_base_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_base_expression

	return p
}

func (s *Constant_base_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_base_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_base_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_base_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_base_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterConstant_base_expression(s)
	}
}

func (s *Constant_base_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitConstant_base_expression(s)
	}
}

func (p *VerilogParser) Constant_base_expression() (localctx IConstant_base_expressionContext) {
	localctx = NewConstant_base_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, VerilogParserRULE_constant_base_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3527)
		p.Constant_expression()
	}

	return localctx
}

// IConstant_expressionContext is an interface to support dynamic dispatch.
type IConstant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_expressionContext differentiates from other interfaces.
	IsConstant_expressionContext()
}

type Constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_expressionContext() *Constant_expressionContext {
	var p = new(Constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_expression
	return p
}

func (*Constant_expressionContext) IsConstant_expressionContext() {}

func NewConstant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_expressionContext {
	var p = new(Constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_expression

	return p
}

func (s *Constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterConstant_expression(s)
	}
}

func (s *Constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitConstant_expression(s)
	}
}

func (p *VerilogParser) Constant_expression() (localctx IConstant_expressionContext) {
	localctx = NewConstant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, VerilogParserRULE_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3529)
		p.Expression()
	}

	return localctx
}

// IConstant_mintypmax_expressionContext is an interface to support dynamic dispatch.
type IConstant_mintypmax_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_mintypmax_expressionContext differentiates from other interfaces.
	IsConstant_mintypmax_expressionContext()
}

type Constant_mintypmax_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_mintypmax_expressionContext() *Constant_mintypmax_expressionContext {
	var p = new(Constant_mintypmax_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_mintypmax_expression
	return p
}

func (*Constant_mintypmax_expressionContext) IsConstant_mintypmax_expressionContext() {}

func NewConstant_mintypmax_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_mintypmax_expressionContext {
	var p = new(Constant_mintypmax_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_mintypmax_expression

	return p
}

func (s *Constant_mintypmax_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_mintypmax_expressionContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_mintypmax_expressionContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_mintypmax_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_mintypmax_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_mintypmax_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterConstant_mintypmax_expression(s)
	}
}

func (s *Constant_mintypmax_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitConstant_mintypmax_expression(s)
	}
}

func (p *VerilogParser) Constant_mintypmax_expression() (localctx IConstant_mintypmax_expressionContext) {
	localctx = NewConstant_mintypmax_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, VerilogParserRULE_constant_mintypmax_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3538)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 376, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3531)
			p.Constant_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3532)
			p.Constant_expression()
		}
		{
			p.SetState(3533)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(3534)
			p.Constant_expression()
		}
		{
			p.SetState(3535)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(3536)
			p.Constant_expression()
		}

	}

	return localctx
}

// IConstant_range_expressionContext is an interface to support dynamic dispatch.
type IConstant_range_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_range_expressionContext differentiates from other interfaces.
	IsConstant_range_expressionContext()
}

type Constant_range_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_range_expressionContext() *Constant_range_expressionContext {
	var p = new(Constant_range_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_range_expression
	return p
}

func (*Constant_range_expressionContext) IsConstant_range_expressionContext() {}

func NewConstant_range_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_range_expressionContext {
	var p = new(Constant_range_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_range_expression

	return p
}

func (s *Constant_range_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_range_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_range_expressionContext) Msb_constant_expression() IMsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMsb_constant_expressionContext)
}

func (s *Constant_range_expressionContext) Lsb_constant_expression() ILsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILsb_constant_expressionContext)
}

func (s *Constant_range_expressionContext) Constant_base_expression() IConstant_base_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_base_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_base_expressionContext)
}

func (s *Constant_range_expressionContext) Width_constant_expression() IWidth_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWidth_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWidth_constant_expressionContext)
}

func (s *Constant_range_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_range_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_range_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterConstant_range_expression(s)
	}
}

func (s *Constant_range_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitConstant_range_expression(s)
	}
}

func (p *VerilogParser) Constant_range_expression() (localctx IConstant_range_expressionContext) {
	localctx = NewConstant_range_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, VerilogParserRULE_constant_range_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3553)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 377, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3540)
			p.Constant_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3541)
			p.Msb_constant_expression()
		}
		{
			p.SetState(3542)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(3543)
			p.Lsb_constant_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3545)
			p.Constant_base_expression()
		}
		{
			p.SetState(3546)
			p.Match(VerilogParserT__137)
		}
		{
			p.SetState(3547)
			p.Width_constant_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3549)
			p.Constant_base_expression()
		}
		{
			p.SetState(3550)
			p.Match(VerilogParserT__138)
		}
		{
			p.SetState(3551)
			p.Width_constant_expression()
		}

	}

	return localctx
}

// IDimension_constant_expressionContext is an interface to support dynamic dispatch.
type IDimension_constant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimension_constant_expressionContext differentiates from other interfaces.
	IsDimension_constant_expressionContext()
}

type Dimension_constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimension_constant_expressionContext() *Dimension_constant_expressionContext {
	var p = new(Dimension_constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dimension_constant_expression
	return p
}

func (*Dimension_constant_expressionContext) IsDimension_constant_expressionContext() {}

func NewDimension_constant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dimension_constant_expressionContext {
	var p = new(Dimension_constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dimension_constant_expression

	return p
}

func (s *Dimension_constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Dimension_constant_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Dimension_constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dimension_constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dimension_constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDimension_constant_expression(s)
	}
}

func (s *Dimension_constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDimension_constant_expression(s)
	}
}

func (p *VerilogParser) Dimension_constant_expression() (localctx IDimension_constant_expressionContext) {
	localctx = NewDimension_constant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, VerilogParserRULE_dimension_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3555)
		p.Constant_expression()
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *ExpressionContext) AllBinary_operator() []IBinary_operatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinary_operatorContext)(nil)).Elem())
	var tst = make([]IBinary_operatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinary_operatorContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Binary_operator(i int) IBinary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_operatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinary_operatorContext)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *VerilogParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, VerilogParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3557)
		p.Term()
	}
	p.SetState(3580)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 381, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3578)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case VerilogParserT__108, VerilogParserT__117, VerilogParserT__135, VerilogParserT__136, VerilogParserT__142, VerilogParserT__144, VerilogParserT__146, VerilogParserT__147, VerilogParserT__148, VerilogParserT__149, VerilogParserT__150, VerilogParserT__151, VerilogParserT__152, VerilogParserT__153, VerilogParserT__154, VerilogParserT__155, VerilogParserT__156, VerilogParserT__157, VerilogParserT__158, VerilogParserT__159, VerilogParserT__160, VerilogParserT__161, VerilogParserT__162, VerilogParserT__163, VerilogParserT__164:
				{
					p.SetState(3558)
					p.Binary_operator()
				}
				p.SetState(3562)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3559)
							p.Attribute_instance()
						}

					}
					p.SetState(3564)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext())
				}
				{
					p.SetState(3565)
					p.Term()
				}

			case VerilogParserT__139:
				{
					p.SetState(3567)
					p.Match(VerilogParserT__139)
				}
				p.SetState(3571)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 379, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3568)
							p.Attribute_instance()
						}

					}
					p.SetState(3573)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 379, p.GetParserRuleContext())
				}
				{
					p.SetState(3574)
					p.Expression()
				}
				{
					p.SetState(3575)
					p.Match(VerilogParserT__64)
				}
				{
					p.SetState(3576)
					p.Term()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(3582)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 381, p.GetParserRuleContext())
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSystem returns the system attribute.
	GetSystem() int

	// SetSystem sets the system attribute.
	SetSystem(int)

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	system int
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) GetSystem() int { return s.system }

func (s *TermContext) SetSystem(v int) { s.system = v }

func (s *TermContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *TermContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *TermContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *TermContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *TermContext) Strings() antlr.TerminalNode {
	return s.GetToken(VerilogParserStrings, 0)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (p *VerilogParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, VerilogParserRULE_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3597)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__135, VerilogParserT__136, VerilogParserT__140, VerilogParserT__141, VerilogParserT__142, VerilogParserT__143, VerilogParserT__144, VerilogParserT__145, VerilogParserT__146, VerilogParserT__147, VerilogParserT__148:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3583)
			p.Unary_operator()
		}
		p.SetState(3587)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 382, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3584)
					p.Attribute_instance()
				}

			}
			p.SetState(3589)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 382, p.GetParserRuleContext())
		}
		{
			p.SetState(3590)
			p.Primary()
		}
		localctx.(*TermContext).SetSystem(1)

	case VerilogParserT__15, VerilogParserT__18, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserEscaped_identifier, VerilogParserSimple_identifier, VerilogParserDollar_Identifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3593)
			p.Primary()
		}
		localctx.(*TermContext).SetSystem(2)

	case VerilogParserStrings:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3596)
			p.Match(VerilogParserStrings)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILsb_constant_expressionContext is an interface to support dynamic dispatch.
type ILsb_constant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLsb_constant_expressionContext differentiates from other interfaces.
	IsLsb_constant_expressionContext()
}

type Lsb_constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLsb_constant_expressionContext() *Lsb_constant_expressionContext {
	var p = new(Lsb_constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_lsb_constant_expression
	return p
}

func (*Lsb_constant_expressionContext) IsLsb_constant_expressionContext() {}

func NewLsb_constant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lsb_constant_expressionContext {
	var p = new(Lsb_constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_lsb_constant_expression

	return p
}

func (s *Lsb_constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Lsb_constant_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Lsb_constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lsb_constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lsb_constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterLsb_constant_expression(s)
	}
}

func (s *Lsb_constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitLsb_constant_expression(s)
	}
}

func (p *VerilogParser) Lsb_constant_expression() (localctx ILsb_constant_expressionContext) {
	localctx = NewLsb_constant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, VerilogParserRULE_lsb_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3599)
		p.Constant_expression()
	}

	return localctx
}

// IMintypmax_expressionContext is an interface to support dynamic dispatch.
type IMintypmax_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMintypmax_expressionContext differentiates from other interfaces.
	IsMintypmax_expressionContext()
}

type Mintypmax_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMintypmax_expressionContext() *Mintypmax_expressionContext {
	var p = new(Mintypmax_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_mintypmax_expression
	return p
}

func (*Mintypmax_expressionContext) IsMintypmax_expressionContext() {}

func NewMintypmax_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mintypmax_expressionContext {
	var p = new(Mintypmax_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_mintypmax_expression

	return p
}

func (s *Mintypmax_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Mintypmax_expressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Mintypmax_expressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Mintypmax_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mintypmax_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mintypmax_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterMintypmax_expression(s)
	}
}

func (s *Mintypmax_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitMintypmax_expression(s)
	}
}

func (p *VerilogParser) Mintypmax_expression() (localctx IMintypmax_expressionContext) {
	localctx = NewMintypmax_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, VerilogParserRULE_mintypmax_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3601)
		p.Expression()
	}
	p.SetState(3607)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__64 {
		{
			p.SetState(3602)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(3603)
			p.Expression()
		}
		{
			p.SetState(3604)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(3605)
			p.Expression()
		}

	}

	return localctx
}

// IModule_path_conditional_expressionContext is an interface to support dynamic dispatch.
type IModule_path_conditional_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_conditional_expressionContext differentiates from other interfaces.
	IsModule_path_conditional_expressionContext()
}

type Module_path_conditional_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_conditional_expressionContext() *Module_path_conditional_expressionContext {
	var p = new(Module_path_conditional_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_conditional_expression
	return p
}

func (*Module_path_conditional_expressionContext) IsModule_path_conditional_expressionContext() {}

func NewModule_path_conditional_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_conditional_expressionContext {
	var p = new(Module_path_conditional_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_conditional_expression

	return p
}

func (s *Module_path_conditional_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_conditional_expressionContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_conditional_expressionContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_conditional_expressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_path_conditional_expressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_path_conditional_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_conditional_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_conditional_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_path_conditional_expression(s)
	}
}

func (s *Module_path_conditional_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_path_conditional_expression(s)
	}
}

func (p *VerilogParser) Module_path_conditional_expression() (localctx IModule_path_conditional_expressionContext) {
	localctx = NewModule_path_conditional_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, VerilogParserRULE_module_path_conditional_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3609)
		p.Module_path_expression()
	}
	{
		p.SetState(3610)
		p.Match(VerilogParserT__139)
	}
	p.SetState(3614)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 385, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3611)
				p.Attribute_instance()
			}

		}
		p.SetState(3616)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 385, p.GetParserRuleContext())
	}
	{
		p.SetState(3617)
		p.Module_path_expression()
	}
	{
		p.SetState(3618)
		p.Match(VerilogParserT__64)
	}
	{
		p.SetState(3619)
		p.Module_path_expression()
	}

	return localctx
}

// IModule_path_expressionContext is an interface to support dynamic dispatch.
type IModule_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_expressionContext differentiates from other interfaces.
	IsModule_path_expressionContext()
}

type Module_path_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_expressionContext() *Module_path_expressionContext {
	var p = new(Module_path_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_expression
	return p
}

func (*Module_path_expressionContext) IsModule_path_expressionContext() {}

func NewModule_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_expressionContext {
	var p = new(Module_path_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_expression

	return p
}

func (s *Module_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_expressionContext) Module_path_primary() IModule_path_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_primaryContext)
}

func (s *Module_path_expressionContext) Unary_module_path_operator() IUnary_module_path_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_module_path_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_module_path_operatorContext)
}

func (s *Module_path_expressionContext) AllBinary_module_path_operator() []IBinary_module_path_operatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinary_module_path_operatorContext)(nil)).Elem())
	var tst = make([]IBinary_module_path_operatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinary_module_path_operatorContext)
		}
	}

	return tst
}

func (s *Module_path_expressionContext) Binary_module_path_operator(i int) IBinary_module_path_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_module_path_operatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinary_module_path_operatorContext)
}

func (s *Module_path_expressionContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_expressionContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_expressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_path_expressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_path_expression(s)
	}
}

func (s *Module_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_path_expression(s)
	}
}

func (p *VerilogParser) Module_path_expression() (localctx IModule_path_expressionContext) {
	localctx = NewModule_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, VerilogParserRULE_module_path_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3631)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserT__15, VerilogParserT__18, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserEscaped_identifier, VerilogParserSimple_identifier, VerilogParserDollar_Identifier:
		{
			p.SetState(3621)
			p.Module_path_primary()
		}

	case VerilogParserT__140, VerilogParserT__141, VerilogParserT__142, VerilogParserT__143, VerilogParserT__144, VerilogParserT__145, VerilogParserT__146, VerilogParserT__147, VerilogParserT__148:
		{
			p.SetState(3622)
			p.Unary_module_path_operator()
		}
		p.SetState(3626)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 386, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3623)
					p.Attribute_instance()
				}

			}
			p.SetState(3628)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 386, p.GetParserRuleContext())
		}
		{
			p.SetState(3629)
			p.Module_path_primary()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3655)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 391, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3653)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case VerilogParserT__142, VerilogParserT__144, VerilogParserT__146, VerilogParserT__147, VerilogParserT__148, VerilogParserT__151, VerilogParserT__152, VerilogParserT__155, VerilogParserT__156:
				{
					p.SetState(3633)
					p.Binary_module_path_operator()
				}
				p.SetState(3637)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 388, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3634)
							p.Attribute_instance()
						}

					}
					p.SetState(3639)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 388, p.GetParserRuleContext())
				}
				{
					p.SetState(3640)
					p.Module_path_expression()
				}

			case VerilogParserT__139:
				{
					p.SetState(3642)
					p.Match(VerilogParserT__139)
				}
				p.SetState(3646)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 389, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3643)
							p.Attribute_instance()
						}

					}
					p.SetState(3648)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 389, p.GetParserRuleContext())
				}
				{
					p.SetState(3649)
					p.Module_path_expression()
				}
				{
					p.SetState(3650)
					p.Match(VerilogParserT__64)
				}
				{
					p.SetState(3651)
					p.Module_path_expression()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(3657)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 391, p.GetParserRuleContext())
	}

	return localctx
}

// IModule_path_mintypmax_expressionContext is an interface to support dynamic dispatch.
type IModule_path_mintypmax_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_mintypmax_expressionContext differentiates from other interfaces.
	IsModule_path_mintypmax_expressionContext()
}

type Module_path_mintypmax_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_mintypmax_expressionContext() *Module_path_mintypmax_expressionContext {
	var p = new(Module_path_mintypmax_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_mintypmax_expression
	return p
}

func (*Module_path_mintypmax_expressionContext) IsModule_path_mintypmax_expressionContext() {}

func NewModule_path_mintypmax_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_mintypmax_expressionContext {
	var p = new(Module_path_mintypmax_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_mintypmax_expression

	return p
}

func (s *Module_path_mintypmax_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_mintypmax_expressionContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_mintypmax_expressionContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_mintypmax_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_mintypmax_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_mintypmax_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_path_mintypmax_expression(s)
	}
}

func (s *Module_path_mintypmax_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_path_mintypmax_expression(s)
	}
}

func (p *VerilogParser) Module_path_mintypmax_expression() (localctx IModule_path_mintypmax_expressionContext) {
	localctx = NewModule_path_mintypmax_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, VerilogParserRULE_module_path_mintypmax_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3658)
		p.Module_path_expression()
	}
	p.SetState(3664)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__64 {
		{
			p.SetState(3659)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(3660)
			p.Module_path_expression()
		}
		{
			p.SetState(3661)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(3662)
			p.Module_path_expression()
		}

	}

	return localctx
}

// IMsb_constant_expressionContext is an interface to support dynamic dispatch.
type IMsb_constant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMsb_constant_expressionContext differentiates from other interfaces.
	IsMsb_constant_expressionContext()
}

type Msb_constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMsb_constant_expressionContext() *Msb_constant_expressionContext {
	var p = new(Msb_constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_msb_constant_expression
	return p
}

func (*Msb_constant_expressionContext) IsMsb_constant_expressionContext() {}

func NewMsb_constant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Msb_constant_expressionContext {
	var p = new(Msb_constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_msb_constant_expression

	return p
}

func (s *Msb_constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Msb_constant_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Msb_constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Msb_constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Msb_constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterMsb_constant_expression(s)
	}
}

func (s *Msb_constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitMsb_constant_expression(s)
	}
}

func (p *VerilogParser) Msb_constant_expression() (localctx IMsb_constant_expressionContext) {
	localctx = NewMsb_constant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, VerilogParserRULE_msb_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3666)
		p.Constant_expression()
	}

	return localctx
}

// IRange_expressionContext is an interface to support dynamic dispatch.
type IRange_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_expressionContext differentiates from other interfaces.
	IsRange_expressionContext()
}

type Range_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_expressionContext() *Range_expressionContext {
	var p = new(Range_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_range_expression
	return p
}

func (*Range_expressionContext) IsRange_expressionContext() {}

func NewRange_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_expressionContext {
	var p = new(Range_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_range_expression

	return p
}

func (s *Range_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Range_expressionContext) Msb_constant_expression() IMsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMsb_constant_expressionContext)
}

func (s *Range_expressionContext) Lsb_constant_expression() ILsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILsb_constant_expressionContext)
}

func (s *Range_expressionContext) Base_expression() IBase_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_expressionContext)
}

func (s *Range_expressionContext) Width_constant_expression() IWidth_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWidth_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWidth_constant_expressionContext)
}

func (s *Range_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterRange_expression(s)
	}
}

func (s *Range_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitRange_expression(s)
	}
}

func (p *VerilogParser) Range_expression() (localctx IRange_expressionContext) {
	localctx = NewRange_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, VerilogParserRULE_range_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3681)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 393, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3668)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3669)
			p.Msb_constant_expression()
		}
		{
			p.SetState(3670)
			p.Match(VerilogParserT__64)
		}
		{
			p.SetState(3671)
			p.Lsb_constant_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3673)
			p.Base_expression()
		}
		{
			p.SetState(3674)
			p.Match(VerilogParserT__137)
		}
		{
			p.SetState(3675)
			p.Width_constant_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3677)
			p.Base_expression()
		}
		{
			p.SetState(3678)
			p.Match(VerilogParserT__138)
		}
		{
			p.SetState(3679)
			p.Width_constant_expression()
		}

	}

	return localctx
}

// IWidth_constant_expressionContext is an interface to support dynamic dispatch.
type IWidth_constant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWidth_constant_expressionContext differentiates from other interfaces.
	IsWidth_constant_expressionContext()
}

type Width_constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWidth_constant_expressionContext() *Width_constant_expressionContext {
	var p = new(Width_constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_width_constant_expression
	return p
}

func (*Width_constant_expressionContext) IsWidth_constant_expressionContext() {}

func NewWidth_constant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Width_constant_expressionContext {
	var p = new(Width_constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_width_constant_expression

	return p
}

func (s *Width_constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Width_constant_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Width_constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Width_constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Width_constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterWidth_constant_expression(s)
	}
}

func (s *Width_constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitWidth_constant_expression(s)
	}
}

func (p *VerilogParser) Width_constant_expression() (localctx IWidth_constant_expressionContext) {
	localctx = NewWidth_constant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, VerilogParserRULE_width_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3683)
		p.Constant_expression()
	}

	return localctx
}

// IConstant_primaryContext is an interface to support dynamic dispatch.
type IConstant_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_primaryContext differentiates from other interfaces.
	IsConstant_primaryContext()
}

type Constant_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_primaryContext() *Constant_primaryContext {
	var p = new(Constant_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_primary
	return p
}

func (*Constant_primaryContext) IsConstant_primaryContext() {}

func NewConstant_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_primaryContext {
	var p = new(Constant_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_primary

	return p
}

func (s *Constant_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_primaryContext) Constant_concatenation() IConstant_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_concatenationContext)
}

func (s *Constant_primaryContext) Constant_function_call() IConstant_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_function_callContext)
}

func (s *Constant_primaryContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Constant_primaryContext) Constant_multiple_concatenation() IConstant_multiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_multiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_multiple_concatenationContext)
}

func (s *Constant_primaryContext) Genvar_identifier() IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *Constant_primaryContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Constant_primaryContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Constant_primaryContext) Specparam_identifier() ISpecparam_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_identifierContext)
}

func (s *Constant_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterConstant_primary(s)
	}
}

func (s *Constant_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitConstant_primary(s)
	}
}

func (p *VerilogParser) Constant_primary() (localctx IConstant_primaryContext) {
	localctx = NewConstant_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, VerilogParserRULE_constant_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3696)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 394, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3685)
			p.Constant_concatenation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3686)
			p.Constant_function_call()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3687)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(3688)
			p.Constant_mintypmax_expression()
		}
		{
			p.SetState(3689)
			p.Match(VerilogParserT__17)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3691)
			p.Constant_multiple_concatenation()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3692)
			p.Genvar_identifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3693)
			p.Number()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3694)
			p.Parameter_identifier()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3695)
			p.Specparam_identifier()
		}

	}

	return localctx
}

// IModule_path_primaryContext is an interface to support dynamic dispatch.
type IModule_path_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_primaryContext differentiates from other interfaces.
	IsModule_path_primaryContext()
}

type Module_path_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_primaryContext() *Module_path_primaryContext {
	var p = new(Module_path_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_primary
	return p
}

func (*Module_path_primaryContext) IsModule_path_primaryContext() {}

func NewModule_path_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_primaryContext {
	var p = new(Module_path_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_primary

	return p
}

func (s *Module_path_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_primaryContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Module_path_primaryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Module_path_primaryContext) Module_path_concatenation() IModule_path_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_concatenationContext)
}

func (s *Module_path_primaryContext) Module_path_multiple_concatenation() IModule_path_multiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_multiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_multiple_concatenationContext)
}

func (s *Module_path_primaryContext) Function_call() IFunction_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *Module_path_primaryContext) System_function_call() ISystem_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_function_callContext)
}

func (s *Module_path_primaryContext) Constant_function_call() IConstant_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_function_callContext)
}

func (s *Module_path_primaryContext) Module_path_mintypmax_expression() IModule_path_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_mintypmax_expressionContext)
}

func (s *Module_path_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_path_primary(s)
	}
}

func (s *Module_path_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_path_primary(s)
	}
}

func (p *VerilogParser) Module_path_primary() (localctx IModule_path_primaryContext) {
	localctx = NewModule_path_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, VerilogParserRULE_module_path_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3709)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 395, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3698)
			p.Number()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3699)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3700)
			p.Module_path_concatenation()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3701)
			p.Module_path_multiple_concatenation()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3702)
			p.Function_call()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3703)
			p.System_function_call()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3704)
			p.Constant_function_call()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3705)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(3706)
			p.Module_path_mintypmax_expression()
		}
		{
			p.SetState(3707)
			p.Match(VerilogParserT__17)
		}

	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSystem returns the system attribute.
	GetSystem() int

	// SetSystem sets the system attribute.
	SetSystem(int)

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	system int
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) GetSystem() int { return s.system }

func (s *PrimaryContext) SetSystem(v int) { s.system = v }

func (s *PrimaryContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *PrimaryContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *PrimaryContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *PrimaryContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *PrimaryContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *PrimaryContext) Multiple_concatenation() IMultiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiple_concatenationContext)
}

func (s *PrimaryContext) Function_call() IFunction_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *PrimaryContext) System_function_call() ISystem_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_function_callContext)
}

func (s *PrimaryContext) Constant_function_call() IConstant_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_function_callContext)
}

func (s *PrimaryContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (p *VerilogParser) Primary() (localctx IPrimaryContext) {
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, VerilogParserRULE_primary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3768)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 398, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3711)
			p.Number()
		}
		localctx.(*PrimaryContext).SetSystem(1)

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3714)
			p.Hierarchical_identifier()
		}
		localctx.(*PrimaryContext).SetSystem(2)

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3717)
			p.Hierarchical_identifier()
		}
		p.SetState(3722)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == VerilogParserT__20 {
			{
				p.SetState(3718)
				p.Match(VerilogParserT__20)
			}
			{
				p.SetState(3719)
				p.Expression()
			}
			{
				p.SetState(3720)
				p.Match(VerilogParserT__21)
			}

			p.SetState(3724)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		localctx.(*PrimaryContext).SetSystem(3)

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3728)
			p.Hierarchical_identifier()
		}
		p.SetState(3733)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3729)
					p.Match(VerilogParserT__20)
				}
				{
					p.SetState(3730)
					p.Expression()
				}
				{
					p.SetState(3731)
					p.Match(VerilogParserT__21)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(3735)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 397, p.GetParserRuleContext())
		}
		{
			p.SetState(3737)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3738)
			p.Range_expression()
		}
		{
			p.SetState(3739)
			p.Match(VerilogParserT__21)
		}
		localctx.(*PrimaryContext).SetSystem(4)

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3742)
			p.Hierarchical_identifier()
		}
		{
			p.SetState(3743)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3744)
			p.Range_expression()
		}
		{
			p.SetState(3745)
			p.Match(VerilogParserT__21)
		}
		localctx.(*PrimaryContext).SetSystem(5)

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3748)
			p.Concatenation()
		}
		localctx.(*PrimaryContext).SetSystem(6)

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3751)
			p.Multiple_concatenation()
		}
		localctx.(*PrimaryContext).SetSystem(7)

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3754)
			p.Function_call()
		}
		localctx.(*PrimaryContext).SetSystem(8)

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3757)
			p.System_function_call()
		}
		localctx.(*PrimaryContext).SetSystem(9)

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3760)
			p.Constant_function_call()
		}
		localctx.(*PrimaryContext).SetSystem(10)

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3763)
			p.Match(VerilogParserT__15)
		}
		{
			p.SetState(3764)
			p.Mintypmax_expression()
		}
		{
			p.SetState(3765)
			p.Match(VerilogParserT__17)
		}
		localctx.(*PrimaryContext).SetSystem(11)

	}

	return localctx
}

// INet_lvalueContext is an interface to support dynamic dispatch.
type INet_lvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_lvalueContext differentiates from other interfaces.
	IsNet_lvalueContext()
}

type Net_lvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_lvalueContext() *Net_lvalueContext {
	var p = new(Net_lvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_lvalue
	return p
}

func (*Net_lvalueContext) IsNet_lvalueContext() {}

func NewNet_lvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_lvalueContext {
	var p = new(Net_lvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_lvalue

	return p
}

func (s *Net_lvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_lvalueContext) Hierarchical_net_identifier() IHierarchical_net_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_net_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_net_identifierContext)
}

func (s *Net_lvalueContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Net_lvalueContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Net_lvalueContext) Constant_range_expression() IConstant_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_range_expressionContext)
}

func (s *Net_lvalueContext) Net_concatenation() INet_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_concatenationContext)
}

func (s *Net_lvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_lvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_lvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNet_lvalue(s)
	}
}

func (s *Net_lvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNet_lvalue(s)
	}
}

func (p *VerilogParser) Net_lvalue() (localctx INet_lvalueContext) {
	localctx = NewNet_lvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, VerilogParserRULE_net_lvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3807)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 401, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3770)
			p.Hierarchical_net_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3771)
			p.Hierarchical_net_identifier()
		}
		{
			p.SetState(3772)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3773)
			p.Constant_expression()
		}
		{
			p.SetState(3774)
			p.Match(VerilogParserT__21)
		}
		p.SetState(3781)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__20 {
			{
				p.SetState(3775)
				p.Match(VerilogParserT__20)
			}
			{
				p.SetState(3776)
				p.Constant_expression()
			}
			{
				p.SetState(3777)
				p.Match(VerilogParserT__21)
			}

			p.SetState(3783)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3784)
			p.Hierarchical_net_identifier()
		}
		{
			p.SetState(3785)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3786)
			p.Constant_expression()
		}
		{
			p.SetState(3787)
			p.Match(VerilogParserT__21)
		}
		p.SetState(3794)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 400, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3788)
					p.Match(VerilogParserT__20)
				}
				{
					p.SetState(3789)
					p.Constant_expression()
				}
				{
					p.SetState(3790)
					p.Match(VerilogParserT__21)
				}

			}
			p.SetState(3796)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 400, p.GetParserRuleContext())
		}
		{
			p.SetState(3797)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3798)
			p.Constant_range_expression()
		}
		{
			p.SetState(3799)
			p.Match(VerilogParserT__21)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3801)
			p.Hierarchical_net_identifier()
		}
		{
			p.SetState(3802)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3803)
			p.Constant_range_expression()
		}
		{
			p.SetState(3804)
			p.Match(VerilogParserT__21)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3806)
			p.Net_concatenation()
		}

	}

	return localctx
}

// IVariable_lvalueContext is an interface to support dynamic dispatch.
type IVariable_lvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_lvalueContext differentiates from other interfaces.
	IsVariable_lvalueContext()
}

type Variable_lvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_lvalueContext() *Variable_lvalueContext {
	var p = new(Variable_lvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_lvalue
	return p
}

func (*Variable_lvalueContext) IsVariable_lvalueContext() {}

func NewVariable_lvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_lvalueContext {
	var p = new(Variable_lvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_lvalue

	return p
}

func (s *Variable_lvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_lvalueContext) Hierarchical_variable_identifier() IHierarchical_variable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_variable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_variable_identifierContext)
}

func (s *Variable_lvalueContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Variable_lvalueContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_lvalueContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Variable_lvalueContext) Variable_concatenation() IVariable_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_concatenationContext)
}

func (s *Variable_lvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_lvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_lvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterVariable_lvalue(s)
	}
}

func (s *Variable_lvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitVariable_lvalue(s)
	}
}

func (p *VerilogParser) Variable_lvalue() (localctx IVariable_lvalueContext) {
	localctx = NewVariable_lvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, VerilogParserRULE_variable_lvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3846)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 404, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3809)
			p.Hierarchical_variable_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3810)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(3811)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3812)
			p.Expression()
		}
		{
			p.SetState(3813)
			p.Match(VerilogParserT__21)
		}
		p.SetState(3820)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserT__20 {
			{
				p.SetState(3814)
				p.Match(VerilogParserT__20)
			}
			{
				p.SetState(3815)
				p.Expression()
			}
			{
				p.SetState(3816)
				p.Match(VerilogParserT__21)
			}

			p.SetState(3822)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3823)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(3824)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3825)
			p.Expression()
		}
		{
			p.SetState(3826)
			p.Match(VerilogParserT__21)
		}
		p.SetState(3833)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 403, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3827)
					p.Match(VerilogParserT__20)
				}
				{
					p.SetState(3828)
					p.Expression()
				}
				{
					p.SetState(3829)
					p.Match(VerilogParserT__21)
				}

			}
			p.SetState(3835)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 403, p.GetParserRuleContext())
		}
		{
			p.SetState(3836)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3837)
			p.Range_expression()
		}
		{
			p.SetState(3838)
			p.Match(VerilogParserT__21)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3840)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(3841)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(3842)
			p.Range_expression()
		}
		{
			p.SetState(3843)
			p.Match(VerilogParserT__21)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3845)
			p.Variable_concatenation()
		}

	}

	return localctx
}

// IUnary_operatorContext is an interface to support dynamic dispatch.
type IUnary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_operatorContext differentiates from other interfaces.
	IsUnary_operatorContext()
}

type Unary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_operatorContext() *Unary_operatorContext {
	var p = new(Unary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_unary_operator
	return p
}

func (*Unary_operatorContext) IsUnary_operatorContext() {}

func NewUnary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_operatorContext {
	var p = new(Unary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_unary_operator

	return p
}

func (s *Unary_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Unary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterUnary_operator(s)
	}
}

func (s *Unary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitUnary_operator(s)
	}
}

func (p *VerilogParser) Unary_operator() (localctx IUnary_operatorContext) {
	localctx = NewUnary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, VerilogParserRULE_unary_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3848)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-136)&-(0x1f+1)) == 0 && ((1<<uint((_la-136)))&((1<<(VerilogParserT__135-136))|(1<<(VerilogParserT__136-136))|(1<<(VerilogParserT__140-136))|(1<<(VerilogParserT__141-136))|(1<<(VerilogParserT__142-136))|(1<<(VerilogParserT__143-136))|(1<<(VerilogParserT__144-136))|(1<<(VerilogParserT__145-136))|(1<<(VerilogParserT__146-136))|(1<<(VerilogParserT__147-136))|(1<<(VerilogParserT__148-136)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBinary_operatorContext is an interface to support dynamic dispatch.
type IBinary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinary_operatorContext differentiates from other interfaces.
	IsBinary_operatorContext()
}

type Binary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinary_operatorContext() *Binary_operatorContext {
	var p = new(Binary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_binary_operator
	return p
}

func (*Binary_operatorContext) IsBinary_operatorContext() {}

func NewBinary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binary_operatorContext {
	var p = new(Binary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_binary_operator

	return p
}

func (s *Binary_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Binary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterBinary_operator(s)
	}
}

func (s *Binary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitBinary_operator(s)
	}
}

func (p *VerilogParser) Binary_operator() (localctx IBinary_operatorContext) {
	localctx = NewBinary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, VerilogParserRULE_binary_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3850)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(VerilogParserT__108-109))|(1<<(VerilogParserT__117-109))|(1<<(VerilogParserT__135-109))|(1<<(VerilogParserT__136-109)))) != 0) || (((_la-143)&-(0x1f+1)) == 0 && ((1<<uint((_la-143)))&((1<<(VerilogParserT__142-143))|(1<<(VerilogParserT__144-143))|(1<<(VerilogParserT__146-143))|(1<<(VerilogParserT__147-143))|(1<<(VerilogParserT__148-143))|(1<<(VerilogParserT__149-143))|(1<<(VerilogParserT__150-143))|(1<<(VerilogParserT__151-143))|(1<<(VerilogParserT__152-143))|(1<<(VerilogParserT__153-143))|(1<<(VerilogParserT__154-143))|(1<<(VerilogParserT__155-143))|(1<<(VerilogParserT__156-143))|(1<<(VerilogParserT__157-143))|(1<<(VerilogParserT__158-143))|(1<<(VerilogParserT__159-143))|(1<<(VerilogParserT__160-143))|(1<<(VerilogParserT__161-143))|(1<<(VerilogParserT__162-143))|(1<<(VerilogParserT__163-143))|(1<<(VerilogParserT__164-143)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUnary_module_path_operatorContext is an interface to support dynamic dispatch.
type IUnary_module_path_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_module_path_operatorContext differentiates from other interfaces.
	IsUnary_module_path_operatorContext()
}

type Unary_module_path_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_module_path_operatorContext() *Unary_module_path_operatorContext {
	var p = new(Unary_module_path_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_unary_module_path_operator
	return p
}

func (*Unary_module_path_operatorContext) IsUnary_module_path_operatorContext() {}

func NewUnary_module_path_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_module_path_operatorContext {
	var p = new(Unary_module_path_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_unary_module_path_operator

	return p
}

func (s *Unary_module_path_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Unary_module_path_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_module_path_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_module_path_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterUnary_module_path_operator(s)
	}
}

func (s *Unary_module_path_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitUnary_module_path_operator(s)
	}
}

func (p *VerilogParser) Unary_module_path_operator() (localctx IUnary_module_path_operatorContext) {
	localctx = NewUnary_module_path_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, VerilogParserRULE_unary_module_path_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3852)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(VerilogParserT__140-141))|(1<<(VerilogParserT__141-141))|(1<<(VerilogParserT__142-141))|(1<<(VerilogParserT__143-141))|(1<<(VerilogParserT__144-141))|(1<<(VerilogParserT__145-141))|(1<<(VerilogParserT__146-141))|(1<<(VerilogParserT__147-141))|(1<<(VerilogParserT__148-141)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBinary_module_path_operatorContext is an interface to support dynamic dispatch.
type IBinary_module_path_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinary_module_path_operatorContext differentiates from other interfaces.
	IsBinary_module_path_operatorContext()
}

type Binary_module_path_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinary_module_path_operatorContext() *Binary_module_path_operatorContext {
	var p = new(Binary_module_path_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_binary_module_path_operator
	return p
}

func (*Binary_module_path_operatorContext) IsBinary_module_path_operatorContext() {}

func NewBinary_module_path_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binary_module_path_operatorContext {
	var p = new(Binary_module_path_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_binary_module_path_operator

	return p
}

func (s *Binary_module_path_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Binary_module_path_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_module_path_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binary_module_path_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterBinary_module_path_operator(s)
	}
}

func (s *Binary_module_path_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitBinary_module_path_operator(s)
	}
}

func (p *VerilogParser) Binary_module_path_operator() (localctx IBinary_module_path_operatorContext) {
	localctx = NewBinary_module_path_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, VerilogParserRULE_binary_module_path_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3854)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-143)&-(0x1f+1)) == 0 && ((1<<uint((_la-143)))&((1<<(VerilogParserT__142-143))|(1<<(VerilogParserT__144-143))|(1<<(VerilogParserT__146-143))|(1<<(VerilogParserT__147-143))|(1<<(VerilogParserT__148-143))|(1<<(VerilogParserT__151-143))|(1<<(VerilogParserT__152-143))|(1<<(VerilogParserT__155-143))|(1<<(VerilogParserT__156-143)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Decimal_number() antlr.TerminalNode {
	return s.GetToken(VerilogParserDecimal_number, 0)
}

func (s *NumberContext) Octal_number() antlr.TerminalNode {
	return s.GetToken(VerilogParserOctal_number, 0)
}

func (s *NumberContext) Binary_number() antlr.TerminalNode {
	return s.GetToken(VerilogParserBinary_number, 0)
}

func (s *NumberContext) Hex_number() antlr.TerminalNode {
	return s.GetToken(VerilogParserHex_number, 0)
}

func (s *NumberContext) Real_number() antlr.TerminalNode {
	return s.GetToken(VerilogParserReal_number, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (p *VerilogParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, VerilogParserRULE_number)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3856)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-168)&-(0x1f+1)) == 0 && ((1<<uint((_la-168)))&((1<<(VerilogParserReal_number-168))|(1<<(VerilogParserDecimal_number-168))|(1<<(VerilogParserBinary_number-168))|(1<<(VerilogParserOctal_number-168))|(1<<(VerilogParserHex_number-168)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITiming_specContext is an interface to support dynamic dispatch.
type ITiming_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTiming_specContext differentiates from other interfaces.
	IsTiming_specContext()
}

type Timing_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTiming_specContext() *Timing_specContext {
	var p = new(Timing_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_timing_spec
	return p
}

func (*Timing_specContext) IsTiming_specContext() {}

func NewTiming_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timing_specContext {
	var p = new(Timing_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_timing_spec

	return p
}

func (s *Timing_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Timing_specContext) AllTime_Identifier() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserTime_Identifier)
}

func (s *Timing_specContext) Time_Identifier(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserTime_Identifier, i)
}

func (s *Timing_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timing_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timing_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTiming_spec(s)
	}
}

func (s *Timing_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTiming_spec(s)
	}
}

func (p *VerilogParser) Timing_spec() (localctx ITiming_specContext) {
	localctx = NewTiming_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, VerilogParserRULE_timing_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3858)
		p.Match(VerilogParserT__165)
	}
	{
		p.SetState(3859)
		p.Match(VerilogParserTime_Identifier)
	}
	{
		p.SetState(3860)
		p.Match(VerilogParserT__149)
	}
	{
		p.SetState(3861)
		p.Match(VerilogParserTime_Identifier)
	}

	return localctx
}

// IDefineContext is an interface to support dynamic dispatch.
type IDefineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefineContext differentiates from other interfaces.
	IsDefineContext()
}

type DefineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefineContext() *DefineContext {
	var p = new(DefineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_define
	return p
}

func (*DefineContext) IsDefineContext() {}

func NewDefineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefineContext {
	var p = new(DefineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_define

	return p
}

func (s *DefineContext) GetParser() antlr.Parser { return s.parser }

func (s *DefineContext) Define_identifier() IDefine_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefine_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefine_identifierContext)
}

func (s *DefineContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *DefineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDefine(s)
	}
}

func (s *DefineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDefine(s)
	}
}

func (p *VerilogParser) Define() (localctx IDefineContext) {
	localctx = NewDefineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, VerilogParserRULE_define)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3863)
		p.Match(VerilogParserT__166)
	}
	{
		p.SetState(3864)
		p.Define_identifier()
	}
	{
		p.SetState(3865)
		p.Constant_expression()
	}

	return localctx
}

// IAttribute_instanceContext is an interface to support dynamic dispatch.
type IAttribute_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_instanceContext differentiates from other interfaces.
	IsAttribute_instanceContext()
}

type Attribute_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_instanceContext() *Attribute_instanceContext {
	var p = new(Attribute_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_attribute_instance
	return p
}

func (*Attribute_instanceContext) IsAttribute_instanceContext() {}

func NewAttribute_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_instanceContext {
	var p = new(Attribute_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_attribute_instance

	return p
}

func (s *Attribute_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_instanceContext) AllAttr_spec() []IAttr_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttr_specContext)(nil)).Elem())
	var tst = make([]IAttr_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttr_specContext)
		}
	}

	return tst
}

func (s *Attribute_instanceContext) Attr_spec(i int) IAttr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttr_specContext)
}

func (s *Attribute_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterAttribute_instance(s)
	}
}

func (s *Attribute_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitAttribute_instance(s)
	}
}

func (p *VerilogParser) Attribute_instance() (localctx IAttribute_instanceContext) {
	localctx = NewAttribute_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, VerilogParserRULE_attribute_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3867)
		p.Match(VerilogParserT__15)
	}
	{
		p.SetState(3868)
		p.Match(VerilogParserT__117)
	}
	{
		p.SetState(3869)
		p.Attr_spec()
	}
	p.SetState(3874)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__16 {
		{
			p.SetState(3870)
			p.Match(VerilogParserT__16)
		}
		{
			p.SetState(3871)
			p.Attr_spec()
		}

		p.SetState(3876)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3877)
		p.Match(VerilogParserT__117)
	}
	{
		p.SetState(3878)
		p.Match(VerilogParserT__17)
	}

	return localctx
}

// IAttr_specContext is an interface to support dynamic dispatch.
type IAttr_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_specContext differentiates from other interfaces.
	IsAttr_specContext()
}

type Attr_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_specContext() *Attr_specContext {
	var p = new(Attr_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_attr_spec
	return p
}

func (*Attr_specContext) IsAttr_specContext() {}

func NewAttr_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_specContext {
	var p = new(Attr_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_attr_spec

	return p
}

func (s *Attr_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_specContext) Attr_name() IAttr_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_nameContext)
}

func (s *Attr_specContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Attr_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterAttr_spec(s)
	}
}

func (s *Attr_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitAttr_spec(s)
	}
}

func (p *VerilogParser) Attr_spec() (localctx IAttr_specContext) {
	localctx = NewAttr_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, VerilogParserRULE_attr_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3885)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 406, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3880)
			p.Attr_name()
		}
		{
			p.SetState(3881)
			p.Match(VerilogParserT__50)
		}
		{
			p.SetState(3882)
			p.Constant_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3884)
			p.Attr_name()
		}

	}

	return localctx
}

// IAttr_nameContext is an interface to support dynamic dispatch.
type IAttr_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_nameContext differentiates from other interfaces.
	IsAttr_nameContext()
}

type Attr_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_nameContext() *Attr_nameContext {
	var p = new(Attr_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_attr_name
	return p
}

func (*Attr_nameContext) IsAttr_nameContext() {}

func NewAttr_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_nameContext {
	var p = new(Attr_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_attr_name

	return p
}

func (s *Attr_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Attr_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterAttr_name(s)
	}
}

func (s *Attr_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitAttr_name(s)
	}
}

func (p *VerilogParser) Attr_name() (localctx IAttr_nameContext) {
	localctx = NewAttr_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, VerilogParserRULE_attr_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3887)
		p.Identifier()
	}

	return localctx
}

// IArrayed_identifierContext is an interface to support dynamic dispatch.
type IArrayed_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayed_identifierContext differentiates from other interfaces.
	IsArrayed_identifierContext()
}

type Arrayed_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayed_identifierContext() *Arrayed_identifierContext {
	var p = new(Arrayed_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_arrayed_identifier
	return p
}

func (*Arrayed_identifierContext) IsArrayed_identifierContext() {}

func NewArrayed_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arrayed_identifierContext {
	var p = new(Arrayed_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_arrayed_identifier

	return p
}

func (s *Arrayed_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Arrayed_identifierContext) Simple_arrayed_identifier() ISimple_arrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_arrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_arrayed_identifierContext)
}

func (s *Arrayed_identifierContext) Escaped_arrayed_identifier() IEscaped_arrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscaped_arrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEscaped_arrayed_identifierContext)
}

func (s *Arrayed_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arrayed_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arrayed_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterArrayed_identifier(s)
	}
}

func (s *Arrayed_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitArrayed_identifier(s)
	}
}

func (p *VerilogParser) Arrayed_identifier() (localctx IArrayed_identifierContext) {
	localctx = NewArrayed_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, VerilogParserRULE_arrayed_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3891)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3889)
			p.Simple_arrayed_identifier()
		}

	case VerilogParserEscaped_identifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3890)
			p.Escaped_arrayed_identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBlock_identifierContext is an interface to support dynamic dispatch.
type IBlock_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_identifierContext differentiates from other interfaces.
	IsBlock_identifierContext()
}

type Block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_identifierContext() *Block_identifierContext {
	var p = new(Block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_block_identifier
	return p
}

func (*Block_identifierContext) IsBlock_identifierContext() {}

func NewBlock_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_identifierContext {
	var p = new(Block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_block_identifier

	return p
}

func (s *Block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterBlock_identifier(s)
	}
}

func (s *Block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitBlock_identifier(s)
	}
}

func (p *VerilogParser) Block_identifier() (localctx IBlock_identifierContext) {
	localctx = NewBlock_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, VerilogParserRULE_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3893)
		p.Identifier()
	}

	return localctx
}

// ICell_identifierContext is an interface to support dynamic dispatch.
type ICell_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCell_identifierContext differentiates from other interfaces.
	IsCell_identifierContext()
}

type Cell_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCell_identifierContext() *Cell_identifierContext {
	var p = new(Cell_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_cell_identifier
	return p
}

func (*Cell_identifierContext) IsCell_identifierContext() {}

func NewCell_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cell_identifierContext {
	var p = new(Cell_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_cell_identifier

	return p
}

func (s *Cell_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Cell_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Cell_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cell_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cell_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterCell_identifier(s)
	}
}

func (s *Cell_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitCell_identifier(s)
	}
}

func (p *VerilogParser) Cell_identifier() (localctx ICell_identifierContext) {
	localctx = NewCell_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, VerilogParserRULE_cell_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3895)
		p.Identifier()
	}

	return localctx
}

// IConfig_identifierContext is an interface to support dynamic dispatch.
type IConfig_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfig_identifierContext differentiates from other interfaces.
	IsConfig_identifierContext()
}

type Config_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfig_identifierContext() *Config_identifierContext {
	var p = new(Config_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_config_identifier
	return p
}

func (*Config_identifierContext) IsConfig_identifierContext() {}

func NewConfig_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Config_identifierContext {
	var p = new(Config_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_config_identifier

	return p
}

func (s *Config_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Config_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Config_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Config_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Config_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterConfig_identifier(s)
	}
}

func (s *Config_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitConfig_identifier(s)
	}
}

func (p *VerilogParser) Config_identifier() (localctx IConfig_identifierContext) {
	localctx = NewConfig_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, VerilogParserRULE_config_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3897)
		p.Identifier()
	}

	return localctx
}

// IDefine_identifierContext is an interface to support dynamic dispatch.
type IDefine_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefine_identifierContext differentiates from other interfaces.
	IsDefine_identifierContext()
}

type Define_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefine_identifierContext() *Define_identifierContext {
	var p = new(Define_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_define_identifier
	return p
}

func (*Define_identifierContext) IsDefine_identifierContext() {}

func NewDefine_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Define_identifierContext {
	var p = new(Define_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_define_identifier

	return p
}

func (s *Define_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Define_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Define_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Define_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Define_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterDefine_identifier(s)
	}
}

func (s *Define_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitDefine_identifier(s)
	}
}

func (p *VerilogParser) Define_identifier() (localctx IDefine_identifierContext) {
	localctx = NewDefine_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, VerilogParserRULE_define_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3899)
		p.Identifier()
	}

	return localctx
}

// IEscaped_arrayed_identifierContext is an interface to support dynamic dispatch.
type IEscaped_arrayed_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEscaped_arrayed_identifierContext differentiates from other interfaces.
	IsEscaped_arrayed_identifierContext()
}

type Escaped_arrayed_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscaped_arrayed_identifierContext() *Escaped_arrayed_identifierContext {
	var p = new(Escaped_arrayed_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_escaped_arrayed_identifier
	return p
}

func (*Escaped_arrayed_identifierContext) IsEscaped_arrayed_identifierContext() {}

func NewEscaped_arrayed_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Escaped_arrayed_identifierContext {
	var p = new(Escaped_arrayed_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_escaped_arrayed_identifier

	return p
}

func (s *Escaped_arrayed_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Escaped_arrayed_identifierContext) Escaped_identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserEscaped_identifier, 0)
}

func (s *Escaped_arrayed_identifierContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Escaped_arrayed_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Escaped_arrayed_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Escaped_arrayed_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEscaped_arrayed_identifier(s)
	}
}

func (s *Escaped_arrayed_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEscaped_arrayed_identifier(s)
	}
}

func (p *VerilogParser) Escaped_arrayed_identifier() (localctx IEscaped_arrayed_identifierContext) {
	localctx = NewEscaped_arrayed_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, VerilogParserRULE_escaped_arrayed_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3901)
		p.Match(VerilogParserEscaped_identifier)
	}
	p.SetState(3903)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 408, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3902)
			p.Range_()
		}

	}

	return localctx
}

// IEscaped_hierarchical_identifierContext is an interface to support dynamic dispatch.
type IEscaped_hierarchical_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEscaped_hierarchical_identifierContext differentiates from other interfaces.
	IsEscaped_hierarchical_identifierContext()
}

type Escaped_hierarchical_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscaped_hierarchical_identifierContext() *Escaped_hierarchical_identifierContext {
	var p = new(Escaped_hierarchical_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_escaped_hierarchical_identifier
	return p
}

func (*Escaped_hierarchical_identifierContext) IsEscaped_hierarchical_identifierContext() {}

func NewEscaped_hierarchical_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Escaped_hierarchical_identifierContext {
	var p = new(Escaped_hierarchical_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_escaped_hierarchical_identifier

	return p
}

func (s *Escaped_hierarchical_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Escaped_hierarchical_identifierContext) AllEscaped_hierarchical_branch() []IEscaped_hierarchical_branchContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscaped_hierarchical_branchContext)(nil)).Elem())
	var tst = make([]IEscaped_hierarchical_branchContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscaped_hierarchical_branchContext)
		}
	}

	return tst
}

func (s *Escaped_hierarchical_identifierContext) Escaped_hierarchical_branch(i int) IEscaped_hierarchical_branchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscaped_hierarchical_branchContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscaped_hierarchical_branchContext)
}

func (s *Escaped_hierarchical_identifierContext) AllSimple_hierarchical_branch() []ISimple_hierarchical_branchContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_hierarchical_branchContext)(nil)).Elem())
	var tst = make([]ISimple_hierarchical_branchContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_hierarchical_branchContext)
		}
	}

	return tst
}

func (s *Escaped_hierarchical_identifierContext) Simple_hierarchical_branch(i int) ISimple_hierarchical_branchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_hierarchical_branchContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_hierarchical_branchContext)
}

func (s *Escaped_hierarchical_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Escaped_hierarchical_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Escaped_hierarchical_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEscaped_hierarchical_identifier(s)
	}
}

func (s *Escaped_hierarchical_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEscaped_hierarchical_identifier(s)
	}
}

func (p *VerilogParser) Escaped_hierarchical_identifier() (localctx IEscaped_hierarchical_identifierContext) {
	localctx = NewEscaped_hierarchical_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, VerilogParserRULE_escaped_hierarchical_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3905)
		p.Escaped_hierarchical_branch()
	}
	p.SetState(3912)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserT__4 {
		p.SetState(3910)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 409, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3906)
				p.Match(VerilogParserT__4)
			}
			{
				p.SetState(3907)
				p.Simple_hierarchical_branch()
			}

		case 2:
			{
				p.SetState(3908)
				p.Match(VerilogParserT__4)
			}
			{
				p.SetState(3909)
				p.Escaped_hierarchical_branch()
			}

		}

		p.SetState(3914)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEvent_identifierContext is an interface to support dynamic dispatch.
type IEvent_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_identifierContext differentiates from other interfaces.
	IsEvent_identifierContext()
}

type Event_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_identifierContext() *Event_identifierContext {
	var p = new(Event_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_identifier
	return p
}

func (*Event_identifierContext) IsEvent_identifierContext() {}

func NewEvent_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_identifierContext {
	var p = new(Event_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_identifier

	return p
}

func (s *Event_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Event_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEvent_identifier(s)
	}
}

func (s *Event_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEvent_identifier(s)
	}
}

func (p *VerilogParser) Event_identifier() (localctx IEvent_identifierContext) {
	localctx = NewEvent_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, VerilogParserRULE_event_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3915)
		p.Identifier()
	}

	return localctx
}

// IFunction_identifierContext is an interface to support dynamic dispatch.
type IFunction_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_identifierContext differentiates from other interfaces.
	IsFunction_identifierContext()
}

type Function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_identifierContext() *Function_identifierContext {
	var p = new(Function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_identifier
	return p
}

func (*Function_identifierContext) IsFunction_identifierContext() {}

func NewFunction_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_identifierContext {
	var p = new(Function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_identifier

	return p
}

func (s *Function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterFunction_identifier(s)
	}
}

func (s *Function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitFunction_identifier(s)
	}
}

func (p *VerilogParser) Function_identifier() (localctx IFunction_identifierContext) {
	localctx = NewFunction_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, VerilogParserRULE_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3917)
		p.Identifier()
	}

	return localctx
}

// IGate_instance_identifierContext is an interface to support dynamic dispatch.
type IGate_instance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGate_instance_identifierContext differentiates from other interfaces.
	IsGate_instance_identifierContext()
}

type Gate_instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGate_instance_identifierContext() *Gate_instance_identifierContext {
	var p = new(Gate_instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_gate_instance_identifier
	return p
}

func (*Gate_instance_identifierContext) IsGate_instance_identifierContext() {}

func NewGate_instance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Gate_instance_identifierContext {
	var p = new(Gate_instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_gate_instance_identifier

	return p
}

func (s *Gate_instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Gate_instance_identifierContext) Arrayed_identifier() IArrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayed_identifierContext)
}

func (s *Gate_instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Gate_instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Gate_instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGate_instance_identifier(s)
	}
}

func (s *Gate_instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGate_instance_identifier(s)
	}
}

func (p *VerilogParser) Gate_instance_identifier() (localctx IGate_instance_identifierContext) {
	localctx = NewGate_instance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, VerilogParserRULE_gate_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3919)
		p.Arrayed_identifier()
	}

	return localctx
}

// IGenerate_block_identifierContext is an interface to support dynamic dispatch.
type IGenerate_block_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_block_identifierContext differentiates from other interfaces.
	IsGenerate_block_identifierContext()
}

type Generate_block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_block_identifierContext() *Generate_block_identifierContext {
	var p = new(Generate_block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_block_identifier
	return p
}

func (*Generate_block_identifierContext) IsGenerate_block_identifierContext() {}

func NewGenerate_block_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_block_identifierContext {
	var p = new(Generate_block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_block_identifier

	return p
}

func (s *Generate_block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_block_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Generate_block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenerate_block_identifier(s)
	}
}

func (s *Generate_block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenerate_block_identifier(s)
	}
}

func (p *VerilogParser) Generate_block_identifier() (localctx IGenerate_block_identifierContext) {
	localctx = NewGenerate_block_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, VerilogParserRULE_generate_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3921)
		p.Identifier()
	}

	return localctx
}

// IGenvar_function_identifierContext is an interface to support dynamic dispatch.
type IGenvar_function_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_function_identifierContext differentiates from other interfaces.
	IsGenvar_function_identifierContext()
}

type Genvar_function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_function_identifierContext() *Genvar_function_identifierContext {
	var p = new(Genvar_function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_function_identifier
	return p
}

func (*Genvar_function_identifierContext) IsGenvar_function_identifierContext() {}

func NewGenvar_function_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_function_identifierContext {
	var p = new(Genvar_function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_function_identifier

	return p
}

func (s *Genvar_function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_function_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Genvar_function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenvar_function_identifier(s)
	}
}

func (s *Genvar_function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenvar_function_identifier(s)
	}
}

func (p *VerilogParser) Genvar_function_identifier() (localctx IGenvar_function_identifierContext) {
	localctx = NewGenvar_function_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, VerilogParserRULE_genvar_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3923)
		p.Identifier()
	}

	return localctx
}

// IGenvar_identifierContext is an interface to support dynamic dispatch.
type IGenvar_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_identifierContext differentiates from other interfaces.
	IsGenvar_identifierContext()
}

type Genvar_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_identifierContext() *Genvar_identifierContext {
	var p = new(Genvar_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_identifier
	return p
}

func (*Genvar_identifierContext) IsGenvar_identifierContext() {}

func NewGenvar_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_identifierContext {
	var p = new(Genvar_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_identifier

	return p
}

func (s *Genvar_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Genvar_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterGenvar_identifier(s)
	}
}

func (s *Genvar_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitGenvar_identifier(s)
	}
}

func (p *VerilogParser) Genvar_identifier() (localctx IGenvar_identifierContext) {
	localctx = NewGenvar_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, VerilogParserRULE_genvar_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3925)
		p.Identifier()
	}

	return localctx
}

// IHierarchical_block_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_block_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_block_identifierContext differentiates from other interfaces.
	IsHierarchical_block_identifierContext()
}

type Hierarchical_block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_block_identifierContext() *Hierarchical_block_identifierContext {
	var p = new(Hierarchical_block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_block_identifier
	return p
}

func (*Hierarchical_block_identifierContext) IsHierarchical_block_identifierContext() {}

func NewHierarchical_block_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_block_identifierContext {
	var p = new(Hierarchical_block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_block_identifier

	return p
}

func (s *Hierarchical_block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_block_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterHierarchical_block_identifier(s)
	}
}

func (s *Hierarchical_block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitHierarchical_block_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_block_identifier() (localctx IHierarchical_block_identifierContext) {
	localctx = NewHierarchical_block_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, VerilogParserRULE_hierarchical_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3927)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_event_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_event_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_event_identifierContext differentiates from other interfaces.
	IsHierarchical_event_identifierContext()
}

type Hierarchical_event_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_event_identifierContext() *Hierarchical_event_identifierContext {
	var p = new(Hierarchical_event_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_event_identifier
	return p
}

func (*Hierarchical_event_identifierContext) IsHierarchical_event_identifierContext() {}

func NewHierarchical_event_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_event_identifierContext {
	var p = new(Hierarchical_event_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_event_identifier

	return p
}

func (s *Hierarchical_event_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_event_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_event_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_event_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_event_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterHierarchical_event_identifier(s)
	}
}

func (s *Hierarchical_event_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitHierarchical_event_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_event_identifier() (localctx IHierarchical_event_identifierContext) {
	localctx = NewHierarchical_event_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, VerilogParserRULE_hierarchical_event_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3929)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_function_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_function_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_function_identifierContext differentiates from other interfaces.
	IsHierarchical_function_identifierContext()
}

type Hierarchical_function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_function_identifierContext() *Hierarchical_function_identifierContext {
	var p = new(Hierarchical_function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_function_identifier
	return p
}

func (*Hierarchical_function_identifierContext) IsHierarchical_function_identifierContext() {}

func NewHierarchical_function_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_function_identifierContext {
	var p = new(Hierarchical_function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_function_identifier

	return p
}

func (s *Hierarchical_function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_function_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterHierarchical_function_identifier(s)
	}
}

func (s *Hierarchical_function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitHierarchical_function_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_function_identifier() (localctx IHierarchical_function_identifierContext) {
	localctx = NewHierarchical_function_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, VerilogParserRULE_hierarchical_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3931)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_identifierContext differentiates from other interfaces.
	IsHierarchical_identifierContext()
}

type Hierarchical_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_identifierContext() *Hierarchical_identifierContext {
	var p = new(Hierarchical_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_identifier
	return p
}

func (*Hierarchical_identifierContext) IsHierarchical_identifierContext() {}

func NewHierarchical_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_identifierContext {
	var p = new(Hierarchical_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_identifier

	return p
}

func (s *Hierarchical_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_identifierContext) Simple_hierarchical_identifier() ISimple_hierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_hierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_hierarchical_identifierContext)
}

func (s *Hierarchical_identifierContext) Escaped_hierarchical_identifier() IEscaped_hierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscaped_hierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEscaped_hierarchical_identifierContext)
}

func (s *Hierarchical_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterHierarchical_identifier(s)
	}
}

func (s *Hierarchical_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitHierarchical_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_identifier() (localctx IHierarchical_identifierContext) {
	localctx = NewHierarchical_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, VerilogParserRULE_hierarchical_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3935)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3933)
			p.Simple_hierarchical_identifier()
		}

	case VerilogParserEscaped_identifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3934)
			p.Escaped_hierarchical_identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHierarchical_net_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_net_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_net_identifierContext differentiates from other interfaces.
	IsHierarchical_net_identifierContext()
}

type Hierarchical_net_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_net_identifierContext() *Hierarchical_net_identifierContext {
	var p = new(Hierarchical_net_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_net_identifier
	return p
}

func (*Hierarchical_net_identifierContext) IsHierarchical_net_identifierContext() {}

func NewHierarchical_net_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_net_identifierContext {
	var p = new(Hierarchical_net_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_net_identifier

	return p
}

func (s *Hierarchical_net_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_net_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_net_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_net_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_net_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterHierarchical_net_identifier(s)
	}
}

func (s *Hierarchical_net_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitHierarchical_net_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_net_identifier() (localctx IHierarchical_net_identifierContext) {
	localctx = NewHierarchical_net_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, VerilogParserRULE_hierarchical_net_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3937)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_variable_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_variable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_variable_identifierContext differentiates from other interfaces.
	IsHierarchical_variable_identifierContext()
}

type Hierarchical_variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_variable_identifierContext() *Hierarchical_variable_identifierContext {
	var p = new(Hierarchical_variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_variable_identifier
	return p
}

func (*Hierarchical_variable_identifierContext) IsHierarchical_variable_identifierContext() {}

func NewHierarchical_variable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_variable_identifierContext {
	var p = new(Hierarchical_variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_variable_identifier

	return p
}

func (s *Hierarchical_variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_variable_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterHierarchical_variable_identifier(s)
	}
}

func (s *Hierarchical_variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitHierarchical_variable_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_variable_identifier() (localctx IHierarchical_variable_identifierContext) {
	localctx = NewHierarchical_variable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, VerilogParserRULE_hierarchical_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3939)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_task_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_task_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_task_identifierContext differentiates from other interfaces.
	IsHierarchical_task_identifierContext()
}

type Hierarchical_task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_task_identifierContext() *Hierarchical_task_identifierContext {
	var p = new(Hierarchical_task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_task_identifier
	return p
}

func (*Hierarchical_task_identifierContext) IsHierarchical_task_identifierContext() {}

func NewHierarchical_task_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_task_identifierContext {
	var p = new(Hierarchical_task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_task_identifier

	return p
}

func (s *Hierarchical_task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_task_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterHierarchical_task_identifier(s)
	}
}

func (s *Hierarchical_task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitHierarchical_task_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_task_identifier() (localctx IHierarchical_task_identifierContext) {
	localctx = NewHierarchical_task_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, VerilogParserRULE_hierarchical_task_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3941)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Simple_identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserSimple_identifier, 0)
}

func (s *IdentifierContext) Escaped_identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserEscaped_identifier, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *VerilogParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, VerilogParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3943)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInout_port_identifierContext is an interface to support dynamic dispatch.
type IInout_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_port_identifierContext differentiates from other interfaces.
	IsInout_port_identifierContext()
}

type Inout_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_port_identifierContext() *Inout_port_identifierContext {
	var p = new(Inout_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inout_port_identifier
	return p
}

func (*Inout_port_identifierContext) IsInout_port_identifierContext() {}

func NewInout_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_port_identifierContext {
	var p = new(Inout_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inout_port_identifier

	return p
}

func (s *Inout_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Inout_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterInout_port_identifier(s)
	}
}

func (s *Inout_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitInout_port_identifier(s)
	}
}

func (p *VerilogParser) Inout_port_identifier() (localctx IInout_port_identifierContext) {
	localctx = NewInout_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, VerilogParserRULE_inout_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3945)
		p.Identifier()
	}

	return localctx
}

// IInput_port_identifierContext is an interface to support dynamic dispatch.
type IInput_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_port_identifierContext differentiates from other interfaces.
	IsInput_port_identifierContext()
}

type Input_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_port_identifierContext() *Input_port_identifierContext {
	var p = new(Input_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_input_port_identifier
	return p
}

func (*Input_port_identifierContext) IsInput_port_identifierContext() {}

func NewInput_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_port_identifierContext {
	var p = new(Input_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_input_port_identifier

	return p
}

func (s *Input_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Input_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterInput_port_identifier(s)
	}
}

func (s *Input_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitInput_port_identifier(s)
	}
}

func (p *VerilogParser) Input_port_identifier() (localctx IInput_port_identifierContext) {
	localctx = NewInput_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, VerilogParserRULE_input_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3947)
		p.Identifier()
	}

	return localctx
}

// IInstance_identifierContext is an interface to support dynamic dispatch.
type IInstance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstance_identifierContext differentiates from other interfaces.
	IsInstance_identifierContext()
}

type Instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstance_identifierContext() *Instance_identifierContext {
	var p = new(Instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_instance_identifier
	return p
}

func (*Instance_identifierContext) IsInstance_identifierContext() {}

func NewInstance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instance_identifierContext {
	var p = new(Instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_instance_identifier

	return p
}

func (s *Instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Instance_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterInstance_identifier(s)
	}
}

func (s *Instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitInstance_identifier(s)
	}
}

func (p *VerilogParser) Instance_identifier() (localctx IInstance_identifierContext) {
	localctx = NewInstance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, VerilogParserRULE_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3949)
		p.Identifier()
	}

	return localctx
}

// ILibrary_identifierContext is an interface to support dynamic dispatch.
type ILibrary_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_identifierContext differentiates from other interfaces.
	IsLibrary_identifierContext()
}

type Library_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_identifierContext() *Library_identifierContext {
	var p = new(Library_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_library_identifier
	return p
}

func (*Library_identifierContext) IsLibrary_identifierContext() {}

func NewLibrary_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_identifierContext {
	var p = new(Library_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_library_identifier

	return p
}

func (s *Library_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Library_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterLibrary_identifier(s)
	}
}

func (s *Library_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitLibrary_identifier(s)
	}
}

func (p *VerilogParser) Library_identifier() (localctx ILibrary_identifierContext) {
	localctx = NewLibrary_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, VerilogParserRULE_library_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3951)
		p.Identifier()
	}

	return localctx
}

// IMemory_identifierContext is an interface to support dynamic dispatch.
type IMemory_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemory_identifierContext differentiates from other interfaces.
	IsMemory_identifierContext()
}

type Memory_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemory_identifierContext() *Memory_identifierContext {
	var p = new(Memory_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_memory_identifier
	return p
}

func (*Memory_identifierContext) IsMemory_identifierContext() {}

func NewMemory_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Memory_identifierContext {
	var p = new(Memory_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_memory_identifier

	return p
}

func (s *Memory_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Memory_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Memory_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Memory_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Memory_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterMemory_identifier(s)
	}
}

func (s *Memory_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitMemory_identifier(s)
	}
}

func (p *VerilogParser) Memory_identifier() (localctx IMemory_identifierContext) {
	localctx = NewMemory_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, VerilogParserRULE_memory_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3953)
		p.Identifier()
	}

	return localctx
}

// IModule_identifierContext is an interface to support dynamic dispatch.
type IModule_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_identifierContext differentiates from other interfaces.
	IsModule_identifierContext()
}

type Module_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_identifierContext() *Module_identifierContext {
	var p = new(Module_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_identifier
	return p
}

func (*Module_identifierContext) IsModule_identifierContext() {}

func NewModule_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_identifierContext {
	var p = new(Module_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_identifier

	return p
}

func (s *Module_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Module_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_identifier(s)
	}
}

func (s *Module_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_identifier(s)
	}
}

func (p *VerilogParser) Module_identifier() (localctx IModule_identifierContext) {
	localctx = NewModule_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, VerilogParserRULE_module_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3955)
		p.Identifier()
	}

	return localctx
}

// IModule_instance_identifierContext is an interface to support dynamic dispatch.
type IModule_instance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_instance_identifierContext differentiates from other interfaces.
	IsModule_instance_identifierContext()
}

type Module_instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_instance_identifierContext() *Module_instance_identifierContext {
	var p = new(Module_instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_instance_identifier
	return p
}

func (*Module_instance_identifierContext) IsModule_instance_identifierContext() {}

func NewModule_instance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_instance_identifierContext {
	var p = new(Module_instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_instance_identifier

	return p
}

func (s *Module_instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_instance_identifierContext) Arrayed_identifier() IArrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayed_identifierContext)
}

func (s *Module_instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterModule_instance_identifier(s)
	}
}

func (s *Module_instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitModule_instance_identifier(s)
	}
}

func (p *VerilogParser) Module_instance_identifier() (localctx IModule_instance_identifierContext) {
	localctx = NewModule_instance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, VerilogParserRULE_module_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3957)
		p.Arrayed_identifier()
	}

	return localctx
}

// INet_identifierContext is an interface to support dynamic dispatch.
type INet_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_identifierContext differentiates from other interfaces.
	IsNet_identifierContext()
}

type Net_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_identifierContext() *Net_identifierContext {
	var p = new(Net_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_identifier
	return p
}

func (*Net_identifierContext) IsNet_identifierContext() {}

func NewNet_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_identifierContext {
	var p = new(Net_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_identifier

	return p
}

func (s *Net_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Net_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterNet_identifier(s)
	}
}

func (s *Net_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitNet_identifier(s)
	}
}

func (p *VerilogParser) Net_identifier() (localctx INet_identifierContext) {
	localctx = NewNet_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, VerilogParserRULE_net_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3959)
		p.Identifier()
	}

	return localctx
}

// IOutput_port_identifierContext is an interface to support dynamic dispatch.
type IOutput_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_port_identifierContext differentiates from other interfaces.
	IsOutput_port_identifierContext()
}

type Output_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_port_identifierContext() *Output_port_identifierContext {
	var p = new(Output_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_port_identifier
	return p
}

func (*Output_port_identifierContext) IsOutput_port_identifierContext() {}

func NewOutput_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_port_identifierContext {
	var p = new(Output_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_port_identifier

	return p
}

func (s *Output_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Output_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterOutput_port_identifier(s)
	}
}

func (s *Output_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitOutput_port_identifier(s)
	}
}

func (p *VerilogParser) Output_port_identifier() (localctx IOutput_port_identifierContext) {
	localctx = NewOutput_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, VerilogParserRULE_output_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3961)
		p.Identifier()
	}

	return localctx
}

// IParameter_identifierContext is an interface to support dynamic dispatch.
type IParameter_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_identifierContext differentiates from other interfaces.
	IsParameter_identifierContext()
}

type Parameter_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_identifierContext() *Parameter_identifierContext {
	var p = new(Parameter_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_identifier
	return p
}

func (*Parameter_identifierContext) IsParameter_identifierContext() {}

func NewParameter_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_identifierContext {
	var p = new(Parameter_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_identifier

	return p
}

func (s *Parameter_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Parameter_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterParameter_identifier(s)
	}
}

func (s *Parameter_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitParameter_identifier(s)
	}
}

func (p *VerilogParser) Parameter_identifier() (localctx IParameter_identifierContext) {
	localctx = NewParameter_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, VerilogParserRULE_parameter_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3963)
		p.Identifier()
	}

	return localctx
}

// IPort_identifierContext is an interface to support dynamic dispatch.
type IPort_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_identifierContext differentiates from other interfaces.
	IsPort_identifierContext()
}

type Port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_identifierContext() *Port_identifierContext {
	var p = new(Port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port_identifier
	return p
}

func (*Port_identifierContext) IsPort_identifierContext() {}

func NewPort_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_identifierContext {
	var p = new(Port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port_identifier

	return p
}

func (s *Port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterPort_identifier(s)
	}
}

func (s *Port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitPort_identifier(s)
	}
}

func (p *VerilogParser) Port_identifier() (localctx IPort_identifierContext) {
	localctx = NewPort_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, VerilogParserRULE_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3965)
		p.Identifier()
	}

	return localctx
}

// IReal_identifierContext is an interface to support dynamic dispatch.
type IReal_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_identifierContext differentiates from other interfaces.
	IsReal_identifierContext()
}

type Real_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_identifierContext() *Real_identifierContext {
	var p = new(Real_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_real_identifier
	return p
}

func (*Real_identifierContext) IsReal_identifierContext() {}

func NewReal_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_identifierContext {
	var p = new(Real_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_real_identifier

	return p
}

func (s *Real_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Real_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterReal_identifier(s)
	}
}

func (s *Real_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitReal_identifier(s)
	}
}

func (p *VerilogParser) Real_identifier() (localctx IReal_identifierContext) {
	localctx = NewReal_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, VerilogParserRULE_real_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3967)
		p.Identifier()
	}

	return localctx
}

// ISimple_arrayed_identifierContext is an interface to support dynamic dispatch.
type ISimple_arrayed_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_arrayed_identifierContext differentiates from other interfaces.
	IsSimple_arrayed_identifierContext()
}

type Simple_arrayed_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_arrayed_identifierContext() *Simple_arrayed_identifierContext {
	var p = new(Simple_arrayed_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_simple_arrayed_identifier
	return p
}

func (*Simple_arrayed_identifierContext) IsSimple_arrayed_identifierContext() {}

func NewSimple_arrayed_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_arrayed_identifierContext {
	var p = new(Simple_arrayed_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_simple_arrayed_identifier

	return p
}

func (s *Simple_arrayed_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_arrayed_identifierContext) Simple_identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserSimple_identifier, 0)
}

func (s *Simple_arrayed_identifierContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Simple_arrayed_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_arrayed_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_arrayed_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSimple_arrayed_identifier(s)
	}
}

func (s *Simple_arrayed_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSimple_arrayed_identifier(s)
	}
}

func (p *VerilogParser) Simple_arrayed_identifier() (localctx ISimple_arrayed_identifierContext) {
	localctx = NewSimple_arrayed_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, VerilogParserRULE_simple_arrayed_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3969)
		p.Match(VerilogParserSimple_identifier)
	}
	p.SetState(3971)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 412, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3970)
			p.Range_()
		}

	}

	return localctx
}

// ISimple_hierarchical_identifierContext is an interface to support dynamic dispatch.
type ISimple_hierarchical_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_hierarchical_identifierContext differentiates from other interfaces.
	IsSimple_hierarchical_identifierContext()
}

type Simple_hierarchical_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_hierarchical_identifierContext() *Simple_hierarchical_identifierContext {
	var p = new(Simple_hierarchical_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_simple_hierarchical_identifier
	return p
}

func (*Simple_hierarchical_identifierContext) IsSimple_hierarchical_identifierContext() {}

func NewSimple_hierarchical_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_hierarchical_identifierContext {
	var p = new(Simple_hierarchical_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_simple_hierarchical_identifier

	return p
}

func (s *Simple_hierarchical_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_hierarchical_identifierContext) Simple_hierarchical_branch() ISimple_hierarchical_branchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_hierarchical_branchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_hierarchical_branchContext)
}

func (s *Simple_hierarchical_identifierContext) Escaped_identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserEscaped_identifier, 0)
}

func (s *Simple_hierarchical_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_hierarchical_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_hierarchical_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSimple_hierarchical_identifier(s)
	}
}

func (s *Simple_hierarchical_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSimple_hierarchical_identifier(s)
	}
}

func (p *VerilogParser) Simple_hierarchical_identifier() (localctx ISimple_hierarchical_identifierContext) {
	localctx = NewSimple_hierarchical_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, VerilogParserRULE_simple_hierarchical_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3973)
		p.Simple_hierarchical_branch()
	}
	p.SetState(3976)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserT__4 {
		{
			p.SetState(3974)
			p.Match(VerilogParserT__4)
		}
		{
			p.SetState(3975)
			p.Match(VerilogParserEscaped_identifier)
		}

	}

	return localctx
}

// ISpecparam_identifierContext is an interface to support dynamic dispatch.
type ISpecparam_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecparam_identifierContext differentiates from other interfaces.
	IsSpecparam_identifierContext()
}

type Specparam_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecparam_identifierContext() *Specparam_identifierContext {
	var p = new(Specparam_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specparam_identifier
	return p
}

func (*Specparam_identifierContext) IsSpecparam_identifierContext() {}

func NewSpecparam_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specparam_identifierContext {
	var p = new(Specparam_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specparam_identifier

	return p
}

func (s *Specparam_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Specparam_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Specparam_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specparam_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specparam_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSpecparam_identifier(s)
	}
}

func (s *Specparam_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSpecparam_identifier(s)
	}
}

func (p *VerilogParser) Specparam_identifier() (localctx ISpecparam_identifierContext) {
	localctx = NewSpecparam_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, VerilogParserRULE_specparam_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3978)
		p.Identifier()
	}

	return localctx
}

// ISystem_function_identifierContext is an interface to support dynamic dispatch.
type ISystem_function_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_function_identifierContext differentiates from other interfaces.
	IsSystem_function_identifierContext()
}

type System_function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_function_identifierContext() *System_function_identifierContext {
	var p = new(System_function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_system_function_identifier
	return p
}

func (*System_function_identifierContext) IsSystem_function_identifierContext() {}

func NewSystem_function_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_function_identifierContext {
	var p = new(System_function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_system_function_identifier

	return p
}

func (s *System_function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *System_function_identifierContext) Dollar_Identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserDollar_Identifier, 0)
}

func (s *System_function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSystem_function_identifier(s)
	}
}

func (s *System_function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSystem_function_identifier(s)
	}
}

func (p *VerilogParser) System_function_identifier() (localctx ISystem_function_identifierContext) {
	localctx = NewSystem_function_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, VerilogParserRULE_system_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3980)
		p.Match(VerilogParserDollar_Identifier)
	}

	return localctx
}

// ISystem_task_identifierContext is an interface to support dynamic dispatch.
type ISystem_task_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_task_identifierContext differentiates from other interfaces.
	IsSystem_task_identifierContext()
}

type System_task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_task_identifierContext() *System_task_identifierContext {
	var p = new(System_task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_system_task_identifier
	return p
}

func (*System_task_identifierContext) IsSystem_task_identifierContext() {}

func NewSystem_task_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_task_identifierContext {
	var p = new(System_task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_system_task_identifier

	return p
}

func (s *System_task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *System_task_identifierContext) Dollar_Identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserDollar_Identifier, 0)
}

func (s *System_task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSystem_task_identifier(s)
	}
}

func (s *System_task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSystem_task_identifier(s)
	}
}

func (p *VerilogParser) System_task_identifier() (localctx ISystem_task_identifierContext) {
	localctx = NewSystem_task_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, VerilogParserRULE_system_task_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3982)
		p.Match(VerilogParserDollar_Identifier)
	}

	return localctx
}

// ITask_identifierContext is an interface to support dynamic dispatch.
type ITask_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_identifierContext differentiates from other interfaces.
	IsTask_identifierContext()
}

type Task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_identifierContext() *Task_identifierContext {
	var p = new(Task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_identifier
	return p
}

func (*Task_identifierContext) IsTask_identifierContext() {}

func NewTask_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_identifierContext {
	var p = new(Task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_identifier

	return p
}

func (s *Task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTask_identifier(s)
	}
}

func (s *Task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTask_identifier(s)
	}
}

func (p *VerilogParser) Task_identifier() (localctx ITask_identifierContext) {
	localctx = NewTask_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, VerilogParserRULE_task_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3984)
		p.Identifier()
	}

	return localctx
}

// ITerminal_identifierContext is an interface to support dynamic dispatch.
type ITerminal_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminal_identifierContext differentiates from other interfaces.
	IsTerminal_identifierContext()
}

type Terminal_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminal_identifierContext() *Terminal_identifierContext {
	var p = new(Terminal_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_terminal_identifier
	return p
}

func (*Terminal_identifierContext) IsTerminal_identifierContext() {}

func NewTerminal_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Terminal_identifierContext {
	var p = new(Terminal_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_terminal_identifier

	return p
}

func (s *Terminal_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Terminal_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Terminal_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Terminal_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Terminal_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTerminal_identifier(s)
	}
}

func (s *Terminal_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTerminal_identifier(s)
	}
}

func (p *VerilogParser) Terminal_identifier() (localctx ITerminal_identifierContext) {
	localctx = NewTerminal_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, VerilogParserRULE_terminal_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3986)
		p.Identifier()
	}

	return localctx
}

// IText_macro_identifierContext is an interface to support dynamic dispatch.
type IText_macro_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_macro_identifierContext differentiates from other interfaces.
	IsText_macro_identifierContext()
}

type Text_macro_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_macro_identifierContext() *Text_macro_identifierContext {
	var p = new(Text_macro_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_text_macro_identifier
	return p
}

func (*Text_macro_identifierContext) IsText_macro_identifierContext() {}

func NewText_macro_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_macro_identifierContext {
	var p = new(Text_macro_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_text_macro_identifier

	return p
}

func (s *Text_macro_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_macro_identifierContext) Simple_identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserSimple_identifier, 0)
}

func (s *Text_macro_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_macro_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_macro_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterText_macro_identifier(s)
	}
}

func (s *Text_macro_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitText_macro_identifier(s)
	}
}

func (p *VerilogParser) Text_macro_identifier() (localctx IText_macro_identifierContext) {
	localctx = NewText_macro_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, VerilogParserRULE_text_macro_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3988)
		p.Match(VerilogParserSimple_identifier)
	}

	return localctx
}

// ITopmodule_identifierContext is an interface to support dynamic dispatch.
type ITopmodule_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopmodule_identifierContext differentiates from other interfaces.
	IsTopmodule_identifierContext()
}

type Topmodule_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopmodule_identifierContext() *Topmodule_identifierContext {
	var p = new(Topmodule_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_topmodule_identifier
	return p
}

func (*Topmodule_identifierContext) IsTopmodule_identifierContext() {}

func NewTopmodule_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topmodule_identifierContext {
	var p = new(Topmodule_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_topmodule_identifier

	return p
}

func (s *Topmodule_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Topmodule_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Topmodule_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topmodule_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topmodule_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterTopmodule_identifier(s)
	}
}

func (s *Topmodule_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitTopmodule_identifier(s)
	}
}

func (p *VerilogParser) Topmodule_identifier() (localctx ITopmodule_identifierContext) {
	localctx = NewTopmodule_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, VerilogParserRULE_topmodule_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3990)
		p.Identifier()
	}

	return localctx
}

// IUdp_identifierContext is an interface to support dynamic dispatch.
type IUdp_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUdp_identifierContext differentiates from other interfaces.
	IsUdp_identifierContext()
}

type Udp_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUdp_identifierContext() *Udp_identifierContext {
	var p = new(Udp_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_udp_identifier
	return p
}

func (*Udp_identifierContext) IsUdp_identifierContext() {}

func NewUdp_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Udp_identifierContext {
	var p = new(Udp_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_udp_identifier

	return p
}

func (s *Udp_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Udp_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Udp_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Udp_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Udp_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterUdp_identifier(s)
	}
}

func (s *Udp_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitUdp_identifier(s)
	}
}

func (p *VerilogParser) Udp_identifier() (localctx IUdp_identifierContext) {
	localctx = NewUdp_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, VerilogParserRULE_udp_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3992)
		p.Identifier()
	}

	return localctx
}

// IUdp_instance_identifierContext is an interface to support dynamic dispatch.
type IUdp_instance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUdp_instance_identifierContext differentiates from other interfaces.
	IsUdp_instance_identifierContext()
}

type Udp_instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUdp_instance_identifierContext() *Udp_instance_identifierContext {
	var p = new(Udp_instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_udp_instance_identifier
	return p
}

func (*Udp_instance_identifierContext) IsUdp_instance_identifierContext() {}

func NewUdp_instance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Udp_instance_identifierContext {
	var p = new(Udp_instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_udp_instance_identifier

	return p
}

func (s *Udp_instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Udp_instance_identifierContext) Arrayed_identifier() IArrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayed_identifierContext)
}

func (s *Udp_instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Udp_instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Udp_instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterUdp_instance_identifier(s)
	}
}

func (s *Udp_instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitUdp_instance_identifier(s)
	}
}

func (p *VerilogParser) Udp_instance_identifier() (localctx IUdp_instance_identifierContext) {
	localctx = NewUdp_instance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, VerilogParserRULE_udp_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3994)
		p.Arrayed_identifier()
	}

	return localctx
}

// IVariable_identifierContext is an interface to support dynamic dispatch.
type IVariable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_identifierContext differentiates from other interfaces.
	IsVariable_identifierContext()
}

type Variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_identifierContext() *Variable_identifierContext {
	var p = new(Variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_identifier
	return p
}

func (*Variable_identifierContext) IsVariable_identifierContext() {}

func NewVariable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_identifierContext {
	var p = new(Variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_identifier

	return p
}

func (s *Variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterVariable_identifier(s)
	}
}

func (s *Variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitVariable_identifier(s)
	}
}

func (p *VerilogParser) Variable_identifier() (localctx IVariable_identifierContext) {
	localctx = NewVariable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, VerilogParserRULE_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3996)
		p.Identifier()
	}

	return localctx
}

// ISimple_hierarchical_branchContext is an interface to support dynamic dispatch.
type ISimple_hierarchical_branchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_hierarchical_branchContext differentiates from other interfaces.
	IsSimple_hierarchical_branchContext()
}

type Simple_hierarchical_branchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_hierarchical_branchContext() *Simple_hierarchical_branchContext {
	var p = new(Simple_hierarchical_branchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_simple_hierarchical_branch
	return p
}

func (*Simple_hierarchical_branchContext) IsSimple_hierarchical_branchContext() {}

func NewSimple_hierarchical_branchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_hierarchical_branchContext {
	var p = new(Simple_hierarchical_branchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_simple_hierarchical_branch

	return p
}

func (s *Simple_hierarchical_branchContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_hierarchical_branchContext) AllSimple_identifier() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserSimple_identifier)
}

func (s *Simple_hierarchical_branchContext) Simple_identifier(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserSimple_identifier, i)
}

func (s *Simple_hierarchical_branchContext) AllDecimal_number() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserDecimal_number)
}

func (s *Simple_hierarchical_branchContext) Decimal_number(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserDecimal_number, i)
}

func (s *Simple_hierarchical_branchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_hierarchical_branchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_hierarchical_branchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterSimple_hierarchical_branch(s)
	}
}

func (s *Simple_hierarchical_branchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitSimple_hierarchical_branch(s)
	}
}

func (p *VerilogParser) Simple_hierarchical_branch() (localctx ISimple_hierarchical_branchContext) {
	localctx = NewSimple_hierarchical_branchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, VerilogParserRULE_simple_hierarchical_branch)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3998)
		p.Match(VerilogParserSimple_identifier)
	}
	p.SetState(4002)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 414, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3999)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(4000)
			p.Match(VerilogParserDecimal_number)
		}
		{
			p.SetState(4001)
			p.Match(VerilogParserT__21)
		}

	}
	p.SetState(4013)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 416, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4004)
				p.Match(VerilogParserT__4)
			}
			{
				p.SetState(4005)
				p.Match(VerilogParserSimple_identifier)
			}
			p.SetState(4009)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 415, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4006)
					p.Match(VerilogParserT__20)
				}
				{
					p.SetState(4007)
					p.Match(VerilogParserDecimal_number)
				}
				{
					p.SetState(4008)
					p.Match(VerilogParserT__21)
				}

			}

		}
		p.SetState(4015)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 416, p.GetParserRuleContext())
	}

	return localctx
}

// IEscaped_hierarchical_branchContext is an interface to support dynamic dispatch.
type IEscaped_hierarchical_branchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEscaped_hierarchical_branchContext differentiates from other interfaces.
	IsEscaped_hierarchical_branchContext()
}

type Escaped_hierarchical_branchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscaped_hierarchical_branchContext() *Escaped_hierarchical_branchContext {
	var p = new(Escaped_hierarchical_branchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_escaped_hierarchical_branch
	return p
}

func (*Escaped_hierarchical_branchContext) IsEscaped_hierarchical_branchContext() {}

func NewEscaped_hierarchical_branchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Escaped_hierarchical_branchContext {
	var p = new(Escaped_hierarchical_branchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_escaped_hierarchical_branch

	return p
}

func (s *Escaped_hierarchical_branchContext) GetParser() antlr.Parser { return s.parser }

func (s *Escaped_hierarchical_branchContext) AllEscaped_identifier() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserEscaped_identifier)
}

func (s *Escaped_hierarchical_branchContext) Escaped_identifier(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserEscaped_identifier, i)
}

func (s *Escaped_hierarchical_branchContext) AllDecimal_number() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserDecimal_number)
}

func (s *Escaped_hierarchical_branchContext) Decimal_number(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserDecimal_number, i)
}

func (s *Escaped_hierarchical_branchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Escaped_hierarchical_branchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Escaped_hierarchical_branchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.EnterEscaped_hierarchical_branch(s)
	}
}

func (s *Escaped_hierarchical_branchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogListener); ok {
		listenerT.ExitEscaped_hierarchical_branch(s)
	}
}

func (p *VerilogParser) Escaped_hierarchical_branch() (localctx IEscaped_hierarchical_branchContext) {
	localctx = NewEscaped_hierarchical_branchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, VerilogParserRULE_escaped_hierarchical_branch)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4016)
		p.Match(VerilogParserEscaped_identifier)
	}
	p.SetState(4020)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 417, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4017)
			p.Match(VerilogParserT__20)
		}
		{
			p.SetState(4018)
			p.Match(VerilogParserDecimal_number)
		}
		{
			p.SetState(4019)
			p.Match(VerilogParserT__21)
		}

	}
	p.SetState(4031)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 419, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4022)
				p.Match(VerilogParserT__4)
			}
			{
				p.SetState(4023)
				p.Match(VerilogParserEscaped_identifier)
			}
			p.SetState(4027)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 418, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4024)
					p.Match(VerilogParserT__20)
				}
				{
					p.SetState(4025)
					p.Match(VerilogParserDecimal_number)
				}
				{
					p.SetState(4026)
					p.Match(VerilogParserT__21)
				}

			}

		}
		p.SetState(4033)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 419, p.GetParserRuleContext())
	}

	return localctx
}
